{"meta":{"title":"qiushao","subtitle":"","description":"Android system development notes","author":"qiushao","url":"http://qiushao.net","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-12-27T01:22:23.740Z","updated":"2020-12-27T01:22:23.740Z","comments":false,"path":"/404.html","permalink":"http://qiushao.net/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-12-27T01:22:23.748Z","updated":"2020-12-27T01:22:23.748Z","comments":false,"path":"about/index.html","permalink":"http://qiushao.net/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2020-12-27T01:22:23.748Z","updated":"2020-12-27T01:22:23.748Z","comments":false,"path":"books/index.html","permalink":"http://qiushao.net/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-12-27T01:22:23.748Z","updated":"2020-12-27T01:22:23.748Z","comments":false,"path":"categories/index.html","permalink":"http://qiushao.net/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-12-27T01:22:23.764Z","updated":"2020-12-27T01:22:23.764Z","comments":true,"path":"links/index.html","permalink":"http://qiushao.net/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-12-27T01:22:23.764Z","updated":"2020-12-27T01:22:23.764Z","comments":false,"path":"repository/index.html","permalink":"http://qiushao.net/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-12-27T01:22:23.764Z","updated":"2020-12-27T01:22:23.764Z","comments":false,"path":"tags/index.html","permalink":"http://qiushao.net/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux profile 和 bashrc 的区别","slug":"Linux/linux-profile-bashrc-difference","date":"2020-12-27T01:22:23.744Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/12/27/Linux/linux-profile-bashrc-difference/","link":"","permalink":"http://qiushao.net/2020/12/27/Linux/linux-profile-bashrc-difference/","excerpt":"","text":"Linux 系统上有四个环境配置文件，分别为: /etc/profile /etc/bash.bashrc ~/.profile ~/.bashrc 1. 先从作用域来说/etc 目录下的配置文件影响所有用户。~/ 用户家目录下的配置文件只影响本用户。 2. 从加载时机来说profile 是用户在登录系统的时候加载的。profile 在用户登录使用的过程中只加载一次。修改之后，需要重启系统生效。我们把 profile 叫做登录式 SHELL 配置文件，bashrc 是用户在启动 bash shell 的时候加载的。也就是启动一个 terminal 终端的时候加载。修改之后，只要重启 terminal 就生效了。或者手动 source ~/.bashrc 也能生效。我们把 bashrc 叫做非登录式 SHELL 配置。 3. 各文件的加载流程登陆式 SHELLL 配置文件加载顺序:/etc/profile &gt; .bash_profile &gt; .bash_login &gt; .profile &gt; .bash_logout非登录式 SHELL 配置文件加载顺序:/etc/bash.bashrc &gt; .bashrc 4. 知识点应用举例问题：在 clion 中设置交叉编译环境，获取不到 .bashrc 中设置的 PATH 环境变量。 在 ~/.bashrc 中设置交叉编译工具环境变量 1export PATH&#x3D;$PATH:&#x2F;media&#x2F;deep&#x2F;source-code&#x2F;Hi3516&#x2F;sourceCode&#x2F;toolchain&#x2F;arm-himix200-linux&#x2F;bin 在 clion 中设置交叉编译工具 123set(CMAKE_SYSTEM_NAME Linux)set(CMAKE_C_COMPILER arm-himix200-linux-gcc)set(CMAKE_CXX_COMPILER arm-himix200-linux-g++) clion 中提示 arm-himix200-linux-gcc 找不到。但直接在 terminal 中执行 cmake 是可以编译成功的。 原因分析：clion 是由 gnome 桌面启动的。gnome 是由登录式 shell 启动的。因此环境变量是继承的登录式 shell 的环境变量。也就是 profile 配置的环境变量。profile 中没配置 arm-himix200-linux 路径，因此找不到。启动的终端是非登录式 shell。会加载 bashrc 文件, 因此能找到 arm-himix200-linux。 解决方案：在 ~/.profile 中设置编译工具环境变量，然后重启即可。 123456789qiushao@qiushao-PC:~$ tail .profile # set PATH so it includes user&#39;s private bin if it existsif [ -d &quot;$HOME&#x2F;.local&#x2F;bin&quot; ] ; then PATH&#x3D;&quot;$HOME&#x2F;.local&#x2F;bin:$PATH&quot;fiexport PATH&#x3D;$PATH:&#x2F;media&#x2F;deep&#x2F;source-code&#x2F;Hi3516&#x2F;sourceCode&#x2F;toolchain&#x2F;arm-himix200-linux&#x2F;binqiushao@qiushao-PC:~$","categories":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/tags/Linux/"}]},{"title":"Linux Mint 20 安装 QT5","slug":"Linux/linuxmint-install-qt5","date":"2020-07-31T14:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/07/31/Linux/linuxmint-install-qt5/","link":"","permalink":"http://qiushao.net/2020/07/31/Linux/linuxmint-install-qt5/","excerpt":"","text":"最近想写些 pc 的小工具给自己使用。决定使用 qt5 来开发，首先需要安装开发包。网上的教程基本都是从 qt 官网上下载安装包安装的，另外一些教程则只是安装了基本开发包而已，没有安装文档和 example 的。因此记录一下使用 apt 安装 qt5 开发包及文档，example 的过程。 1. 安装 qt5 基本开发包1sudo apt install build-essential qt5-default qtcreator 如果你不需要看文档和例子的话，这样子就足够了。但对于我这种新手菜鸡来说，没有例子来学习是不行的。 2. 安装开发文档和例子1sudo apt install qt5-doc qt5-doc-html qtbase5-doc-html qtbase5-examples 安装完后，打开 qtcreator ，示例里面就可以看到各种各样的例子了。以上只是安装了 qt5 的基本界面开发包，文档及例子而已。qt5 还把很多开发包给拆分了出来，比如说串口，多媒体，webengine 等。大家根据自己需要来选择安装。 3. 安装串口相关的开发包及文档这次是想写个串口工具，因此需要用到串口开发包，我们可以这样查找一下 qt 都提供了哪些扩展开发包 123456789101112131415161718192021222324mint@mint-pc:~$ apt search libqt | grep dev | grep -v i386p libqt5-ukui-style-dev - Development files of libqt5-ukui-style1 p libqt5charts5-dev - Qt charts development files p libqt5datavisualization5-dev - APIs for data visualization functionality - development files p libqt5gamepad5-dev - Qt 5 gamepad module - development files p libqt5gstreamer-dev - Development headers for QtGStreamer - Qt 5 build p libqt5networkauth5-dev - online account access for Qt apps - Development Files v libqt5opengl5-desktop-dev - i A libqt5opengl5-dev - Qt 5 OpenGL library development files p libqt5pas-dev - Development files for Qt5Pas p libqt5remoteobjects5-dev - Qt module for IPC — development files v libqt5scintilla2-dev - p libqt5scxml5-dev - Qt module for creating state machines from SCXML files development p libqt5sensors5-dev - Qt 5 Sensors development files p libqt5serialbus5-dev - Qt serialbus serial bus access development p libqt5serialport5-dev - Qt 5 serial port development files p libqt5svg5-dev - Qt 5 SVG module development files p libqt5texttospeech5-dev - Speech library for Qt - development files p libqt5virtualkeyboard5-dev - Qt virtual keyboard - development files p libqt5waylandclient5-dev - QtWayland client development files p libqt5waylandcompositor5-dev - QtWayland compositor development files p libqt5webchannel5-dev - Web communication library for Qt - development files p libqt5webkit5-dev - Web content engine library for Qt - development files p libqt5websockets5-dev - Qt 5 Web Sockets module - development files 我们可以看到有很多模块开发包，比如 gamepad, gstreamer, opengl, sensor, serialport 等，这里我们要安装的串口开发模块是 libqt5serialport5-dev。相关的开发文档可以这么搜索 1234mint@mint-pc:~$ apt search qt5serialportp A libqt5serialport5 - Qt 5 serial port support p libqt5serialport5-dev - Qt 5 serial port development files p qt5serialport-examples - Qt 5 serial port examples 因此我们要安装以下两个包 1sudo apt install libqt5serialport5-dev qt5serialport-examples 安装完之后，重启 qtcreator，我们就可以看到多出了一些串口相关的例子。 其他的模块也是类似的安装方法。 使用 clion 来开发 qt 程序使用过各种 IDE, 发现还是 clion 最好用。qtcreator 只是用来看文档和例子而已只要在 CMakeLists.txt 中添加以下配置即可： 1234567891011121314151617181920212223# qt5 setttingsset(CMAKE_INCLUDE_CURRENT_DIR ON)set(CMAKE_AUTOMOC ON)set(CMAKE_AUTOUIC ON)set(CMAKE_AUTORCC ON)find_package(Qt5 REQUIRED Widgets SerialPort)FILE(GLOB_RECURSE header_list \"src/*.h\")FILE(GLOB_RECURSE cpp_list \"src/*.cpp\")# qt5 settings, 信号，槽相关qt5_wrap_cpp(MOC $&#123;cpp_list&#125;)# qt5 settings, 有资源文件的话，需要做以下配置#set(RESOURCE_DIR res/resources.qrc)#qt5_wrap_ui(UIC widget.ui)#qt5_add_resources(RCC resources.qrc)add_executable(qsterminal $&#123;cpp_list&#125; $&#123;header_list&#125;)# qt5 settingstarget_link_libraries(qsterminal Qt5::Widgets Qt5::SerialPort)","categories":[{"name":"QT","slug":"QT","permalink":"http://qiushao.net/categories/QT/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/tags/Linux/"},{"name":"QT","slug":"QT","permalink":"http://qiushao.net/tags/QT/"}]},{"title":"Linux Mint 20 安装微信","slug":"Linux/linuxmint-install-wechat","date":"2020-07-28T14:00:00.000Z","updated":"2021-01-04T13:37:15.247Z","comments":true,"path":"2020/07/28/Linux/linuxmint-install-wechat/","link":"","permalink":"http://qiushao.net/2020/07/28/Linux/linuxmint-install-wechat/","excerpt":"","text":"最近 Linux Mint 20 发布了，手痒又折腾了一下。体验了几天，个人感觉非常好，就是国产那堆应用安装麻烦了一点。感谢 deepin 对很多国产应用做了移植，适配工作，让我们可以直接在 debian 系的系统上直接安装使用。下面以安装微信为例说明一下在 debian 系的系统上怎么安装 deepin 适配过的部分国产应用。 1. 添加 apt source在 /etc/apt/sources.list.d/ 目录下新建文件 deepin-wine.list，内容如下: 1deb [trusted&#x3D;yes] https:&#x2F;&#x2F;deepin-wine.i-m.dev &#x2F; deepin 把QQ/微信之类的 deepin wine 应用打包放在了 deepin 仓库中，因此先提取出这些应用及依赖的软件包，再减去 Debian/Ubuntu 等发行版官方仓库中固有的软件包，就可以打包成一个移植于对应发行版的“差量仓库”。感谢这个仓库的作者 https://github.com/zq1997/deepin-wine ，想了解更多的细节的话，可以去这个仓库看看。 2. 刷新软件源1sudo apt update 3. 查看 deepin-wine 相关的软件包12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455mint@mint-pc:~$ apt search deepinp deepin-calculator - Calculator for DDE (Deepin Desktop Environment) p deepin-deb-installer - Deepin Package Manager i A deepin-fonts-wine - Windows API implementation - fonts v deepin-fonts-wine:i386 - p deepin-gettext-tools - Deepin Internationalization utilities p deepin-icon-theme - Icon Theme for Deepin software and Deepin Desktop Environment p deepin-image-viewer - Image Viewer for Deepin Desktop Environment i A deepin-libwine:i386 - Windows API implementation - library p deepin-menu - Deepin menu service p deepin-movie - Deepin movie player p deepin-music - music player with brilliant and tweakful UI p deepin-notifications - System notifications for Deepin Desktop Environment p deepin-picker - Color picker tool for deepin p deepin-screen-recorder - Simple recorder tools for deepin 视频录制工具 p deepin-screenshot - Advanced screen shoting tool 截图工具 p deepin-shortcut-viewer - Pop-up shortcut viewer for Deepin applications p deepin-terminal - Deepin terminal emulator application p deepin-voice-recorder - Deepin&#39;s Voice recorder 录音工具 i A deepin-wine - Windows API implementation - standard suite v deepin-wine:i386 - i A deepin-wine-helper:i386 - Deepin Wine Helper v deepin-wine-plugin - i A deepin-wine-plugin:i386 - Deepin Wine plugin i A deepin-wine-plugin-virtual - Deepin Wine plugin virtual package v deepin-wine-plugin-virtual:i386 - i A deepin-wine-uninstaller:i386 - Deepin Wine Uninstaller Tool v deepin-wine32 - i A deepin-wine32:i386 - Windows API implementation - 32-bit binary loader i A deepin-wine32-preloader:i386 - Windows API implementation - prelinked 32-bit binary loader p deepin.cn.360.yasuo:i386 - 360zip on Deepin Wine p deepin.cn.com.winrar:i386 - WinRAR on Deepin Wine p deepin.com.95579.cjsc:i386 - CHANGJIANG SECURITIES Client on Deepin Wine p deepin.com.aaa-logo:i386 - SWGSoft AAALogo on Deepin Wine p deepin.com.baidu.pan:i386 - Baidu net disk client on Deepin Wine 百度网盘 p deepin.com.cmbchina:i386 - CMBChina Client on Deepin Wine i deepin.com.foxmail:i386 - Tencent Foxmail Client on Deepin Wine p deepin.com.gtja.fuyi:i386 - GUOTAI JUNAN SECURITIES RichEasy Client on Deepin Wine p deepin.com.qq.b.crm:i386 - Tencent bizQQ Client on Deepin Wine p deepin.com.qq.b.eim:i386 - Tencent QQEIM Client on Deepin Wine p deepin.com.qq.im:i386 - Tencent QQ Client on Deepin Wine QQ p deepin.com.qq.im.light:i386 - Tencent QQ Client on Deepin Wine TIM p deepin.com.qq.office:i386 - Tencent TIM Client on Deepin Wine p deepin.com.qq.rtx2015:i386 - Tencent QQ Client on Deepin Wine p deepin.com.taobao.aliclient.qianniu:i386 - Ali Qian Niu Client on Deepin Wine 阿里千牛 p deepin.com.taobao.wangwang:i386 - Ali WangWang Client on Deepin Wine 阿里旺旺 p deepin.com.thunderspeed:i386 - Thunder Speed Client on Deepin Wine 迅雷下载 i deepin.com.wechat:i386 - Tencent WeChat Client on Deepin Wine 微信 p deepin.com.weixin.work:i386 - Tencent WeChat Work Client on Deepin Wine 企业微信 p deepin.net.263.em:i386 - 263 EM Client on Deepin Wine p deepin.org.7-zip:i386 - 7-Zip on Deepin Wine p deepin.org.foobar2000:i386 - Foobar2000 on Deepin Wine v deepinwine-cmbchina:i386 - v libqt5deepintheme-plugin - mint@mint-pc:~$ 根据包名大概可以知道是哪些软件。 4. 安装微信只要执行以下命令即可 123sudo apt install deepin.com.wechatsudo apt install deepin-screenshot sudo apt install libjpeg62:i386 deepin-screenshot ：深度截图libjpeg62:i386 ：不安装这个包的话，发送不了截图。 之前旧版本安装完之后，就可以直接从应用列表里面看到了，但 2020-10 月之后更新了新版本，新版本的安装位置变成了 /opt/apps，这个路径不在标准的应用 desktop 配置搜索路径。所以新版本还要做些设置才能在应用列表里面显示。在 ~/.profile 文件最后面添加以下配置： 1234567XDG_DATA_DIRS&#x3D;$&#123;XDG_DATA_DIRS:-&#x2F;usr&#x2F;local&#x2F;share:&#x2F;usr&#x2F;share&#125;for deepin_dir in &#x2F;opt&#x2F;apps&#x2F;*&#x2F;entries; do if [ -d &quot;$deepin_dir&#x2F;applications&quot; ]; then XDG_DATA_DIRS&#x3D;&quot;$XDG_DATA_DIRS:$deepin_dir&quot; fidoneexport XDG_DATA_DIRS 然后重启就行了 5. 截图默认的截图快捷键是 Alt + A，但这个快捷键只有焦点在微信界面的时候才可以使用。为了能够全局截图，我们可以使用深度截图。打开 系统设置 –&gt; 键盘 –&gt; 快捷键 –&gt; 自定义快捷键设置如下： 然后就可以全局使用 Ctrl + Alt + A 来截图啦。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/tags/Linux/"}]},{"title":"内存泄漏分析工具：tcmalloc","slug":"Linux/memory-leak-analyze-tcmalloc","date":"2020-07-11T12:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/07/11/Linux/memory-leak-analyze-tcmalloc/","link":"","permalink":"http://qiushao.net/2020/07/11/Linux/memory-leak-analyze-tcmalloc/","excerpt":"","text":"最近遇到一个内存泄漏的问题。由于代码量比较庞大，且使用了很多第三方库，部分第三方库还是商业闭源的，没法通过 code review 还排查了。对于闭源部分的库，静态代码检查工具也没法派上用场。所以一直在寻找一个能够追踪内存分配，释放，定位内存泄漏点的工具。尝试了 valgrind 和 gperftools。由于是嵌入式开发，内存，cpu 都比较有限。valgrind 资源占用太多，应用根本就没法跑起来。后面了解了 gperftools 的原理后，觉得内存，cpu 的占用应该是可以接受的，所以就一直折腾 gperftools，经过几天的折腾，总算靠 gperftools 这个工具找出了内存泄漏的真凶。下面介绍一下 gperftools 工具的使用方法。 1. 下载编译先从 github 上下载最新版本的代码 123qiushao@qiushao-pc:~/projects/opensources$ git clone https://github.com/gperftools/gperftoolsqiushao@qiushao-pc:~/projects/opensources$ cd gperftoolsqiushao@qiushao-pc:~/projects/opensources/gperftools$ 我们先编译安装 pc 上使用的版本： 1234qiushao@qiushao-pc:~/projects/opensources/gperftools$ ./autogen.shqiushao@qiushao-pc:~/projects/opensources/gperftools$ ./configureqiushao@qiushao-pc:~/projects/opensources/gperftools$ make -jqiushao@qiushao-pc:~/projects/opensources/gperftools$ sudo make install 如果是需要交叉编译的话，则再重新编译。 ./configure 时指定目标平台，编译工具链即可。只需要编译，不需要安装，后面我们直接 copy so 库到板子上就行： 123qiushao@qiushao-pc:~/projects/opensources/gperftools$ make cleanqiushao@qiushao-pc:~/projects/opensources/gperftools$ ./configure --host=arm-linux CXX=arm-himix200-linux-g++ CC=arm-himix200-linux-gccqiushao@qiushao-pc:~/projects/opensources/gperftools$ make -j 编译的结果在 .libs 目录下，gperftools 是一个工具集合，我们分析内存泄漏问题时，只需要使用其中的 libtcmalloc.so 即可。 12345qiushao@qiushao-pc:~/projects/opensources/gperftools$ file .libs/libtcmalloc.so*.libs/libtcmalloc.so: symbolic link to libtcmalloc.so.4.5.5.libs/libtcmalloc.so.4: symbolic link to libtcmalloc.so.4.5.5.libs/libtcmalloc.so.4.5.5: ELF 32-bit LSB shared object, ARM, EABI5 version 1 (GNU/Linux), dynamically linked, with debug_info, not strippedqiushao@qiushao-pc:~/projects/opensources/gperftools$ 2. tcmalloc 使用我们先在 pc 上测试一下效果，如果能满足我们的需求的话，再到板子上进行测试。先写个有内存泄漏的 demo： 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char* get_buffer(size_t size) &#123; char *buffer = (char *)malloc(size); // 这里分配了内存，但后面 leak_memory 函数使用完之后没有释放，造成内存泄漏。 memset(buffer, 0, size); return buffer;&#125;void leak_memory() &#123; char *buffer = get_buffer(1024 * 1024); sprintf(buffer, \"do something with buffer\"); printf(\"%s\\n\", buffer);&#125;int main() &#123; printf(\"tcmalloc test\"); for(int i=0; i &lt; 10; i++) &#123; leak_memory(); &#125; return 0;&#125; 编译时需要加上调试信息 -g 1qiushao@qiushao-pc:~/projects/test$ g++ -o tcmalloc_test -g tcmalloc_test.cpp 我们在写代码，和编译代码的时候都不需要 tcmalloc 的参与，我觉得这一点是做得非常好的。对代码完全没有侵入。只需要按以下的方式执行就可以： 1qiushao@qiushao-pc:~/projects/test$ LD_PRELOAD=/usr/local/lib/libtcmalloc.so HEAPCHECK=normal ./tcmalloc_test LD_PRELOAD : 指定 libtcmalloc.so 的路径 HEAPCHECK: 指定检查等级。包括 minimal, normal, strict, draconian 这四种等级。具体差别参考文档： gperftools/docs/heap_checker.html 。如果 normal 没有检查出来问题的话，再用 draconian 试试。 3. 解析内存泄漏分析结果程序的执行结果如下： 12345678910111213141516171819202122232425262728293031323334qiushao@qiushao-pc:~/projects/test$ LD_PRELOAD=/usr/local/lib/libtcmalloc.so HEAPCHECK=normal ./tcmalloc_test WARNING: Perftools heap leak checker is active -- Performance may suffertcmalloc testdo something with bufferdo something with bufferdo something with bufferdo something with bufferdo something with bufferdo something with bufferdo something with bufferdo something with bufferdo something with bufferdo something with bufferHave memory regions w/o callers: might report false leaksLeak check _main_ detected leaks of 10485760 bytes in 10 objectsThe 1 largest leaks:*** WARNING: Cannot convert addresses to symbols in output below.*** Reason: Cannot find 'pprof' (is PPROF_PATH set correctly?)*** If you cannot fix this, try running pprof directly.Leak of 10485760 bytes in 10 objects allocated from: @ 55d4280a4732 @ 55d4280a4763 @ 55d4280a47d2 @ 7fc6cb53bb97 @ 55d4280a463a If the preceding stack traces are not enough to find the leaks, try running THIS shell command:pprof ./tcmalloc_test \"/tmp/tcmalloc_test.14180._main_-end.heap\" --inuse_objects --lines --heapcheck --edgefraction=1e-10 --nodefraction=1e-10 --gvIf you are still puzzled about why the leaks are there, try rerunning this program with HEAP_CHECK_TEST_POINTER_ALIGNMENT=1 and/or with HEAP_CHECK_MAX_POINTER_OFFSET=-1If the leak report occurs in a small fraction of runs, try running with TCMALLOC_MAX_FREE_QUEUE_SIZE of few hundred MB or with TCMALLOC_RECLAIM_MEMORY=false, it might help find leaExiting with error code (instead of crashing) because of whole-program memory leaksqiushao@qiushao-pc:~/projects/test$ tcmalloc 的内存泄漏检查生效时会有这个警告：WARNING: Perftools heap leak checker is active -- Performance may suffer运行完程序之后，提示: Leak of 10485760 bytes in 10 objects allocated from: 。即有 10 处内存地址泄漏了，总共泄漏了 10485760 bytes。tcmalloc 会在 /tmp 目录下生成一个 heap 文件：/tmp/tcmalloc_test.14180.main-end.heap。这个文件记录了所有的内存分配信息。pprof 是 gperftools 自带的一个 perl 脚本，如果我们之前有 make install 的话，直接使用就行，没有 make install 的话，就得设置一下环境变量了。我们可以通过 pprof 脚本来解析 heap 文件，获取每一个内存泄漏的位置及调用堆栈： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879qiushao@qiushao-pc:~/projects/test$ pprof ./tcmalloc_test \"/tmp/tcmalloc_test.14180._main_-end.heap\" --lines --text --stackUsing local file ./tcmalloc_test.Using local file /tmp/tcmalloc_test.14180._main_-end.heap.Total: 10 objectsStacks:10 (000055d4280a4732) /home/qiushao/projects/test/tcmalloc_test.cpp:6:get_buffer (000055d4280a4762) /home/qiushao/projects/test/tcmalloc_test.cpp:12:leak_memory (000055d4280a47d1) /home/qiushao/projects/test/tcmalloc_test.cpp:20:main (00007fc6cb53bb96) /build/glibc-OTsEL5/glibc-2.27/csu/../csu/libc-start.c:310:__libc_start_main (000055d4280a4639) ??:0:_startLeak of 1048576 bytes in 1 objects allocated from: @ 55d4280a4732 unknown @ 000055d4280a4762 leak_memory /home/qiushao/projects/test/tcmalloc_test.cpp:12 @ 000055d4280a47d1 main /home/qiushao/projects/test/tcmalloc_test.cpp:20 @ 00007fc6cb53bb96 __libc_start_main /build/glibc-OTsEL5/glibc-2.27/csu/../csu/libc-start.c:310 @ 000055d4280a4639 _start ??:0Leak of 1048576 bytes in 1 objects allocated from: @ 55d4280a4732 unknown @ 000055d4280a4762 leak_memory /home/qiushao/projects/test/tcmalloc_test.cpp:12 @ 000055d4280a47d1 main /home/qiushao/projects/test/tcmalloc_test.cpp:20 @ 00007fc6cb53bb96 __libc_start_main /build/glibc-OTsEL5/glibc-2.27/csu/../csu/libc-start.c:310 @ 000055d4280a4639 _start ??:0Leak of 1048576 bytes in 1 objects allocated from: @ 55d4280a4732 unknown @ 000055d4280a4762 leak_memory /home/qiushao/projects/test/tcmalloc_test.cpp:12 @ 000055d4280a47d1 main /home/qiushao/projects/test/tcmalloc_test.cpp:20 @ 00007fc6cb53bb96 __libc_start_main /build/glibc-OTsEL5/glibc-2.27/csu/../csu/libc-start.c:310 @ 000055d4280a4639 _start ??:0Leak of 1048576 bytes in 1 objects allocated from: @ 55d4280a4732 unknown @ 000055d4280a4762 leak_memory /home/qiushao/projects/test/tcmalloc_test.cpp:12 @ 000055d4280a47d1 main /home/qiushao/projects/test/tcmalloc_test.cpp:20 @ 00007fc6cb53bb96 __libc_start_main /build/glibc-OTsEL5/glibc-2.27/csu/../csu/libc-start.c:310 @ 000055d4280a4639 _start ??:0Leak of 1048576 bytes in 1 objects allocated from: @ 55d4280a4732 unknown @ 000055d4280a4762 leak_memory /home/qiushao/projects/test/tcmalloc_test.cpp:12 @ 000055d4280a47d1 main /home/qiushao/projects/test/tcmalloc_test.cpp:20 @ 00007fc6cb53bb96 __libc_start_main /build/glibc-OTsEL5/glibc-2.27/csu/../csu/libc-start.c:310 @ 000055d4280a4639 _start ??:0Leak of 1048576 bytes in 1 objects allocated from: @ 55d4280a4732 unknown @ 000055d4280a4762 leak_memory /home/qiushao/projects/test/tcmalloc_test.cpp:12 @ 000055d4280a47d1 main /home/qiushao/projects/test/tcmalloc_test.cpp:20 @ 00007fc6cb53bb96 __libc_start_main /build/glibc-OTsEL5/glibc-2.27/csu/../csu/libc-start.c:310 @ 000055d4280a4639 _start ??:0Leak of 1048576 bytes in 1 objects allocated from: @ 55d4280a4732 unknown @ 000055d4280a4762 leak_memory /home/qiushao/projects/test/tcmalloc_test.cpp:12 @ 000055d4280a47d1 main /home/qiushao/projects/test/tcmalloc_test.cpp:20 @ 00007fc6cb53bb96 __libc_start_main /build/glibc-OTsEL5/glibc-2.27/csu/../csu/libc-start.c:310 @ 000055d4280a4639 _start ??:0Leak of 1048576 bytes in 1 objects allocated from: @ 55d4280a4732 unknown @ 000055d4280a4762 leak_memory /home/qiushao/projects/test/tcmalloc_test.cpp:12 @ 000055d4280a47d1 main /home/qiushao/projects/test/tcmalloc_test.cpp:20 @ 00007fc6cb53bb96 __libc_start_main /build/glibc-OTsEL5/glibc-2.27/csu/../csu/libc-start.c:310 @ 000055d4280a4639 _start ??:0Leak of 1048576 bytes in 1 objects allocated from: @ 55d4280a4732 unknown @ 000055d4280a4762 leak_memory /home/qiushao/projects/test/tcmalloc_test.cpp:12 @ 000055d4280a47d1 main /home/qiushao/projects/test/tcmalloc_test.cpp:20 @ 00007fc6cb53bb96 __libc_start_main /build/glibc-OTsEL5/glibc-2.27/csu/../csu/libc-start.c:310 @ 000055d4280a4639 _start ??:0Leak of 1048576 bytes in 1 objects allocated from: @ 55d4280a4732 unknown @ 000055d4280a4762 leak_memory /home/qiushao/projects/test/tcmalloc_test.cpp:12 @ 000055d4280a47d1 main /home/qiushao/projects/test/tcmalloc_test.cpp:20 @ 00007fc6cb53bb96 __libc_start_main /build/glibc-OTsEL5/glibc-2.27/csu/../csu/libc-start.c:310 @ 000055d4280a4639 _start ??:0 10 100.0% 100.0% 10 100.0% get_buffer /home/qiushao/projects/test/tcmalloc_test.cpp:6 0 0.0% 100.0% 10 100.0% __libc_start_main /build/glibc-OTsEL5/glibc-2.27/csu/../csu/libc-start.c:310 0 0.0% 100.0% 10 100.0% _start ??:0 0 0.0% 100.0% 10 100.0% leak_memory /home/qiushao/projects/test/tcmalloc_test.cpp:12 0 0.0% 100.0% 10 100.0% main /home/qiushao/projects/test/tcmalloc_test.cpp:20qiushao@qiushao-pc:~/projects/test$ 其中： --lines: 打印文件路径和行号。 --text : 以文本形式输出分析结果，还可以以 pdf, 调用图 gv 等形式输出。 --stack: 打印每一处泄漏的调用堆栈。 4. arm linux 上使用 tcmalloc在开发板上使用 tcmalloc 跟 pc 上使用是差不多的。我们把交叉编译生成的 libtcmalloc.so* 库 copy 到板子上。我放到了 /vendor/lib 目录下。然后手动执行程序： 12345~ # mount -t nfs -o nolock -o tcp -o rsize=32768,wsize=32768 192.168.181.112:/media/qiushao/source-code/Hi3516/sourceCode/trunk /mnt~ # mount -o rw,remount /vendor~ # cp -f /mnt/libtcmalloc.so* /vendor/lib/~ # cp -f /mnt/tcmalloc_test /vendor/bin/~ # LD_PRELOAD=/vendor/lib/libtcmalloc.so HEAPCHECK=normal /vendor/bin/tcmalloc_test 执行结果跟在 pc 上执行的是一样的： 123456789101112131415161718192021222324252627282930~ # LD_PRELOAD=/vendor/lib/libtcmalloc.so HEAPCHECK=normal /vendor/bin/tcmalloc_testWARNING: Perftools heap leak checker is active -- Performance may suffertcmalloc testdo something with bufferdo something with bufferdo something with bufferdo something with bufferdo something with bufferdo something with bufferdo something with bufferdo something with bufferdo something with bufferdo something with bufferHave memory regions w/o callers: might report false leaksLeak check _main_ detected leaks of 10485760 bytes in 10 objectsThe 1 largest leaks:*** WARNING: Cannot convert addresses to symbols in output below.*** Reason: Cannot find 'pprof' (is PPROF_PATH set correctly?)*** If you cannot fix this, try running pprof directly.Leak of 10485760 bytes in 10 objects allocated from:If the preceding stack traces are not enough to find the leaks, try running THIS shell command:pprof /vendor/bin/tcmalloc_test \"/tmp/tcmalloc_test.251._main_-end.heap\" --inuse_objects --lines --heapcheck --edgefraction=1e-10 --nodefraction=1e-10 --gvIf you are still puzzled about why the leaks are there, try rerunning this program with HEAP_CHECK_TEST_POINTER_ALIGNMENT=1 and/or with HEAP_CHECK_MAX_POINTER_OFFSET=-1If the leak report occurs in a small fraction of runs, try running with TCMALLOC_MAX_FREE_QUEUE_SIZE of few hundred MB or with TCMALLOC_RECLAIM_MEMORY=false, it might help Exiting with error code (instead of crashing) because of whole-program memory leaks~ # 同样也生成了 “/tmp/tcmalloc_test.251.main-end.heap” 文件。由于在板子上没法跑 pprof 脚本。这个脚本实际上是 perl 脚本，还依赖一大堆其他工具。我们可以把 “/tmp/tcmalloc_test.251.main-end.heap” 文件 copy 到 pc 上，然后在 pc 用 pprof 进行分析。 在分析的时候可能会提示一些库找不到，我们需要把这些库从板子上也 copy 到 pc 上对应的目录。 5. tcmalloc 基本原理介绍使用完 tcmalloc 之后，我们有以下几个疑问，只要把这几个疑问解决了，那我们对 tcmalloc 的基本原理也就清楚了。 如何记录内存分配，释放:tcmalloc 其实就是定义了一套自己的内存分配释放函数把标准库中的 malloc, alloc, free, new, delete 等替换掉。在分配内存的时候，通过 libunwind 获取调用堆栈，把内存分配调用堆栈记录下来。 如何替换标准库的内存分配，释放函数：LD_PRELOAD 是 Linux 系统的一个环境变量，它可以影响程序的运行时的链接，它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。 如何在程序 main 函数结束后，执行内存泄漏分析：只要定义一个全局静态类变量就行，这个变量的构造函数会在 main 之前执行，析构函数会在 main 函数之后执行。 再详细的东西就不展开讨论了，想了解细节的同学，可以自己阅读代码。更详细的使用细节说明，请阅读 gperftools 代码里面的 docs 文档。 参考资料： https://wallenwang.com/2018/11/tcmalloc/ https://www.cnblogs.com/my_life/articles/4683313.html","categories":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/tags/Linux/"},{"name":"gperftools","slug":"gperftools","permalink":"http://qiushao.net/tags/gperftools/"},{"name":"tcmalloc","slug":"tcmalloc","permalink":"http://qiushao.net/tags/tcmalloc/"},{"name":"内存泄漏","slug":"内存泄漏","permalink":"http://qiushao.net/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"}]},{"title":"根据条件禁用Android.bp模块","slug":"Android/Android.bp-disable-module","date":"2020-05-29T12:00:00.000Z","updated":"2020-12-27T01:22:23.740Z","comments":true,"path":"2020/05/29/Android/Android.bp-disable-module/","link":"","permalink":"http://qiushao.net/2020/05/29/Android/Android.bp-disable-module/","excerpt":"","text":"上一篇文章我们提到了在 Android 10 之后，Android.bp 定义的模块才能加入到 bootjar 中。但是我们有个中间件模块是各平台同一套代码的。我们还有 Android 5.1 的平台在维护，而 Android 5.1 是还不支持 Android.bp 的。为了兼容各平台，我们需要同时编写 Android.mk 和 Android.bp 规则，里面都定义了中间件模块。但这样子在同时支持 mk 和 bp 的平台就会有模块重定义的问题。所以我们需要一种机制，能实现以下需求： Android 版本 &gt;= 10 时：Android.bp 的模块定义生效，Android.mk 的模块定义不生效。 Android 版本 &lt; 10 时：Android.mk 的模块定义生效，Android.bp 的模块定义不生效。 Android.mk 根据 sdk 版本，禁用模块Android.mk 是 Makefile 语法，本身就有条件判断功能，所以要实现这个功能是很简单的： 1234567891011LOCAL_PATH :&#x3D; $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE :&#x3D; hello # 模块名LOCAL_SRC_FILES :&#x3D; hello.cpp # 源文件列表LOCAL_SHARED_LIBRARIES :&#x3D; liblog # 依赖关系LOCAL_xxx :&#x3D; xxx# 小于 Android 10 才在 Android.mk 中定义模块。include $(BUILD_XXX) 才会真正定义一个模块。ifeq (1,$(filter 1,$(shell echo &quot;$$(( $(PLATFORM_SDK_VERSION) &lt; 29 ))&quot; ))) include $(BUILD_EXECUTABLE) # 模块类型endif Android.bp 根据 sdk 版本，禁用模块Android.bp 的条件编译，前面的文章已经有讨论过了，这里就不再展开了。http://qiushao.net/2020/02/05/Android系统开发入门/15-Anroid.bp条件编译/只展示一下关键配置即可： 12345678910111213141516171819func helloHook(ctx android.LoadHookContext) &#123; &#x2F;&#x2F;AConfig() function is at build&#x2F;soong&#x2F;android&#x2F;config.go fmt.Println(&quot;PlatformSdkVersion &#x3D; &quot;, ctx.AConfig().PlatformSdkVersion()) type props struct &#123; Enabled *bool &#125; p :&#x3D; &amp;props&#123;&#125; var int_platform_sdk_version int int_platform_sdk_version &#x3D; ctx.AConfig().PlatformSdkVersionInt() var enabled bool if int_platform_sdk_version &gt;&#x3D; 29 &#123; enabled &#x3D; true &#125; else &#123; enabled &#x3D; false &#125; p.Enabled &#x3D; &amp;enabled ctx.AppendProperties(p)&#125; Android.bp 中有一个 enabled 字段，当 enabled = false 时，这个模块就不会被定义，所以我们只要根据 sdk 的版本来给 enabled 字段赋值即可。这里需要注意的是 props struct 中定义的 Enabled 是指针类型。","categories":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发入门-16.Android系统添加 bootjar","slug":"Android系统开发入门/16-Android-add-bootjar","date":"2020-05-23T02:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/05/23/Android系统开发入门/16-Android-add-bootjar/","link":"","permalink":"http://qiushao.net/2020/05/23/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/16-Android-add-bootjar/","excerpt":"","text":"1. 什么是 bootjar要理解 boojar 首先得理解 Java-类的加载机制。其中最重要的概念是双亲委托加载模式： 从上图我们可以看到 Bootstrap ClassLoader 的加载路径就包含了 BOOTCLASSPATH 路径。BOOTCLASSPATH 是一个环境变量，我们可以这样查看： 123pure:&#x2F; # echo $BOOTCLASSPATH&#x2F;apex&#x2F;com.android.runtime&#x2F;javalib&#x2F;core-oj.jar:&#x2F;apex&#x2F;com.android.runtime&#x2F;javalib&#x2F;core-libart.jar:&#x2F;apex&#x2F;com.android.runtime&#x2F;javalib&#x2F;okhttp.jar:&#x2F;apex&#x2F;com.android.runtime&#x2F;javalib&#x2F;bouncycastle.jar:&#x2F;apex&#x2F;com.android.runtime&#x2F;javalib&#x2F;apache-xml.jar:&#x2F;system&#x2F;framework&#x2F;framework.jar:&#x2F;system&#x2F;framework&#x2F;ext.jar:&#x2F;system&#x2F;framework&#x2F;telephony-common.jar:&#x2F;system&#x2F;framework&#x2F;voip-common.jar:&#x2F;system&#x2F;framework&#x2F;ims-common.jar:&#x2F;system&#x2F;framework&#x2F;android.test.base.jar:&#x2F;apex&#x2F;com.android.conscrypt&#x2F;javalib&#x2F;conscrypt.jar:&#x2F;apex&#x2F;com.android.media&#x2F;javalib&#x2F;updatable-media.jarpure:&#x2F; # Android 中的 bootjar 其实就是要将某个 jar 包添加到 BOOTCLASSPATH。 2. 什么时候需要添加 boojar想像一下，你是做 TV 系统的。TV 芯片的供应商有 hisi, rtk, mtk 等，他们在系统中都提供了一套 TV 相关的 java api 给我们应用使用。 我们同时要开发这几个不同芯片供应商的平台。我们的应用应该怎么开发呢？ 最原始的方案是应用层分别对接不同芯片供应商提供的接口这种方案的问题是假如有N个应用需要用到 TV 接口的话，那我们就需要维护 3 * N个应用。这种方法的代码维护成本太高了，不可接受。 封装一层中间层，我们称之为 middleware（中间件）, apk 只对接中间件，平台差异部分由中间来分别对接。这种方案我们需要维护N个应用 + 三份中间件接口。这种方案有以下好处： 那所有应用都统一对接到中间件即可。不需要处理平台差异。大大减少应用代码的维护量。 供应商接口有变化时，应用层不需要更改。只需要在中间件调整适配即可。 这种方案有两种实现方式。 - 中间件 jar 带完整实现，编译 apk 时打包到 apk 中。这种方案的问题是当中间件实现有变化时，所有的 apk 都需要重新打包发布，不好维护。 - 中间件 jar 是空接口。具体实现放到平台中。当中间件实现有变化时，apk 不需要任何更改，只需要更改平台的中间实现就行。要实现这种方案就得通过 bootjar 来实现了。目前我们使用的是这种方案。 3. 添加 bootjar添加 bootjar 的方法很简单，假设我们有个 java_library api.pure 需要加入 bootjar， 只需要做以下工作即可。device.mk 中加入 12PRODUCT_PACKAGES +&#x3D; api.purePRODUCT_BOOT_JARS +&#x3D; api.pure Android/build/core/tasks/check_boot_jars/package_whitelist.txt 中加入 12api\\.pureapi\\.pure\\..* 4. Android 10 boojar 的变化最近在搞 hisiv900, Android 10 的平台。需要把之前的中间导入到系统里面。以前的中间件是 Android.mk 模块。按照上面的方法导入时编译出现类似以下的错误： 12345678910[100% 2&#x2F;2] out&#x2F;soong&#x2F;.bootstrap&#x2F;bin&#x2F;soong_build out&#x2F;soong&#x2F;build.ninjaFAILED: out&#x2F;soong&#x2F;build.ninjaout&#x2F;soong&#x2F;.bootstrap&#x2F;bin&#x2F;soong_build -t -l out&#x2F;.module_paths&#x2F;Android.bp.list -b out&#x2F;soong -n out -d out&#x2F;soong&#x2F;build.ninja.d -globFile out&#x2F;soong&#x2F;.bootstrap&#x2F;build-globs.ninja -o out&#x2F;soong&#x2F;build.ninja Android.bpinternal error: failed to find dex jar path for module &quot;api.pure&quot;internal error: failed to find dex jar path for module &quot;api.pure&quot;15:18:21 soong bootstrap failed with: exit status 1#### failed to build some targets (15 seconds) ####qiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;android-10.0.0_r33$ 只提示找不到 dex jar, 也不知道为什么错了。折腾了好久，后面在 build 目录搜索 PRODUCT_BOOT_JARS 关键字，发现 build/make/core/java.mk 有以下代码： 123ifneq ($(filter $(LOCAL_MODULE),$(PRODUCT_BOOT_JARS)),) $(call pretty-error,Modules in PRODUCT_BOOT_JARS must be defined in Android.bp files)endif 才发现，原来 Android 10 之后，Android.mk 定义的模块是没法加入到 bootjar 了。需要切换成 Android.bp。经过实验总结，要加入到 bootjar 需要满足以下条件：Android.bp 模块 + installable 为 true + source file 需要是源文件（不能是jar包）","categories":[{"name":"Android系统开发入门","slug":"Android系统开发入门","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"hisi Camera 开发--HiMPP媒体处理软件开发基本概念","slug":"IPCamera/himpp-overview","date":"2020-05-17T13:30:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/05/17/IPCamera/himpp-overview/","link":"","permalink":"http://qiushao.net/2020/05/17/IPCamera/himpp-overview/","excerpt":"","text":"1. HIMPP平台架构简介海思提供的媒体处理软件平台(Media Process Platform,简称 MPP),可支持应用软件快速开发。该平台对应用软件屏蔽了芯片相关的复杂的底层处理,并对应用软件直接提供 MPI(MPP Program Interface)接口完成相应功能。该平台支持应用软件快速开发以下功能:输入视频捕获、H.265/H.264/JPEG 编码、H.265/H.264/JPEG 解码、视频输出显示、视频图像前处理(包括去噪、增强、锐化)、图像拼接、图像几何矫正、智能、音频捕获及输出、音频编解码等功能。 2. 系统分层结构系统大概层次结构如下： 硬件层硬件层由 Hi35xx 芯片加上必要的外围器件构成。外围器件包括 Flash、DDR、视频 Sensor 或 AD、音频 AD 等。 操作系统层基于 Linux 或 Huawei LiteOS 的 OS 系统。 操作系统适配层提供操作系统系统调用基础函数,屏蔽操作系统差异,支持媒体处理平台运行在不同的操作系统上,或相同操作系统不同版本。 媒体处理平台基于操作系统适配层,控制芯片完成相应的媒体处理功能。它对应用层屏蔽了硬件处理细节,并为应用层提供 API 接口完成相应功能。 其他驱动除媒体处理平台外,海思为 Hi35xx 芯片的其他相关硬件处理单元提供了相应的驱动,包括 CIPHER、RTC 等驱动。 应用层基于海思媒体处理平台及其他驱动,由用户开发的应用软件系统。 以上这些分层，我们主要关注的是 HIMPP 媒体软件处理平台和应用层。我们必须对 HIMPP 这层的内容进行深入的学习了解，才能在其基础之上开发应用。 3. HIMPP 数据处理流程海思媒体处理平台主要流程分为视频处理及音频处理两条路线： 我们先来大概了解一下各个模块的作用： sensor: 包括镜头，感光芯片等器件，主要作用是光电信号转换。 disk: 为硬盘存储文件。视频的来源既可以是从 sensor 中采集的，也可以是从文件中读取出来的。视频回放时走的是这条通路。 VI：视频采集模块。捕获视频图像，可对其做剪切、缩放、镜像等处理，并输出多路不同分辨率的图像数据。 VDEC：视频解码模块。对编码后的视频码流进行解码，并将解析后的图像数据送 VPSS 进行图像处理或直接送 VO 显示。可对 H.264/H.265/VC1/MPEG4/MPEG2/AVS 格式的视 频码流进行解码。 VPSS：图像处理子系统。接收 VI 或 VDEC 发送过来的图像，可对图像进行去噪、图像增强、锐化等处理，并实现同源输出多路不同分辨率的图像数据用于编码、预览或抓拍。 NNIE：AI算法模块。从 VPSS 拿到帧数据，然后进行人脸检测，识别等各种 AI 算法。算法结果可以通过 histreaming 等协议发送给客户端 app。 VENC：编码模块。接收 VI 捕获并经 VPSS 处理后输出的图像数据，可叠加用户通过 Region 模块设置的 OSD 图像，然后按不同协议进行编码并输出相应码流(H264,MJPEG等)。然后可以通过各种视频传输协议进行传输。比如 uvc, rtsp, http 等。也可以保存到文件，后续可以进行回放。 VO：视频输出模块。接收 VPSS 处理后的输出图像，可进行播放控制等处理，最后按用户配置的输出协议输出给外围视频设备 HDMI 等。 mic：麦克风。主要作用是声电信号转换。 AI: 音频采集模块。捕获音频数据，然后 AENC 模块支持按多种音频协议对其进行编码，最后输出音频码流。 用户从网络或外围存储设备获取的音频码流可直接送给 ADEC 模块，ADEC 支持 解码多种不同的音频格式码流，解码后数据送给 AO 模块即可播放声音。 我们对以上各模块的作用及数据处理流程一定要非常熟悉。因为应用层的开发基本上都是围绕着这个流程来进行编码实现的。应用层只需要配置好各模块的参数，启动，然后把各模块连接起来就行。 4. 系统初始化系统控制模块根据芯片特性，完成硬件各个部件的复位、基本初始化工作，同时负责完成 MPP（Media Process Platform 媒体处理平台）系统各个业务模块的初始化、去初始化以及管理 MPP 系统各个业务模块的工作状态、提供当前 MPP 系统的版本信息、提供大块物理内存管理等功能。应用程序启动 MPP 业务前，必须完成 MPP 系统初始化工作。同理，应用程序退出 MPP 业务后，也要完成 MPP 系统去初始化工作，释放资源。 4.1 视频缓冲池 VB视频缓存池主要向媒体业务提供大块物理内存管理功能，负责内存的分配和回收，充分发挥内存缓存池的作用，让物理内存资源在各个媒体处理模块中合理使用。一组大小相同、物理地址连续的缓存块组成一个视频缓存池。视频输入通道需要使用公共视频缓存池。所有的视频输入通道都可以从公共视频缓存池中获取视频缓存块用于保存采集的图像（如图中所示从公共视频缓存池 B 中获取视频缓存块 Bm）。由于视频输入通道不提供创建和销毁公共视频缓存池功能，因此，在系统初始化之前，必须为视频输入通道配置公共视频缓存池。 典型的公共视频缓存池数据流图如下： VI 从公共视频缓存池 B 中获取视频缓存块 Bm,缓存块 Bm 经 VI发送给 VPSS,输入缓存块 Bm 经过 VPSS 处理之后被释放回公共视频缓存池。假设 VPSS 通道的工作模式是 USER, 则 VPSS 通道 0 从公共视频缓存池 B 中获取缓存块 Bi 作为输出图像缓存 buffer 发送给 VENC,VPSS 通道 1 从公共视频缓存池 B 中获取缓存块 Bk 作为输出图像缓存 buffer 发送给 VO,Bi 经 VENC 编码完之后释放回公共视频缓存池,Bk 经 VO 显示完之后释放回公共视频缓存池。 5. VI视频输入(VI)模块实现的功能:通过 MIPI Rx(含 MIPI 接口、LVDS 接口和 HISPI 接口),SLVS-EC,BT.1120,BT.656,BT.601,DC 等接口接收视频数据。VI 将接收到的数据存入到指定的内存区域,在此过程中,VI 可以对接收到的原始视频图像数据进行处理, 实现视频数据的采集。VI 在软件层次上划分 4 个部分：VI 从软件上划分了输入设备(DEV), 输入 PIPE(图示为物理 PIPE,虚拟 PIPE 只包含ISP_BE)、物理通道(PHY_CHN)、扩展通道(EXT_CHN)四个层级。 视频输入设备视频输入设备支持若干种时序输入,负责对时序进行解析。 视频输入物理 PIPE视频输入 PIPE 绑定在设备后端,负责设备解析后的数据再处理。包含了 ISP 的相关处理功能,主要是对图像数据进行流水线处理,输出YUV 图像格式给通道。 视频输入虚拟 PIPE视频输入虚拟 PIPE 不绑定设备,负责其他模块或用户发送过来的数据再处理。 视频物理通道物理通道负责将最终处理后的数据输出到 DDR,在真正将数据输出到 DDR 之前,它可以实现裁剪等功能。Hi3519AV100 VI 的一个 PIPE 包含 2 个物理通道。CH0 具有裁剪、压缩等功能。CH1 具有缩小的功能,支持 8 个扩展通道。 视频扩展通道扩展通道是物理通道的扩展,扩展通道具备缩放、裁剪、鱼眼矫正功能,它通过绑定物理通道,将物理通道输出作为自己的输入,然后输出用户设置的目标图像。 VI 的硬件通路如下： 镜头畸变校正(LDC)镜头畸变校正,一些低端镜头容易产生图像畸变,需要根据畸变程度对其图像进行校正。 DISDIS 模块通过比较当前图像与前两帧图像采用不同自由度的防抖算法计算出当前图像在各个轴方向上的抖动偏移向量,然后根据抖动偏移向量对当前图像进行校正,从而起到防抖的效果。 BASBayer scaling,即 Bayer 域缩放。 低延时低延时指图像写出指定的行数到 DDR 后,VI 上报一个中断,把图像发给后端模块处理,可以减少延时,且硬件会有机制保证图像是先写后读,不会出现读图像错误。 提前上报中断提前上报中断指图像写出指定的行数到 DDR 后,VI 上报一个中断,把图像发给后端模块处理,可以减少延时,但没有和低延时一样的硬件机制保证后端模块读图像不会出错。 6. VPSSVPSS(Video Process Sub-System)是视频处理子系统,支持的具体图像处理功能包括 FRC(Frame Rate Control)、CROP、Sharpen、3DNR、Scale、像素格式转换、LDC、Spread、固定角度旋转、任意角度旋转、鱼眼校正、Cover/Coverex、Overlayex、Mosaic、Mirror/Flip、HDR、Aspect Ratio、压缩解压等。 vpss 的数据处理流程如下： vpss 相关基本概念： GROUPVPSS 对用户提供组(GROUP)的概念。最大个数请参见 VPSS_MAX_GRP_NUM 定义,各 GROUP 分时复用 VPSS 硬件,硬件依次处理各个组提交的任务。 CHANNELVPSS 组的通道。通道分为 2 种:物理通道和扩展通道。VPSS 硬件提供多个物理通道,每个通道具有缩放、裁剪等功能。扩展通道具备裁剪、缩放功能,它通过绑定物理通道,将物理通道输出作为自己的输入,把图像裁剪、缩放成用户设置的目标分辨率输出。 PIPEVPSS 组的管道,取值只能为 0。 FRC帧率控制,分为 2 种:组帧率控制和通道帧率控制。 组帧率控制:用于控制各 GROUP 对输入图像的接收。 通道帧率控制:用于控制各个物理通道和扩展通道图像的处理。 CROP裁剪,分为 3 种:组裁剪、物理通道裁剪以及扩展通道裁剪。 组裁剪,VPSS 对输入图像进行裁剪。 物理通道裁剪,VPSS 对各个物理通道的输出图像进行裁剪。 扩展通道裁剪,VPSS 调用 VGS 对扩展通道的输出图像进行裁剪 Scale缩放,对图像进行缩小放大。物理通道水平、垂直最大支持 15 倍缩小,最大支持 16 倍放大;扩展通道水平、垂直最大支持 30 倍缩小,最大支持 16 倍放大。 Mirror/FlipMirror 即水平镜像,Flip 即上下翻转。可使用 Mirror+Flip 实现 180°旋转。 Mosaic马赛克,对 VPSS 的输出图像填充马赛克块。 Cover视频遮挡区域,对 VPSS 的输出图像填充纯色块。 Overlayex视频叠加区域,调用 VGS 对 VPSS 通道的输出图像叠加位图,支持位图格式 ARGB4444、ARGB1555、ARGB8888、2BPP(仅 Hi3516EV200/Hi3516EV300 支持)。 3DNR去噪。通过参数配置,把图像中的高斯噪声去除,使得图像变得平滑,有助于降低编码码率。Hi3559AV100ES/Hi3559AV100 不支持。 固定角度旋转支持 0 度、90 度、180 度以及 270 度固定角度的旋转功能。 任意角度旋转支持任意角度的旋转功能。Hi3559AV100ES/Hi3559AV100/Hi3516EV200 不支持。 LDC对输入图像做镜头畸变校正。Hi3559AV100ES/Hi3559AV100/Hi3516EV200 不支持。 Spread对输入图像做展宽处理。Hi3559AV100ES/Hi3559AV100/Hi3516EV200 不支持。 鱼眼校正仅 Hi3519AV100/Hi3516CV500/Hi3516AV300/Hi3516DV300 支持。 Aspect Ratio幅形比,指定输出画面相对于输入画面的宽高纵横比。 6.1 从 VPSS 模块中获取帧数据我们需要进行 AI 算法运行的时候，需要从 VPSS 模块中获取帧数据，输入给算法模块进行处理。帧数据的获取大概如下： 12345678// 1. 获取帧数据，保存到 pstVideoFrame 中。HI_S32 HI_MPI_VPSS_GetChnFrame(VPSS_GRP VpssGrp, VPSS_CHN VpssChn, VIDEO_FRAME_INFO_S *pstVideoFrame, HI_S32 s32MilliSec);\\// 2. 第一步中获取到的数据地址是物理地址，需要调用 mmap 把物理地址映射成逻辑地址。HI_VOID *HI_MPI_SYS_Mmap(HI_U64 u64PhyAddr, HI_U32 u32Size);// 3. 数据使用将帧数据输入给算法模块使用。// 4. 释放帧数据HI_S32 HI_MPI_VPSS_ReleaseChnFrame(VPSS_GRP VpssGrp, VPSS_CHN VpssChn, const VIDEO_FRAME_INFO_S *pstVideoFrame); 7. VOVO(Video Output,视频输出)模块主动从内存相应位置读取视频和图形数据,并通过相应的显示设备（HDMI等）输出视频和图形。 8. VENC视频编码模块支持多路实时编码,且每路编码独立,编码协议和编码 profile 可以不同。本模块支持视频编码同时,调度 Region 模块对编码图像内容进行叠加和遮挡。视频编码流程如下： 其中编码通道处理流程如下： venc 相关基本概念： 编码通道编码通道作为基本容器,保存编码通道的多种用户设置和管理编码通道的多种内部资源。编码通道完成图像转化为码流的功能,具体由码率控制器和编码器协同完成。这里的编码器指的是狭义上的编码器,只完成编码功能。码率控制器提供了对编码参数的控制和调整,从而对输出码率进行控制。 码率控制码率控制器实现对编码码率进行控制。从信息学的角度分析,图像的压缩比越低,压缩图像的质量越高;图像压缩比例越高,压缩图像的质量越低。对于场景变化的真实场景,图像质量稳定,编码码率会波动;编码码率稳定,图像质量会波动。以 H.264 编码为例,通常图像 Qp 越低,图像的质量越好,码率越高;图像 Qp 越高,图像质量越差,码率越低。码率控制是针对连续的编码码流而言,所以,JPEG 协议编码通道不包括码率控制功能。码率控制器分别提供了对 MJPEG 协议编码通道 CBR、VBR、FIXQP 三种码率控制模式,H.264/H.265 协议编码通道 CBR、VBR、AVBR、QVBR、CVBR、FIXQP、QPMAP 七种码率控制模式,对图像质量和码率进行调节,对于 H.264/H.265/协议通道的 QPMAP 模式,码控的策略由用户决定。 8.1 从 VENC 模块中获取帧数据VENC 编码完成后，需要 uvc, rtsp 等模块从 VENC 中获取帧数据，然后对外发送。帧数据的获取流程大概如下： 12345678// 1. 查询 VENC 编码状态， VENC_CHN_STATUS_S.u32CurPacks 为当前帧的 package 数量。为 0 时说明还没编码好，等会再查询。HI_S32 HI_MPI_VENC_QueryStatus(VENC_CHN VeChn, VENC_CHN_STATUS_S *pstStatus);// 2. 获取帧数据，保存到 pstStream 中。HI_S32 HI_MPI_VENC_GetStream(VENC_CHN VeChn, VENC_STREAM_S *pstStream, HI_S32 s32MilliSec);// 3. 数据使用将帧数据输入给 uvc, rtsp 等模块。// 4. 释放帧数据HI_S32 HI_MPI_VENC_ReleaseStream(VENC_CHN VeChn, VENC_STREAM_S *pstStream); 9. VI, VPSS 工作模式VI 和 VPSS 各自的工作模式分为在线,离线,并行模式,工作模式说明如下： 模式 VI_CAP 与 VI_PROC VI_PROC 与 VPSS 在线模式 VI_CAP 与 VI_PROC 之间在线数据流传输,此模式下 VI_CAP不会写出 RAW 数据到 DDR,而是直接把数据流送给VI_PROC。 VI_PROC 与 VPSS 之间的在线数据流传输,在此模式下 VI_PROC不会写出 YUV 数据到 DDR,而是直接把数据流送给 VPSS。 离线模式 VI_CAP 写出 RAW 数据到DDR,然后 VI_PROC 从 DDR 读取 RAW 数据进行后处理。 VI_PROC 写出 YUV 数据到DDR,然后 VPSS 从 DDR 读取 YUV 数据进行后处理。 从以上的描述来看在线模式和离线模式的主要差别是是否将数据写出 DDR。在线模式时 VI 进行时序解析后直接在芯片内部将数据传递到VPSS，中间无DDR 写出的过程。在线模式可以省一定的带宽和内存，降低端到端的延时。但是，在线模式时，因为VI 不写出数据到DDR，无法进行CoverEx、OverlayEx、Rotate、LDC 等操作，需要在VPSS 各通道写出后再进行Rotate/LDC 等处理，而且有些功能只在离线下能支持，比如DIS。所以使用在线模式还是离线模式需要根据具体需求来决定。如果追求低延时，那自然要使用在线模式。","categories":[{"name":"Camera","slug":"Camera","permalink":"http://qiushao.net/categories/Camera/"}],"tags":[{"name":"Hi3519AV100","slug":"Hi3519AV100","permalink":"http://qiushao.net/tags/Hi3519AV100/"},{"name":"Camera","slug":"Camera","permalink":"http://qiushao.net/tags/Camera/"}]},{"title":"arm linux 开启 coredump file","slug":"Linux/linux-enable-coredump","date":"2020-05-01T13:30:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/05/01/Linux/linux-enable-coredump/","link":"","permalink":"http://qiushao.net/2020/05/01/Linux/linux-enable-coredump/","excerpt":"","text":"1. 基本概念之前一直在做 Android 相关的工作，在 Android 系统上无论是 java 进程还是 c++ 进程崩溃的时候都会有堆栈信息可以追溯是哪里挂了。java 进程挂的话，logcat 里面直接有错误堆栈信息。c++ 进程挂的话，/data/tomstone 目录里面会生成 coredump 信息。里面有错误堆栈，但错误堆栈只是一个地址调用而已，需要使用 addr2line 工具来将地址转换成文件行数。现在纯 Linux 环境中开发 Camera 应用。当程序运行在过程中崩溃时，就只提示了一个进程 Abort 了。然后啥信息都没有。鬼才知道哪里出问题了。这个时候就得 coredump 出场了。Linux 系统默认是把 coredump 关闭的。打开 coredump 后，进程崩溃时，操作系统会将程序当时的内存状态记录下来，保存在一个文件中，这种行为就叫做 Core Dump（中文有的翻译成“核心转储”)。我们可以认为 core dump 是“内存快照”，但实际上，除了内存信息之外，还有些关键的程序运行状态也会同时 dump 下来，例如寄存器信息（包括程序指针、栈指针等）、内存管理信息、其他处理器和操作系统状态和信息。core dump 对于编程人员诊断和调试程序是非常有帮助的，因为对于有些程序错误是很难重现的，例如指针异常，而 core dump 文件可以再现程序出错时的情景。 2. 开启 core dump我们先查询一下 coredump 是否打开了 123456789101112131415&#x2F; # ulimit -a-f: file size (blocks) unlimited-t: cpu time (seconds) unlimited-d: data seg size (kb) unlimited-s: stack size (kb) 8192-c: core file size (blocks) 0-m: resident set size (kb) unlimited-l: locked memory (kb) 64-p: processes 1832-n: file descriptors 1024-v: address space (kb) unlimited-w: locks unlimited-e: scheduling priority 0-r: real-time priority 0&#x2F; # ulimit -a 命令为查询当前的系统限制规则。 其中 core file size (blocks, -c) 0 表示 coredump 文件的大小为限制为 0，即关闭 coredump 功能。通过以下命令来打开 coredump 功能： 12345678910111213141516&#x2F; # ulimit -c unlimited&#x2F; # ulimit -a-f: file size (blocks) unlimited-t: cpu time (seconds) unlimited-d: data seg size (kb) unlimited-s: stack size (kb) 8192-c: core file size (blocks) unlimited-m: resident set size (kb) unlimited-l: locked memory (kb) 64-p: processes 1832-n: file descriptors 1024-v: address space (kb) unlimited-w: locks unlimited-e: scheduling priority 0-r: real-time priority 0&#x2F; # 我们可以看到 core file size 的限制变为 unlimited 为。也就是没有限制。这样就可以打开 coredump 功能了。默认情况下 coredump 文件的存放路径为当前目录。我们可以通过以下命令来修改 coredump 的存放路径： 12echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_uses_pidecho &quot;&#x2F;data&#x2F;core_%e_%p&quot; &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern 以下命令把 coredump 文件存放到了 /data 目录 其中 %e, %p 的解析如下 1234567%p - insert pid into filename 添加pid%u - insert current uid into filename 添加当前uid%g - insert current gid into filename 添加当前gid%s - insert signal that caused the coredump into the filename 添加导致产生core的信号%t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间%h - insert hostname where the coredump happened into filename 添加主机名%e - insert coredumping executable name into filename 添加命令名 在测试过程中，我们需要一直打开 coredump 功能的，因此我们把以下命令加入到 /etc/profile 中。以便每次开机都生效 12345# enable coredump for debugecho \"enable coredump file\"ulimit -c unlimited echo 0 &gt; /proc/sys/kernel/core_uses_pidecho \"/data/core_%e_%p\" &gt; /proc/sys/kernel/core_pattern 3. gdb 调试 core dump我们来写一个会崩溃的程序试试看会不会产生 coredump 文件。 123456789101112#include &lt;stdio.h&gt;void get_value(int *value) &#123; *value = 31;&#125;int main(int argc, char *argv[]) &#123; int *value = nullptr; get_value(value); printf(\"value = %d\\n\", *value); return 0;&#125; 交叉编译这个程序，然后上传到板子上运行： 1234567/data # lstest/data # ./test Segmentation fault (core dumped)/data # lscore_test_252 test/data # 我们看到产生了一个 coredump 文件 core_test_252。接下来我们需要使用 gdb 来查看 coredump 文件里面的错误堆栈。 123456789101112131415161718192021222324252627282930/data # lscore_test_252 test/data # gdb test core_test_252 GNU gdb (GDB) 7.9.1Copyright (C) 2015 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type \"show copying\"and \"show warranty\" for details.This GDB was configured as \"arm-himix200-linux\".Type \"show configuration\" for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type \"help\".Type \"apropos word\" to search for commands related to \"word\"...Reading symbols from test...done.[New LWP 252]warning: Could not load shared library symbols for linux-vdso.so.1.Do you need \"set solib-search-path\" or \"set sysroot\"?Core was generated by `./test'.Program terminated with signal SIGSEGV, Segmentation fault.#0 0x00010530 in get_value (value=0x0) at main.cpp:44 main.cpp: No such file or directory.(gdb) bt#0 0x00010530 in get_value (value=0x0) at main.cpp:4#1 0x00010568 in main (argc=1, argv=0xbeedfe34) at main.cpp:9(gdb) 使用 gdb test core_test_252 命令来加载 coredump 文件。 gdb execute_file_path coredump_file_path加载完之后，使用 bt 指令来打印错误堆栈。bt 即 backtrace 的简写。从上面的分析结果我们知道发生错误的地方在 main.cpp 第 4 行代码。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/tags/Linux/"},{"name":"coredump","slug":"coredump","permalink":"http://qiushao.net/tags/coredump/"}]},{"title":"hdmi edid 分辨率设置","slug":"hdmi/hdmi-edid-reslution-setting","date":"2020-04-22T10:00:00.000Z","updated":"2020-12-27T01:22:23.748Z","comments":true,"path":"2020/04/22/hdmi/hdmi-edid-reslution-setting/","link":"","permalink":"http://qiushao.net/2020/04/22/hdmi/hdmi-edid-reslution-setting/","excerpt":"","text":"以下说明截图基于 R_980mgr_4.16.39.13141_Win.msi 工具(以下简称 980)，最好先安装这个工具，然后对着说明进行操作。关于 edid 的各字段这里不再作解析，请网上查阅资料。可以参考以下文章: https://www.cnblogs.com/beyond-rxl/archive/2018/07/05/9266997.htmlhttps://blog.csdn.net/Gplusplus/article/details/52597033 本文只解析说明如何修改 edid 以支持目标分辨率。设置推荐分辨率。 1. 导入 edid打开 980, 切换到 EDID/DPCD 标签页，右键 EDID - USER 菜单，选择 import 菜单。然后选择需要编辑的 EDID 文件即可。 980 的界面菜单大致功能划分如下： 2. 分辨率设置在EDID中定义了几种 Timing，分别是 Established Timing、Standard Timing、Detailed Timing 还有一些额外的Timing，比如GTF和CVT Timing。其中 Detailed Timing 又包含了： Preferred Timing， 普通 Detailed Timing， Extension Block中的Detailed Timing。这三者的格式基本是一致的。 对于显示器来说，支持的这些 Timing 有一个优先级：Preferred Timing &gt; 普通 Detailed Timing &gt; Extension Block 中的 Detailed Timing &gt; CVT &gt; Standard Timing &gt; Established Timing 下面对这几种 Timing 分别解析。 2.1. Established Timings提供一些基本固定的VESA, Apple, Mac, IBM VGA等输出的Timing。这个比较简单，如果确认芯片支持这些分辨率的话，直接打钩就行了。不需要解析。 2.2. Standard Timings总共16个字节，提供最多8种分辨率的识别，每一种分辨率都是由2个字节的模式格式和刷新率得到的。这些分辨率应该是对 Established Timings 的一种扩充。 每个字段的意义解析如下： Unused : 是否使用这个分辨率。 H-Active Pixels(256-2288 by 8) :水平分辨率, 例如 1280 Image Aspect Ratio: 画面比例(水平分辨率 : 垂直分辨率), 例如 5:4 Refresh Rate(60 - 123 HZ): 刷新率，也就是帧率，例如 60 其中水平分辨率和画面比例共同决定了分辨率。如上面的例子。水平分辨率为 1280, 画面比例为 5 : 4。那我们就可以算出垂直分辨率：水平分辨率 / 垂直分辨率 = 5 / 4–&gt; 垂直分辨率 = 水平分辨率 * 4 / 5 = 1280 * 4 / 5 = 1024 也就是整个分辨率块定义的分辨率为： 1280 * 1024 60HZ 。 2.3 Detailed Timing2.3.1 Preferred Timing (推荐分辨率)推荐分辨率就是 hdmi 设备优先输出的分辨率。当用户没有手动设置过分辨率时，且 hdmi 设备支持时，输出的分辨率就是推荐分辨率。如果是 windows 电脑接入电视的话，我们在设置分辨的时候分看到分辨率列表里面有(推荐) 的字样提示： Preferred Timing 其实用的就是第一个 Detailed Timing: 2.3.2 普通 Detailed Timing各字段的描述跟 Preferred Timing 一样的。 目前其实也只有 Descriptor 2。普通 Detailed Timing Descriptions。共72个字节分为四个详细时序描述块（DTD），每部分18个字节，故最多可以对四个TIMING 进行详细描述。一般来说 Descriptor 1/2 用来描述分辨率, 其中 Descriptor 1 作为推荐分辨率。 Descriptor 3/4 用来描述显示器信息（比如说显示器名）。 显示器名的设置如下： 2.3.3 Extension Block 中的 Detailed Timing扩展块中的 Detailed Timing 跟普通 Detailed Timing 的字段是一样的。只不过是放的位置不一样而已。当前面三种方法不能囊括我们想要支持的分辨率，且 EDID 还有足够的空间的时候。我们就可以通过这种方法来添加分辨率支持。 4. 导出 edid修改完之后，点一下 Apply 按钮，然后然后 File –&gt; Export， 选择 bin 形式导出即可。","categories":[{"name":"hdmi","slug":"hdmi","permalink":"http://qiushao.net/categories/hdmi/"}],"tags":[{"name":"edid","slug":"edid","permalink":"http://qiushao.net/tags/edid/"},{"name":"hdmi","slug":"hdmi","permalink":"http://qiushao.net/tags/hdmi/"}]},{"title":"Hi3519AV100 sdk 介绍","slug":"IPCamera/Hi3519AV100-sdk-overview","date":"2020-04-15T13:30:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/04/15/IPCamera/Hi3519AV100-sdk-overview/","link":"","permalink":"http://qiushao.net/2020/04/15/IPCamera/Hi3519AV100-sdk-overview/","excerpt":"","text":"0. 文档目录结构1234567891011121314151617181920212223qiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519&#x2F;ReleaseDoc&#x2F;zh$ tree -L 4.├── 00.hardware # 硬件相关文档├── 01.software # 软件相关文档│ ├── board│ │ ├── Hi3519AV100 SDK 安装及升级使用说明.pdf # sdk 安装,编译，烧录说明。本文后面的内容主要参考此文档。│ │ ├── Hi3519AV100与Hi3559AV100 开发包差异说明.pdf│ │ ├── MPP│ │ │ ├── HDMI 开发参考.pdf│ │ │ ├── HiMPP V4.0 媒体处理软件 FAQ.pdf│ │ │ ├── HiMPP V4.0 媒体处理软件开发参考.pdf # camera 功能开发参考文档。进行 camera 应用开发时主要参考此文档。│ │ ├── OSDRV│ │ │ ├── Hi3519AV100╱Hi3556AV100 U-boot 移植应用开发指南.pdf│ │ │ ├── Hi3519AV100╱Hi3556AV100 开发环境用户指南.pdf│ │ │ ├── UBI 文件系统使用指南.pdf│ │ │ ├── 外围设备驱动 操作指南.doc│ │ │ └── 裸烧及非裸烧升级 使用手册.pdf│ │ ├── PQ│ │ └── SVP│ ├── Hi3519AV100R001 Open Source Software Notice.doc│ ├── HiMPP SDK 二次开发网络安全注意事项.pdf│ ├── pc├── 02.only for reference 1. sdk 目录结构我们拿到的 sdk 有以下文件： 123456789101112qiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519$ ll-rwxr-x--- 1 qiushao geoclue 1870000000 Apr 3 08:54 arm-himix200-linux.part1.rar*-rwxr-x--- 1 qiushao geoclue 1861766810 Apr 3 08:54 arm-himix200-linux.part2.rar*-rwxr-x--- 1 qiushao geoclue 1519247343 Apr 3 08:55 Hi3519AV100R001C02SPC020.rar*-rwxr-x--- 1 qiushao geoclue 12771415 Apr 3 08:56 HiDPU_PC_V2.0.0.0.tgz*-rwxr-x--- 1 qiushao geoclue 22645270 Apr 3 08:56 HiIVE_PC_V2.1.0.8_64bit_sec.tgz*-rwxr-x--- 1 qiushao geoclue 1710000000 Apr 3 08:55 HiSVP_PC_V1.2.2.0.part1.rar*-rwxr-x--- 1 qiushao geoclue 1710000000 Apr 3 08:55 HiSVP_PC_V1.2.2.0.part2.rar*-rwxr-x--- 1 qiushao geoclue 1710000000 Apr 3 08:54 HiSVP_PC_V1.2.2.0.part3.rar*-rwxr-x--- 1 qiushao geoclue 1681662082 Apr 3 08:56 HiSVP_PC_V1.2.2.0.part4.rar*-rwxr-x--- 1 qiushao geoclue 15852 Apr 3 08:55 linux-4.9.y.rar*qiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519$ 我们目前用到的只有前面三个文件。其中 arm-himix200-linux 是编译工具链。 Hi3519AV100R001C02SPC020 是 sdk 及一些工具。Hi3519AV100R001C02SPC020.rar 解压后的目录结构如下： 12345678910qiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519&#x2F;Hi3519AV100R001C02SPC020$ tree.├── 00.hardware # 硬件相关设计文档├── 01.software # 软件相关，包括 sdk 代码和烧录工具,调试工具等│ ├── board│ │ └── Hi3519AV100_SDK_V2.0.2.0.tgz│ └── pc│ └── HiTool│ └── HiTool-BVT-5.2.7.zip└── 02.only for reference # 其他参考文档，包括 sensor 规则书，uboot 移植相关的硬件信息表等 其中 Hi3519AV100_SDK_V2.0.2.0.tgz 是最重要的 sdk 代码包。我们把它拿出来解压。目录结构如下： 1234567891011121314151617181920qiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519&#x2F;Hi3519AV100_SDK_V2.0.2.0$ tree.├── package│ ├── drv.tgz│ ├── mpp_smp_linux.tgz│ ├── osal.tgz│ └── osdrv.tgz├── scripts│ └── common.sh├── sdk.cleanup├── sdk.unpack└── smp_image_glibc ├── rootfs_hi3519av100_128k.jffs2 ├── rootfs_hi3519av100_256k.jffs2 ├── rootfs_hi3519av100_2k_24bit.yaffs2 ├── rootfs_hi3519av100_2k_4bit.yaffs2 ├── rootfs_hi3519av100_32M.ext4 ├── rootfs_hi3519av100_64k.jffs2 ├── u-boot-hi3519av100.bin └── uImage_hi3519av100_smp 代码压缩文件都放在 package 目录。我们需要执行 sdk.unpack 脚本来解压代码： 1qiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519&#x2F;Hi3519AV100_SDK_V2.0.2.0$ .&#x2F;sdk.unpack 解压代码后目录结构如下: 12345678910111213141516171819202122232425262728293031323334353637383940qiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519&#x2F;Hi3519AV100_SDK_V2.0.2.0$ tree -L 4.├── osdrv # bsp 相关代码, 主要包含 uboot, kernel, rootfs │ ├── components│ │ ├── ipcm│ │ └── pcie_mcc│ ├── Makefile│ ├── opensource│ │ ├── busybox # busybox 源码│ │ ├── kernel # kernel 源码，│ │ └── uboot│ ├── pub # 编译出来的镜像放在这个目录│ ├── rootfs_scripts│ └── tools # 编译镜像需要的一些工具├── package # 压缩的 sdk├── scripts # sdk 解压相关脚本├── sdk.cleanup├── sdk.unpack ├── smp │ ├── a53_linux│ │ ├── drv│ │ │ ├── extdrv ＃ 外设驱动│ │ │ └── interdrv # 内部芯片驱动│ │ ├── mpp # 媒体处理相关的驱动，库，头文件以及 sample等。应用层的开发主要就是使用这些库来进行开发了。│ │ │ ├── cfg.mak│ │ │ ├── component│ │ │ ├── include ＃ mpi 头文件│ │ │ ├── init # 媒体模块驱动初始化│ │ │ ├── ko # 预编译好的驱动文件及加载脚本│ │ │ ├── lib # 预编译好的 mpi 静态库和动态库 │ │ │ ├── Makefile.linux.param│ │ │ ├── Makefile.param│ │ │ ├── obj # 预编译好的驱动 .o 文件│ │ │ ├── sample # mpi 接口使用样例，供开发参考。│ │ │ └── tools # 调试工具│ │ └── osal ＃ 操作系统抽象层(Linux, Liteos)│ │ ├── include│ │ └── linux│ └── dsp_liteos└── smp_image_glibc # 预编译好的系统镜像: uboot, kernel, rootfs 2. 编译工具安装2.1 依赖安装先安装以下这些工具，不然编译会出现各种莫名其妙的错误： 1sudo apt-get install gperf bison flex libuuid1 u-boot-tools zlib1g-dev build-essential ncurses-dev libacl1-dev liblzo2-dev uuid-dev zlib1g-dev liblzo2-dev uuid-dev pkg-config texinfo 2.2 编译工具链安装把 arm-himix200-linux.rar 解压后，得到 arm-himix200-linux.tgz。再解压一次得到 arm-himix200-linux 目录，结构如下： 123456789qiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519&#x2F;arm-himix200-linux$ tree .├── arm-himix200-linux.install├── arm-himix200-linux.tar.bz2├── gdb_build.sh├── gdb_readme_cn.txt├── gdb_readme_en.txt├── readme.txt└── runtime_glibc.tgz 按文档的操作，是需要 sudo 执行 arm-himix200-linux.install 进行安装。其实只要把工具链解压，并设置一下 PATH 环境变量就行了： 12345qiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519&#x2F;arm-himix200-linux$ tar xvf arm-himix200-linux.tar.bz2qiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519&#x2F;arm-himix200-linux$ tar xvf runtime_glibc.tgz -C arm-himix200-linux&#x2F;qiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519&#x2F;arm-himix200-linux&#x2F;arm-himix200-linux&#x2F;bin$ cd qiushao@qiushao-pc:~$ echo &#39;PATH&#x3D;&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519&#x2F;arm-himix200-linux&#x2F;arm-himix200-linux&#x2F;bin:$PATH&#39; &gt;&gt; ~&#x2F;.bashrcqiushao@qiushao-pc:~$ source ~&#x2F;.bashrc 3. 编译烧录 uboot, kernel, rootfs编译方法主要参考 Hi3519AV100_SDK/osdrv/readme_cn.txt 说明文件。 3.1 下载 kernel由于 GPL 协议的问题，海思并没有把 kernel 的代码一起发布。需要我们自己下载 kernel 源码： 1qiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519&#x2F;Hi3519AV100_SDK&#x2F;osdrv&#x2F;opensource&#x2F;kernel$ wget https:&#x2F;&#x2F;mirrors.edge.kernel.org&#x2F;pub&#x2F;linux&#x2F;kernel&#x2F;v4.x&#x2F;linux-4.9.37.tar.gz 3.2 编译系统镜像在 osdrv 目录下执行 make all 就行 123qiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519AV100_SDK&#x2F;osdrv$ make all...---------finish osdrv work 出现 finish osdrv work 提示，说明已经编译完成了。编译生成的镜像放在 osdrv/pub/smp_image_glibc 目录下: 123qiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519AV100_SDK&#x2F;osdrv&#x2F;pub&#x2F;smp_image_glibc$ lsrootfs_hi3519av100_128k.jffs2 rootfs_hi3519av100_2k_24bit.yaffs2 rootfs_hi3519av100_32M.ext4 u-boot-hi3519av100.binrootfs_hi3519av100_256k.jffs2 rootfs_hi3519av100_2k_4bit.yaffs2 rootfs_hi3519av100_64k.jffs2 uImage_hi3519av100_smp 3.3 烧录系统SPI Nand Flash 的地址空间安排如下： 123| 1M | 4M | 32M ||----------------------|---------------------|---------------------|| uboot | kernel | rootfs | 3.3.1 hitool 烧录如果板子是空板的话，需要使用 hitool 进行烧录。请参考 HiBurn工具使用指南.pdf 3.3.2 tftp 烧录如果板子上有 uboot 的话，且板子有网口的话，则可以使用 tftp 来烧录。因为 hitool 没有提供 linux 版本，所以我一般都是使用 tftp 来烧录了。 tftp 配置上一篇文章我们已经介绍过 tftp 服务环境的搭建了。先修改 tftp 的目录为编译生成 images 的目录：123456# &#x2F;etc&#x2F;default&#x2F;tftpd-hpaTFTP_USERNAME&#x3D;&quot;tftp&quot;TFTP_DIRECTORY&#x3D;&quot;&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519AV100_SDK&#x2F;osdrv&#x2F;pub&#x2F;smp_image_glibc&quot;TFTP_ADDRESS&#x3D;&quot;:69&quot;TFTP_OPTIONS&#x3D;&quot;-l -c -s&quot; 然后重启 tftp 服务。1qiushao@qiushao-pc:&#x2F;etc&#x2F;default$ sudo service tftpd-hpa restart pc 网络信息查看ubuntu 下查看 pc 的 ip, 网关等信息的方法1234567891011121314151617181920212223qiushao@qiushao-pc:~$ ifconfigwlp4s0: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.3.29 netmask 255.255.255.0 broadcast 192.168.3.255 inet6 fe80::f7d3:b73c:461a:af45 prefixlen 64 scopeid 0x20&lt;link&gt; inet6 240e:fe:3839:339:c717:1207:24ef:fd76 prefixlen 64 scopeid 0x0&lt;global&gt; inet6 240e:fe:3839:300:7c94:2acf:4818:8 prefixlen 128 scopeid 0x0&lt;global&gt; inet6 240e:fe:3839:339:1002:ba0c:2ed:5ffa prefixlen 64 scopeid 0x0&lt;global&gt; ether 40:74:e0:b3:f2:63 txqueuelen 1000 (Ethernet) RX packets 36413 bytes 33826854 (33.8 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 16292 bytes 2617305 (2.6 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0qiushao@qiushao-pc:~$ qiushao@qiushao-pc:~$ route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 192.168.3.1 0.0.0.0 UG 600 0 0 wlp4s0169.254.0.0 0.0.0.0 255.255.0.0 U 1000 0 0 virbr0172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0192.168.3.0 0.0.0.0 255.255.255.0 U 600 0 0 wlp4s0192.168.122.0 0.0.0.0 255.255.255.0 U 0 0 0 virbr0qiushao@qiushao-pc:~$ 根据以上信息得到 pc 的网络信息如下：ip: 192.168.3.29netmask: 255.255.255.0gateway: 192.168.3.1mac: 40:74:e0:b3:f2:63 板子网络信息配置板子需要接入和 pc 同一个局域网。板子上电后, 敲任意键进入 u-boot。设置 serverip(即 tftp 服务器的 ip), ipaddr(板子 ip)和 ethaddr(板子的 MAC 地址)。12345678910111213141516hisilicon # setenv serverip 192.168.3.29hisilicon # setenv ipaddr 192.168.3.30 # 板子的 ip，参考 serverip, 修改最后一位即可。hisilicon # setenv netmask 255.255.255.0hisilicon # setenv gatewayip 192.168.3.1hisilicon # setenv ethaddr 40:74:e0:b3:f2:64 # 参考 pc 的 mac, 修改最后一位即可。hisilicon # saveenvSaving Environment to NAND...Erasing NAND...Erasing at 0xa0000 -- 100% complete.Writing to NAND... OKhisilicon # ping 192.168.3.29 # 确认网络设置正常。ETH0: PHY(phyaddr&#x3D;1, rgmii) link UP: DUPLEX&#x3D;FULL : SPEED&#x3D;1000MMAC: 54-E1-AD-0A-A1-F8Using gmac0 devicehost 192.168.3.29 is alivehisilicon # 烧录分区 烧写 u-boot123mw.b 42000000 ff 80000tftp 0x42000000 u-boot-hi3519av100.binnand erase 0 80000;nand write 42000000 0 80000 烧写内核123mw.b 42000000 ff 400000tftp 42000000 uImage_hi3519av100_smpnand erase 100000 400000;nand write 42000000 100000 400000 烧写根文件系统123mw.b 42000000 ff 2000000tftp 42000000 rootfs_hi3519av100_2k_4bit.yaffs2nand erase 500000 2000000;nand write.yaffs 42000000 500000 0xafeb00 (0xafeb00 为实际文件大小) 设置启动参数123setenv bootargs &#39;mem&#x3D;256M console&#x3D;ttyAMA0,115200 clk_ignore_unused root&#x3D;&#x2F;dev&#x2F;mtdblock2 rw rootfstype&#x3D;yaffs2 mtdparts&#x3D;hinand:1M(boot),4M(kernel),32M(rootfs)&#39;setenv bootcmd &#39;nand read 0x42000000 100000 400000; bootm 0x42000000&#39;saveenv 重启系统1reset 4. 板子网络环境配置经过上面的步骤，我们的系统是跑起来了，但只是把 kernel 启动了，根文件系统挂载了而已，什么业务都没有运行的。我们需要编写自己的应用在上面运行才可以。在写代码之前我们还需要配置一下板子的网络环境，以便开发调试。在开发阶段,推荐使用 NFS 作为开发环境,可以省去重新制作和烧写根文件系统的工作。也不需要频繁用 u 盘 copy 文件。 4.1 pc端配置nfs服务pc 端 nfs 服务的配置之前已经介绍过了，这里面就不再重复。我们把 nfs share 的目录改成 Hi3519AV100_SDK： 123456789101112131415qiushao@qiushao-pc:&#x2F;etc$ cat exports # &#x2F;etc&#x2F;exports: the access control list for filesystems which may be exported# to NFS clients. See exports(5).## Example for NFSv2 and NFSv3:# &#x2F;srv&#x2F;homes hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_subtree_check)## Example for NFSv4:# &#x2F;srv&#x2F;nfs4 gss&#x2F;krb5i(rw,sync,fsid&#x3D;0,crossmnt,no_subtree_check)# &#x2F;srv&#x2F;nfs4&#x2F;homes gss&#x2F;krb5i(rw,sync,no_subtree_check)#&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519AV100_SDK *(rw,sync,no_subtree_check,root_squash)qiushao@qiushao-pc:&#x2F;etc$qiushao@qiushao-pc:&#x2F;etc$ sudo exportfs -a qiushao@qiushao-pc:&#x2F;etc$ sudo service nfs-kernel-server restart 4.2 设置板子的 mac,ip 等信息123456789101112~ # ifconfig eth0 hw ether 40:74:e0:b3:f2:64~ # ifconfig eth0 192.168.3.30 netmask 255.255.255.0IPv6: ADDRCONF(NETDEV_UP): eth0: link is not ready~ # hi_gmac_v200 40e0000.ethernet eth0: Link is Up - 1Gbps&#x2F;Full - flow control offIPv6: ADDRCONF(NETDEV_CHANGE): eth0: link becomes ready~ # route add default gw 192.168.3.1~ # ping 192.168.3.29PING 192.168.3.29 (192.168.3.29): 56 data bytes64 bytes from 192.168.3.29: seq&#x3D;0 ttl&#x3D;64 time&#x3D;43.142 ms64 bytes from 192.168.3.29: seq&#x3D;1 ttl&#x3D;64 time&#x3D;62.610 ms64 bytes from 192.168.3.29: seq&#x3D;2 ttl&#x3D;64 time&#x3D;76.662 ms 4.3 板子上挂载 nfs 文件系统12345~ # mount -t nfs -o nolock -o tcp -o rsize&#x3D;32768,wsize&#x3D;32768 192.168.3.29:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519AV100_SDK &#x2F;mnt~ # ls &#x2F;mntosdrv scripts sdk.unpack smp_image_glibcpackage sdk.cleanup smp~ # 5. 编译运行 sample5.1 编译 sample海思 sdk 里面带了一些 sample: 1234qiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519AV100_SDK&#x2F;smp&#x2F;a53_linux&#x2F;mpp&#x2F;sample$ lsaudio awb_online_calibration dis fisheye lsc_online_cali Makefile.param region smp_linux.mak svp traffic_capture vdec vgsavs common dpu hifb Makefile pciv scene_auto snap tde uvc_app venc vioqiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519AV100_SDK&#x2F;smp&#x2F;a53_linux&#x2F;mpp&#x2F;sample$ 我们先试着在上面跑个简单的 vio sample 看看。vio sample 的功能是从摄像头输出，然后输出到 hdmi。编译的方法很简单，进入 sample/vio 目录，直接 make 就行。编译成功的话，会在 vio 目录生成一个 sample_vio_main 文件: 1234567qiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519AV100_SDK&#x2F;smp&#x2F;a53_linux&#x2F;mpp&#x2F;sample$ cd vioqiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519AV100_SDK&#x2F;smp&#x2F;a53_linux&#x2F;mpp&#x2F;sample&#x2F;vio$ lsMakefile res sample_vio.h sample_vio_main.c smpqiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519AV100_SDK&#x2F;smp&#x2F;a53_linux&#x2F;mpp&#x2F;sample&#x2F;vio$ make...qiushao@qiushao-pc:&#x2F;media&#x2F;qiushao&#x2F;source-code&#x2F;Hi3519AV100_SDK&#x2F;smp&#x2F;a53_linux&#x2F;mpp&#x2F;sample&#x2F;vio$ lsMakefile res sample_vio.h sample_vio_main sample_vio_main.c sample_vio_main.o smp 5.2 加载设备驱动现在我们又回到板子上进行操作。在运行 sample 之前我们需要先加载 hisi 的驱动 12345678910&#x2F; # cd &#x2F;mnt&#x2F;smp&#x2F;a53_linux&#x2F;mpp&#x2F;ko&#x2F;mnt&#x2F;smp&#x2F;a53_linux&#x2F;mpp&#x2F;ko # .&#x2F;load3519av100 -i -sensor0 imx334mmz_start: 0x32000000, mmz_size: 1760Msys_config: loading out-of-tree module taints kernel.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;sensr0: imx334&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;sensr1: imx334&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;sensr2: imx334&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;sensr3: imx334&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;sensr4: imx334&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Module himedia: init ok 5.3 运行 sample驱动加载成功之后，就可以开始运行 sample 啦 1234567891011121314151617181920212223242526&#x2F;mnt&#x2F;smp&#x2F;a53_linux&#x2F;mpp # cd sample&#x2F;vio&#x2F;&#x2F;mnt&#x2F;smp&#x2F;a53_linux&#x2F;mpp&#x2F;sample&#x2F;vio # .&#x2F;sample_vio_mainUsage : .&#x2F;sample_vio_main &lt;index&gt; &lt;intf&gt;index: 0)VI(Online) - VPSS(Online) - VO. 1)VI(Offline)- VPSS(Offline) - VO. LDC+DIS+SPREAD. 2)VI(Offline)- VPSS(Online) - VO. Double pipe. 3)VI(Online)- VPSS(Offline) - VO. Double chn. 4)Resolute Ratio Switch. 5)GDC - VPSS LowDelay. 6)Double WDR Pipe. 7)FPN Calibrate &amp; Correction. 8)WDR Switch. 9)90&#x2F;180&#x2F;270 Rotate. 10)Mipi Demux Yuv. 11)UserPic.intf: 0) vo HDMI output, default. 1) vo BT1120 output.&#x2F;mnt&#x2F;smp&#x2F;a53_linux&#x2F;mpp&#x2F;sample&#x2F;vio # .&#x2F;sample_vio_main 0[SAMPLE_COMM_VI_SetMipiAttr]-1408: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; MipiDev 0, SetMipiAttr enWDRMode: 0linear mode&#x3D;&#x3D;&#x3D;Imx334 8M30fps 12bit LINE Init OK!&#x3D;&#x3D;&#x3D;[SAMPLE_COMM_ISP_Thread]-187: ISP Dev 0 running ![SAMPLE_COMM_VO_StartChn]-544: u32Width:1920, u32Height:1080, u32Square:1---------------press Enter key to exit!--------------- 至此，系统就已经运行起来了， sample 也运行起来了。后面我们再来逐步学习 camera 系统相关的开发知识。","categories":[{"name":"Camera","slug":"Camera","permalink":"http://qiushao.net/categories/Camera/"}],"tags":[{"name":"Hi3519AV100","slug":"Hi3519AV100","permalink":"http://qiushao.net/tags/Hi3519AV100/"},{"name":"Camera","slug":"Camera","permalink":"http://qiushao.net/tags/Camera/"}]},{"title":"busybox rx 传输文件","slug":"Linux/busybox-rx","date":"2020-04-12T12:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/04/12/Linux/busybox-rx/","link":"","permalink":"http://qiushao.net/2020/04/12/Linux/busybox-rx/","excerpt":"","text":"如果你的板子上没有网口，没有 usb 口，只有一个串口可以交互的时候，我想要把一个文件从 pc 传到板子上，该怎么办呢？这个时候就只能用串口传输了，还好 busybox 就带了一个 rx 命令，支持串口传输文件。因为串口的传输速度很慢，只有 10k/s 左右而已。所以传输稍大一点的文件就力不从心了。但对于一两M的小文件还是挺方便的。下面来演示一下使用方法。 在板子上启动接收文件服务 12&#x2F;data # busybox rx camera_appCC 这时就是在等待接收 pc 端发送的文件了。接收到的文件保存为 camera_app。 pc 端通过 xmodern 发送文件我使用的是 secureCRT 来连接的串口。SecureCRT –&gt; Transfer –&gt; send xmodern然后选择要发送的文件即可。 12345&#x2F;data # busybox rx camera_appCCStarting xmodem transfer. Press Ctrl+C to cancel.Transferring &#x2F;home&#x2F;qiushao&#x2F;camera_app... 72% 3110 KB 11 KB&#x2F;sec 00:01:47 ETA 0 Errors","categories":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/tags/Linux/"}]},{"title":"ubuntu 18.04 安装配置 nfs 服务","slug":"Linux/ubuntu-nfs-settings","date":"2020-04-12T08:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/04/12/Linux/ubuntu-nfs-settings/","link":"","permalink":"http://qiushao.net/2020/04/12/Linux/ubuntu-nfs-settings/","excerpt":"","text":"最近在学习 hi3519av100 camera 开发，为避免频繁使用 u 盘 copy 文件，因此需要搭建 nfs 服务。 1. 安装服务端和客户端1sudo apt install nfs-kernel-server nfs-common 其中 nfs-kernel-server 为服务端， nfs-common 为客户端。 2. 配置 nfs 共享目录在家目录创建共享目录，并在 /etc/exports 中导出: 123qiushao@qiushao-pc:~$ mkdir nfs-shareqiushao@qiushao-pc:~$ sudo vim &#x2F;etc&#x2F;exports &#x2F;home&#x2F;qiushao&#x2F;nfs-share *(rw,sync,no_root_squash,no_subtree_check) 格式如下：共享目录 可访问共享目录的ip(共享目录权限列表)各字段解析如下：/home/qiushao/nfs-share: 要共享的目录：指定可以访问共享目录的用户 ip, * 代表所有用户。192.168.3. 指定网段。192.168.3.29 指定 ip。rw：可读可写。如果想要只读的话，可以指定 ro。sync：文件同步写入到内存与硬盘中。async：文件会先暂存于内存中，而非直接写入硬盘。no_root_squash：登入 nfs 主机使用分享目录的使用者，如果是 root 的话，那么对于这个分享的目录来说，他就具有 root 的权限！这个项目『极不安全』，不建议使用！但如果你需要在客户端对 nfs 目录进行写入操作。你就得配置 no_root_squash。方便与安全不可兼得。root_squash：在登入 nfs 主机使用分享之目录的使用者如果是 root 时，那么这个使用者的权限将被压缩成为匿名使用者，通常他的 UID 与 GID 都会变成 nobody 那个系统账号的身份。subtree_check：强制 nfs 检查父目录的权限（默认）no_subtree_check：不检查父目录权限 配置完成后，执行以下命令导出共享目录，并重启 nfs 服务: 123qiushao@qiushao-pc:~$ sudo exportfs -a qiushao@qiushao-pc:~$ sudo service nfs-kernel-server restartqiushao@qiushao-pc:~$ 这样服务端就配置完成啦。 3. 客户端访问测试123456qiushao@qiushao-pc:~$ sudo mount localhost:&#x2F;home&#x2F;qiushao&#x2F;nfs-share &#x2F;mntqiushao@qiushao-pc:~$ cd &#x2F;mntqiushao@qiushao-pc:&#x2F;mnt$ lsqiushao@qiushao-pc:&#x2F;mnt$ touch foobarqiushao@qiushao-pc:&#x2F;mnt$ ls ~&#x2F;nfs-share&#x2F;foobar 我们把 nfs-share 共享文件系统挂载到 /mnt， 可以看到我们在 /mnt 目录下创建一个 foobar 文件，然后在 nfs-share 目录下也有一个 foobar 文件。看起来 nfs 的配置是已经 ok 了。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/tags/Linux/"},{"name":"nfs","slug":"nfs","permalink":"http://qiushao.net/tags/nfs/"}]},{"title":"ubuntu 18.04 安装配置 tftp","slug":"Linux/ubuntu-tftp-settings","date":"2020-04-04T08:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/04/04/Linux/ubuntu-tftp-settings/","link":"","permalink":"http://qiushao.net/2020/04/04/Linux/ubuntu-tftp-settings/","excerpt":"","text":"因为最近要开始搞 Camera 了，初步看了下开发文档，发现需要使用 tftp 来进行烧录，因此在电脑上配置好 tftp 服务先。 1. 安装 tftp 服务端，客户端一行命令即可： 1qiushao@qiushao-pc:~$ sudo apt-get install tftp-hpa tftpd-hpa 其中 tftp-hpa 是客户端， tftpd-hpa 是服务端。 2. 配置服务端修改 /etc/default/tftpd-hpa 文件内容如下 123456# &#x2F;etc&#x2F;default&#x2F;tftpd-hpaTFTP_USERNAME&#x3D;&quot;tftp&quot;TFTP_DIRECTORY&#x3D;&quot;&#x2F;home&#x2F;qiushao&#x2F;tftp-root&quot;TFTP_ADDRESS&#x3D;&quot;:69&quot;TFTP_OPTIONS&#x3D;&quot;-l -c -s&quot; TFTP_DIRECTORY : tftp 启动根目录， 修改成自己想要的目录 TFTP_OPTIONS : tftp 启动选项，各选项解析如下： -l –Listen -c –create -s –secure 如果你在客户端获取文件时出现 Error code 1: File not found 这个错误，请检查一下 TFTP_OPTIONS=&quot;-l -c -s&quot;。配置好后，重启 tftp 服务: 1qiushao@qiushao-pc:~$ sudo service tftpd-hpa restart 检查一下服务是否在运行了： 1234qiushao@qiushao-pc:~$ netstat -a | grep tftpudp 0 0 0.0.0.0:tftp 0.0.0.0:* udp6 0 0 [::]:tftp [::]:* qiushao@qiushao-pc:~$ 有 tftp 监听了，说明服务已经启动了。 3. 客户端测试我们先在 /home/qiushao/tftp-root 目录下创建一个文件 foobar，然后在 /home/qiushao 目录执行 tftp get 来下载文件: 12345678910qiushao@qiushao-pc:~$ cd tftp-root&#x2F;qiushao@qiushao-pc:~&#x2F;tftp-root$ touch foobarqiushao@qiushao-pc:~&#x2F;tftp-root$ lsfoobarqiushao@qiushao-pc:~&#x2F;tftp-root$ cd qiushao@qiushao-pc:~$ tftp localhosttftp&gt; get foobarqiushao@qiushao-pc:~$ ls foobar foobarqiushao@qiushao-pc:~$ tftp get 下载文件成功了，说明我们的 tftp 服务应该是没有问题的了。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/tags/Linux/"},{"name":"tftp","slug":"tftp","permalink":"http://qiushao.net/tags/tftp/"}]},{"title":"c++静态代码检查-TscanCode","slug":"c++/c++静态代码检查","date":"2020-03-21T12:00:00.000Z","updated":"2020-12-27T01:22:23.748Z","comments":true,"path":"2020/03/21/c++/c++静态代码检查/","link":"","permalink":"http://qiushao.net/2020/03/21/c++/c++%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5/","excerpt":"","text":"前面两篇文章我们制定了编码规范，还有编码规范检查的方法。编码规范是为了让大家写代码的风格更统一，为了让人更好的阅读理解代码。相比编码规范，我觉得代码静态检查，提前发现潜在的错误更为重要。有很多开源的工具，或者商业的产品提供了静态检查的功能：开源的工具：TscanCode, cppcheck, clang等商业收费的工具：pclint, coverity 等 目前只用过 cppcheck, TscanCode, 个人感觉 TscanCode 更加专业一点。 在公司的代码仓库上使用 cppckeck 检查，有很多误报，还有很多编码风格的小问题，真正的严重错误基本上没有发现。用 TscanCode 发现了五十几个严重错误，基本上没有误报的。下面就详细介绍一下 TscanCode 的使用方法，其他工具的就做介绍了，感兴趣的同学请自行搜索。 1. 安装TscanCode 是开源的工具，代码仓库为：https://github.com/Tencent/TscanCode, 我们可以自己下载下来编译，也可以使用腾讯预编译好的可执行文件(代码仓库的 release 目录)。简单起见，我们直接使用预编译好的文件就行。 1234567qiushao@qiushao-pc:~&#x2F;projects&#x2F;opensources$ git clone https:&#x2F;&#x2F;github.com&#x2F;Tencent&#x2F;TscanCode.gitqiushao@qiushao-pc:~&#x2F;projects&#x2F;opensources$ cd TscanCode&#x2F;release&#x2F;linux&#x2F;qiushao@qiushao-pc:~&#x2F;projects&#x2F;opensources&#x2F;TscanCode&#x2F;release&#x2F;linux$ unzip TscanCodeV2.14.24.linux.zip qiushao@qiushao-pc:~&#x2F;projects&#x2F;opensources&#x2F;TscanCode&#x2F;release&#x2F;linux$ cd TscanCodeV2.14.24.linux&#x2F;TscanCodeV2.14.2395.linuxqiushao@qiushao-pc:~&#x2F;projects&#x2F;opensources&#x2F;TscanCode&#x2F;release&#x2F;linux&#x2F;TscanCodeV2.14.24.linux&#x2F;TscanCodeV2.14.2395.linux$ chmod a+x tscancode qiushao@qiushao-pc:~&#x2F;projects&#x2F;opensources&#x2F;TscanCode&#x2F;release&#x2F;linux&#x2F;TscanCodeV2.14.24.linux&#x2F;TscanCodeV2.14.2395.linux$ echo &quot;PATH&#x3D;$PATH:$(pwd)&quot; &gt;&gt; ~&#x2F;.bashrcqiushao@qiushao-pc:~&#x2F;projects&#x2F;opensources&#x2F;TscanCode&#x2F;release&#x2F;linux&#x2F;TscanCodeV2.14.24.linux&#x2F;TscanCodeV2.14.2395.linux$ source ~&#x2F;.bashrc 这样就安装完了。 2. 基本使用方法我们先看看帮助 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667qiushao@qiushao-pc:~&#x2F;projects&#x2F;opensources&#x2F;TscanCode$ tscancode -hTscanCode - A tool for static C&#x2F;C++ code analysisSyntax: tscancode [OPTIONS] [files or paths]If a directory is given instead of a filename, *.cpp, *.cxx, *.cc, *.c++, *.c,*.tpp, and *.txx files are checked recursively from the given directory.Options: -D&lt;ID&gt; Define preprocessor symbol. Unless --max-configs or --force is used, TscanCode will only check the given configuration when -D is used. Example: &#39;-DDEBUG&#x3D;1 -D__cplusplus&#39;. -U&lt;ID&gt; Undefine preprocessor symbol. Use -U to explicitly hide certain #ifdef &lt;ID&gt; code paths from checking. Example: &#39;-UDEBUG&#39; --enable&#x3D;&lt;id&gt; Enable additional checks. The available ids are: * all Enable all checks. It is recommended to only use --enable&#x3D;all when the whole program is scanned, because this enables unusedFunction. * warning Enable warning messages * style Enable all coding style checks. All messages with the severities &#39;style&#39;, &#39;performance&#39; and &#39;portability&#39; are enabled. * performance Enable performance messages * portability Enable portability messages * information Enable information messages * unusedFunction Check for unused functions. It is recommend to only enable this when the whole program is scanned. * missingInclude Warn if there are missing includes. For detailed information, use &#39;--check-config&#39;. Several ids can be given if you separate them with commas. See also --std -h, --help Print this help. -I &lt;dir&gt; Give path to search for include files. Give several -I parameters to give several paths. First given path is searched for contained header files first. If paths are relative to source files, this is not needed. -j &lt;jobs&gt; Start [jobs] threads to do the checking simultaneously. -q, --quiet Do not show progress reports. --xml Write results in xml format to error stream (stderr).Example usage: # Recursively check the current folder. Print the progress on the screen and # write errors to a file: tscancode . 2&gt; err.txt # Recursively check ..&#x2F;myproject&#x2F; and don&#39;t print progress: tscancode --quiet ..&#x2F;myproject&#x2F; # Check test.cpp, enable all checks: tscancode --enable&#x3D;all test.cpp # Check f.cpp and search include files from inc1&#x2F; and inc2&#x2F;: tscancode -I inc1&#x2F; -I inc2&#x2F; f.cppqiushao@qiushao-pc:~&#x2F;projects&#x2F;opensources&#x2F;TscanCode$ 语法格式如下： 1tscancode [OPTIONS] [files or paths] 可以对文件和目录进行扫描，如果是目录的话，会递归扫描目录下的所有 *.cpp, *.cxx, *.cc, *.c++, *.c, *.tpp, and *.txx 文件。提供以下选项： -D: 定义宏定义。比如:-DDEBUG=1 -D__cplusplus。 -U: 取消宏定义。比如：-UDEBUG。 --enable=: 启用附加检查。取值范围： all : 启用所有附加检查。 warning : 打开 warning 消息。 style : 启用代码风格检查。 performance : 启用性能检查。 portability : 启用可移植性检查。 information : 打开 information 消息。 unusedFunction : 启用未调用函数检查。 missingInclude : 启用找不到头文件消息。 -I: 指定头文件路径。比如：-Ifoobar/include。 -j: 并发检查线程数。比如: -j8。 -q: 不打印处理进度，只输出结果。 --xml: 指定输出格式为 xml。 使用例子1：递归检查 samples 目录下所有源文件, 进度信息显示在终端，结果重定向到 result.txt 文件中 1tscancode samples 2&gt; result.txt 实际使用时发现有错误： 12345qiushao@qiushao-pc:~&#x2F;projects&#x2F;opensources&#x2F;TscanCode$ tscancode samples 2&gt; result.txtFailed to load setting file &#39;cfg.xml&#39;. File not foundFailed to load library configuration file &#39;std.cfg&#39;. File not foundFailed to load library configuration file &#39;posix.cfg&#39;. File not foundFailed to load library configuration file &#39;windows.cfg&#39;. File not found 看信息是没有找到 cfg.xml 文件， cfg.xml 文件在 tscancode 文件同级目录下。查看代码，发现居然需要使用绝对路径或者相对路径调用 tscancode 才行(也就是调用路径一定要存在/)，改成以下调用方式后就可以了： 1.&#x2F;release&#x2F;linux&#x2F;TscanCodeV2.14.24.linux&#x2F;TscanCodeV2.14.2395.linux&#x2F;tscancode .&#x2F;samples 2&gt; result.txt 呵呵，居然不知道获取执行文件的路径，然后从同级目录下读取 cfg。 使用例子2:指定头文件目录 1tscancode -I inc1&#x2F; -I inc2&#x2F; f.cpp 3. 启用关闭部分检查配置文件在 tscancode 同级目录下的 cfg/cfg.xml 里面。 1234567 &lt;section name&#x3D;&quot;Checks&quot;&gt; &lt;id name&#x3D;&quot;nullpointer&quot; value&#x3D;&quot;1&quot;&gt; &lt;subid name&#x3D;&quot;dereferenceAfterCheck&quot; value&#x3D;&quot;1&quot; severity&#x3D;&quot;Serious&quot; rule_name&#x3D;&quot;先判空后解引用&quot; desc&#x3D;&quot;指针先判空，然后在判空作用域外解引用，因为指针判空暗示当前上下文该指针可能为空，因此建议对没有在&gt;判空作用域的指针添加判空保护。&quot;&#x2F;&gt; &lt;subid name&#x3D;&quot;funcRetNull&quot; value&#x3D;&quot;0&quot; severity&#x3D;&quot;Warning&quot; rule_name&#x3D;&quot;函数返回值未判空解引用&quot; desc&#x3D;&quot;函数存在返回NULL的分支，所以返回值可能为空，应该先判空再使用&quot;&#x2F;&gt; &lt;subid name&#x3D;&quot;funcRetNullStatistic&quot; value&#x3D;&quot;1&quot; severity&#x3D;&quot;Serious&quot; rule_name&#x3D;&quot;基于统计推断函数返回值未判空&quot; desc&#x3D;&quot;通过分析代码调用模式，如果调用func函数，有10处对返回值进行了判空，而只有1处没有判空&gt;，那么很有可能是漏掉了判空。&quot;&#x2F;&gt; 比如说我们不需要空指针检查，把 value 的值改为 0 即可。 4. 规则扩展目前看起来好像只能通过修改代码来添加规则了。这里先不讨论了，后面有需求再研究一下。","categories":[{"name":"c++","slug":"c","permalink":"http://qiushao.net/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://qiushao.net/tags/c/"},{"name":"静态代码检查","slug":"静态代码检查","permalink":"http://qiushao.net/tags/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5/"}]},{"title":"c++编码规范检查-cpplint","slug":"c++/c++编码规范检查","date":"2020-03-15T02:00:00.000Z","updated":"2020-12-27T01:22:23.748Z","comments":true,"path":"2020/03/15/c++/c++编码规范检查/","link":"","permalink":"http://qiushao.net/2020/03/15/c++/c++%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E6%A3%80%E6%9F%A5/","excerpt":"","text":"上一篇文章我们已经制定了编码规范，但规范条例这么多，是不可能人工 review 的，必须得用工具自动化检查才行。因为我们使用的是 google 的编码规范，所以我们直接使用 google 提供的编码规范检查工具 cpplint 就行了。下面详细介绍一下 cpplint 的用法。 1. 下载安装cpplint 其实就是 google styleguide 仓库中的一个 python 脚本而已，直接下载下来就可以使用了。这里我选择 git clone 整个 styleguide 工程，然后把 cpplint 目录加入到 PATH： 12345qiushao@qiushao-pc:~$ cd projects/opensources/qiushao@qiushao-pc:~/projects/opensources$ git clone https://github.com/google/styleguide.gitqiushao@qiushao-pc:~/projects/opensources$ cdqiushao@qiushao-pc:~$ echo 'export PATH=$PATH:/home/qiushao/projects/opensources/styleguide/cpplint' &gt;&gt; .bashrc qiushao@qiushao-pc:~$ source ~/.bashrc 这样 cpplint.py 就安装完了，可以使用了。 2. 基本使用方法我们先看看使用帮助： 12345678qiushao@qiushao-pc:~$ cpplint.py --helpSyntax: cpplint.py [--verbose=#] [--output=vs7] [--filter=-x,+y,...] [--counting=total|toplevel|detailed] [--root=subdir] [--linelength=digits] [--headers=x,y,...] [--quiet] &lt;file&gt; [file] ......... 各参数解析如下： 2.1 --verbosecpplint 把检查结果分成 0 ~ 5 六个等级。等级 0 为输出全部结果。换句话来说就是当错误等级 &gt;= verbose 时，就输出。 2.2 --output指定输出格式，默认格式是 emacs, 还可能指定为 vs7(Visual Studio) 的输出格式。 2.3 --filter分类过滤器，决定是否要输出某些类型的错误。默认输出所有的错误类型。- :不输出这个类型的错误。+ :输出这个类型的错误。比如： 123--filter&#x3D;-whitespace,+whitespace&#x2F;braces--filter&#x3D;whitespace,runtime&#x2F;printf,+runtime&#x2F;printf_format--filter&#x3D;-,+build&#x2F;include_what_you_use 可以这样来查找所有的错误类型： 1234567qiushao@qiushao-pc:~$ cpplint.py --filter&#x3D; build&#x2F;class build&#x2F;c++11 build&#x2F;c++14 build&#x2F;c++tr1 build&#x2F;deprecated ... 2.4 --counting输出结果统计，有三个选项, 默认选项是 total： total :只输出错误总数 toplevel :输出各顶层分类的错误统计，比如说 ‘build’, ‘whitespace’ detailed :输出各子分类的错误统计，比如说 ‘build/class’, ‘whitespace/braces’ 例子： 123456789101112131415qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10&#x2F;system&#x2F;core&#x2F;adb$ cpplint.py --verbose&#x3D;5 --counting&#x3D;toplevel adb.cpp adb.cpp:33: &lt;chrono&gt; is an unapproved C++11 header. [build&#x2F;c++11] [5]adb.cpp:34: &lt;condition_variable&gt; is an unapproved C++11 header. [build&#x2F;c++11] [5]adb.cpp:35: &lt;mutex&gt; is an unapproved C++11 header. [build&#x2F;c++11] [5]adb.cpp:37: &lt;thread&gt; is an unapproved C++11 header. [build&#x2F;c++11] [5]adb.cpp:62: Do not use namespace using-directives. Use using-declarations instead. [build&#x2F;namespaces] [5]adb.cpp:135: Missing space before ( in switch( [whitespace&#x2F;parens] [5]adb.cpp:135: Missing space before &#123; [whitespace&#x2F;braces] [5]adb.cpp:322: Missing space before ( in switch( [whitespace&#x2F;parens] [5]adb.cpp:322: Missing space before &#123; [whitespace&#x2F;braces] [5]adb.cpp:390: Missing space before ( in if( [whitespace&#x2F;parens] [5]Done processing adb.cppCategory &#39;build&#39; errors found: 5Category &#39;whitespace&#39; errors found: 5Total errors found: 10 2.5 --root指定代码的根目录。这个参数会影响头文件保护的宏命名检查结果，比如, 有个头文件的路径为 chrome/browser/ui/browser.h, 则头文件保护的宏命名为： 123未设置--root &#x3D;&gt; CHROME_BROWSER_UI_BROWSER_H_--root&#x3D;chrome &#x3D;&gt; BROWSER_UI_BROWSER_H_--root&#x3D;chrome&#x2F;browser &#x3D;&gt; UI_BROWSER_H_ 2.6 --linelength一行代码的长度限制。默认值为 80 个字符，超 80 个字符后，会提示错误。对于现代的大屏幕来说，我感觉 80 个字符太小了，设置为 120 比较合理。 2.7 --headers设置头文件的扩展名，默认只接受 .h 后缀。例子： 12--headers&#x3D;hpp,hxx--headers&#x3D;hpp 2.8 --extensions设置 cpplint 要检查的文件扩展名，比如： 1--extensions&#x3D;hpp,cpp 2.9 --quiet如果没有错误，则不输出任何信息 2.10 配置文件我们可以在代码目录里面放一个 CPPLINT.cfg 文件，把参数配置都写到里面来，比如： 123456set noparentfilter&#x3D;+filter1,-filter2exclude_files&#x3D;regexlinelength&#x3D;80root&#x3D;subdirheaders&#x3D;x,y set noparent :让 cpplint 不要搜索上级目录查找其他的 .cfg 文件。exclude_files :排除某些文件，文件名可以使用正则表达式。 3. 添加自定义规则cpplint 定义了很多规则，但也不可能满足所有人的需求。下面就来说说怎么扩展规则。我们先看看 cpplint 的基本框架： 从上面的图可以看到几个关键的函数： ProcessFile : 对单个文件的整体处理，包括编码，换行符等 ProcessFileData : 对单个文件的内容进行处理，包括 copyright 声明等 ProcessLine : 对每一行进行处理，大部分规则都在这里处理了 每一项规则都定义成一个函数，以 CheckXXX 方法命名。检查到错误之后调用 Error(filename, linenum, category, confidence, message) 函数来输出错误。 filename : 文件名 linenum : 出错行数 category : 错误类型 confidence : 错误等级， 1 ~ 5 message 错误提示 我们只需要参考现有的规则添加即可。基本上都是对正则表达式的使用而已。也因为 cpplint 只是使用了模式匹配的方法来做检查，并没有进行语法分析，所以有很多规则没法检查。比如，命名规则等。这也是一个非常大的缺陷。不过目前也没有其他更优秀的开源工具了，就将就着用先了。 4. git 提交前自动检查我们的目标是在开发者 git commit 之前自动进行代码风格检查，如果检查有任何错误，则提交失败。所以这个检查需要是在本地进行的。让错误尽早地消灭在源头。幸好，git 提供了 pre-commit hooks 可以满足我们的要求。git pre-commit 默认是关闭的，打开的方式如下：把 .git/hooks/ 目录下的 pre-commit.sample 文件重命名为 pre-commit 即可。然后稍作修改如下： 1234567891011121314151617181920212223242526272829303132333435#!/bin/sh## An example hook script to verify what is about to be committed.# Called by \"git commit\" with no arguments. The hook should# exit with non-zero status after issuing an appropriate message if# it wants to stop the commit.## To enable this hook, rename this file to \"pre-commit\".if git rev-parse --verify HEAD &gt;/dev/null 2&gt;&amp;1then against=HEADelse # Initial commit: diff against an empty tree object against=4b825dc642cb6eb9a060e54bf8d69288fbee4904fi# Redirect output to stderr.exec 1&gt;&amp;2cpplint=cpplint.pysum=0filters='-whitespace/line_length,-build/include' # for cppfor file in $(git diff-index --name-status $against -- | grep -E '\\.[ch](pp)?$' | awk '&#123;print $2&#125;'); do $cpplint --filter=$filters $file sum=$(expr $&#123;sum&#125; + $?)done if [ $&#123;sum&#125; -eq 0 ]; then exit 0else exit 1fi 我们来尝试提交一个有错误的代码： 1234567qiushao@qiushao-pc:~&#x2F;projects&#x2F;clion&#x2F;test$ git commit -m &#39;test&#39; main.cpp:0: No copyright message found. You should have a line: &quot;Copyright [year] &lt;Copyright Owner&gt;&quot; [legal&#x2F;copyright] [5]main.cpp:2: Line contains invalid UTF-8 (or Unicode replacement character). [readability&#x2F;utf8] [5]main.cpp:7: Could not find a newline character at the end of the file. [whitespace&#x2F;ending_newline] [5]Done processing main.cppTotal errors found: 3qiushao@qiushao-pc:~&#x2F;projects&#x2F;clion&#x2F;test$ pre-commit 脚本的返回值为非 0 值，则认为有错误，就会提交失败。上面这个例子把 filters 参数直接写在这个脚本里面了，实际应用时最好写到 CPPLINT.cfg 配置文件里面。","categories":[{"name":"c++","slug":"c","permalink":"http://qiushao.net/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://qiushao.net/tags/c/"},{"name":"静态代码检查","slug":"静态代码检查","permalink":"http://qiushao.net/tags/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5/"}]},{"title":"c++编码规范","slug":"c++/c++编码规范","date":"2020-03-11T06:00:00.000Z","updated":"2020-12-27T01:22:23.748Z","comments":true,"path":"2020/03/11/c++/c++编码规范/","link":"","permalink":"http://qiushao.net/2020/03/11/c++/c++%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/","excerpt":"","text":"本文中的规范大部分是参考 google 发布的 c++ 编码规范，有同学翻译成了中文版本。但这个规范我觉得顺序有点乱，有些地方讨论太详细，有些地方又表达得不清楚。因此整理，挑选了部分规范。 1. 文件编码格式1.1 文件编码：统一使用 utf-8 编码如果文件编码不统一，又有同学使用中文注释的话，就很容易出现乱码的问题。应该所有的文本编辑器都是支持 utf-8 编码的。Linux 的文本编辑器默认使用的都是 utf-8 编码。但 windows 的系统文本编辑器大部分默认编码是 gbk， 所以使用 windows 的同学需要检测一下自己使用的代码编辑器是否已经设置默认编码为 utf-8 了。 1.２ 换行符：统一使用 unix 换行符换行符有三种：unix(LF), macos(CR), windows(CRLF)。其中, CR 表示回车(ASCII 13, \\r)， LF 表示换行(ASCII 10, \\n)。虽然我们在代码编辑器里面看不出来有什么区别。但在一些特殊情况下是会有影响的。比如板子上运行的 shell 脚本，如果换行符是 windows 换行符的话，可能就会执行错误了。为了避免这类问题，我们要求统一使用 unix 换行符。如果现有文件的换行符是 windows 的话，可以通过 dos2unix 这个工具来做转换。代码编辑器也是可以设置默认换行符的。 2. 命名约定最重要的一致性规则是命名管理。 命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义: 类型, 变量, 函数, 常量, 宏, 等等。 甚至, 我们大脑中的模式匹配引擎非常依赖这些命名规则。命名规则具有一定随意性, 但相比按个人喜好命名, 一致性更重要, 所以无论你认为它们是否重要, 规则总归是要遵守的。 2.1 通用命名规则 总述函数命名, 变量命名, 文件命名要有描述性; 少用缩写。 说明尽可能使用描述性的命名, 别心疼空间, 毕竟相比之下让代码易于新读者理解更重要。 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词。 示例好的命名：123int price_count_reader; // 无缩写int num_errors; // \"num\" 是一个常见的写法int num_dns_connections; // 人人都知道 \"DNS\" 是什么 不好的命名：123456int n; // 毫无意义.int nerr; // 含糊不清的缩写.int n_comp_conns; // 含糊不清的缩写.int wgc_connections; // 只有贵团队知道是什么意思.int pc_reader; // \"pc\" 有太多可能的解释了.int cstmr_id; // 删减了若干字母. 例外，一些特定的广为人知的缩写是允许的, 例如用 i 表示迭代变量和用 T 表示模板参数。 2.2 文件命名 总述文件名要全部小写, 单词之间使用下划线 _ 连接。 说明C++ 文件要以 .cpp 结尾, 头文件以 .h 结尾。不要使用已经存在于 /usr/include 下的文件名 (注: 即编译器搜索系统头文件的路径), 如 string.h。通常应尽量让文件名更加明确， http_server_logs.h 就比 logs.h 要好。 定义类时文件名一般成对出现, 如 foo_bar.h 和 foo_bar.cpp, 对应于类 FooBar。 示例可接受的文件命名：1http_server_logs.h 不接受的文件命名：12httpserverlogs.h // 没有单词分隔，看得眼花 http-server-logs.cpp // 单词分隔没有使用下划线 _ 2.3 类型命名 总述类型名称的每个单词首字母均大写, 不包含下划线，比如: MyExcitingClass, MyExcitingEnum。 说明所有类型命名 (类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数) 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线。 示例12345678910111213// 类和结构体class UrlTable &#123;&#125;class UrlTableTester &#123;&#125;struct UrlTableProperties &#123;&#125;// 枚举enum UrlTableErrors &#123;&#125;// typedef 别名typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;// using 别名using PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;; 2.4 变量命名 总述变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接。 类的成员变量以下划线结尾, 但结构体的就不用, 如: a_local_variable, a_struct_data_member, a_class_data_member_。 说明类的成员变量最后面需要添加下划线，结构体的成员变量不需要在最后面添加下划线。因类的成员变量我们要求是都是 private 的，不能直接访问。 加下载线是为了容易区分这个变量是成员变量还是局部变量。结构体的成员变量默认是 public 的，我们使用结构体的一般用法也是要直接访问其成员变量的。另外，结构体一般也没有方法，不需要区分成员变量和局部变量，所以后面不用加下划线。 示例普通变量命名12string table_name; // 好 - 用下划线string tableName; // 差 - 混合大小写 类数据成员不管是静态的还是非静态的, 类数据成员都可以和普通变量一样, 但要接下划线。123456class TableInfo &#123; ... private: string table_name_; // 好 - 后加下划线 static Pool&lt;TableInfo&gt;* pool_; // 好&#125;; 结构体变量不管是静态的还是非静态的, 结构体数据成员都可以和普通变量一样, 不用像类那样接下划线。12345struct UrlTableProperties &#123; string name; int num_entries; static Pool&lt;UrlTableProperties&gt;* pool;&#125;; 2.5 常量命名 总述声明为 constexpr 或 const 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合. 说明所有具有静态存储类型的变量 (例如静态变量或全局变量, 参见 存储类型) 都应当以此方式命名。 示例1const int kDaysInAWeek = 7; 2.6 函数命名 总述常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: MyExcitingFunction(), MyExcitingMethod(), my_exciting_member_variable(), set_my_exciting_member_variable()。 说明一般来说, 函数名的每个单词首字母大写 (即 “驼峰变量名” 或 “帕斯卡变量名”), 没有下划线。 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写。例如, 写作 StartRpc() 而非 StartRPC()。 示例12345AddTableEntry()DeleteUrl()OpenFileOrDie()count() // 取值set_count(int count) // 设值 2.7 枚举命名 总述枚举的命名应当和 常量 一致: kEnumName 。 说明单独的枚举值应该优先采用常量的命名方式。 枚举名 UrlTableErrors (以及 AlternateUrlTableErrors) 是类型, 所以要用大小写混合的方式。 示例12345enum UrlTableErrors &#123; kOK = 0, kErrorOutOfMemory, kErrorMalformedInput,&#125;; 2.8 宏命名 总述一般来说不推荐使用宏定义，应该使用常量或者内联函数替代。如果你一定要用, 像这样命名: MY_MACRO_THAT_SCARES_SMALL_CHILDREN。 说明通常不应该使用宏. 如果不得不用, 其命名全部大写, 使用下划线分隔单词。像 LOGD 这种调试信息，需要输出函数名，位置信息的，就必须得用宏定义了。 示例12#define LOGD(priority, tag, ...) Log::print(priority, tag, __FUNCTION__, __LINE__, __VA_ARGS__)#define PI_ROUNDED 3.0 3. 头文件通常每一个 .cpp 文件都有一个对应的 .h 文件。 也有一些常见例外, 如单元测试代码和只包含 main() 函数的 .cpp 文件。正确使用头文件可令代码在可读性、文件大小和性能上大为改观。下面的规则将引导你规避使用头文件时的各种陷阱。 3.1 Self-contained 头文件 总述看 google 原来的规范，写了一大堆，还是不太明白。个人的理解是：头文件本身依赖的其它头文件，需要全部包含。 说明确保你的 header files 包含了你需要的所有东西， 而不是假设你 #include 进来的某个（些）headers 帮你包含了你需要的东西。 示例不好的做法:12// A.h#include \"B.h\" 12// B.h#include \"C.h\" 12// C.hclass MyClass&#123;&#125;; 有 A.h, B.h, C.h 三个头文件，A.h 中需要使用 C.h 中的 MyClass 类，虽然你 #include B.h 也实现了使用 MyClass 的目的，但是这并不是编程的最佳实践。这种写法会令人感到困惑， MyClass 到底是来自于哪里？最好的做法是在 A.h 中直接 #include C.h。另一种不好的做法：12345// my_class.h class MyClass&#123; MyClass(std::string s);&#125;; 12345// my_class.cpp #include &lt;string&gt;#include \"my_class.h\"MyClass::MyClass(std::string s)&#123;&#125; 这里 my_class.h 就不是 self-contained 的，他需要 #include &lt;string&gt;才能编译。上面的代码虽然编译不会带来问题，前提是 cpp 中你把 #include &lt;string&gt; 放在 #include &quot;my_class.h 的前面。如果将来某一天你不小心把 #include &quot;my_class.h 放在了#include &lt;string&gt; 前面， 就会报 string 未定义错误。cpp可以认为是单纯的使用某个头文件，我们不应该对头文件使用者做出任何假设。因此头文件要做到 self-contained。正确的做法是在 my_class.h 中 #include &lt;string&gt;。 3.2 避免头文件重复包含 总述所有头文件都应该使用 #define 来防止头文件被重复包含, 命名格式当是: &lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_。 说明为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径。 例如, 项目 foo 中的头文件 foo/src/bar/baz.h 可按如下方式保护: 示例1234#ifndef FOO_BAR_BAZ_H_#define FOO_BAR_BAZ_H_...#endif // FOO_BAR_BAZ_H_ 3.3 前置声明 总述尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。 说明所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义。 优点： 前置声明能够节省编译时间，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。 前置声明能够节省不必要的重新编译的时间。 #include 使代码因为头文件中无关的改动而被重新编译多次。 缺点： 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。 前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。 前置声明来自命名空间 std:: 的 symbol 时，其行为未定义。 前置声明了不少来自头文件的 symbol 时，就会比单单一行的 include 冗长。 仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂。 极端情况下，用前置声明代替 includes 甚至都会暗暗地改变代码的含义。 3.4 #include 的路径及顺序 总述使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖，头文件的包含顺序应为: 相关头文件(foobar.cpp 的相关头文件为 foobar.h) –&gt; C 库 –&gt; C++ 库 –&gt; 其他库的 .h –&gt; 本项目内的 .h。在这些类型的头文件之间使用空行来分隔开。 说明项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录)。 例如, google-awesome-project/src/base/logging.h 应该按如下方式包含:1#include \"base/logging.h\" 示例google-awesome-project/src/foo/internal/fooserver.cpp 的头文件包含顺序如下:1234567891011121314#include \"foo/public/fooserver.h\" // 相关头文件放在第一位// c 库头文件#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;// c++ 库头文件#include &lt;hash_map&gt;#include &lt;vector&gt;// 本项目内的其他头文件#include \"base/basictypes.h\"#include \"base/commandlineflags.h\"#include \"foo/public/bar.h\" 4. 作用域4.1 局部变量 总述将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化。 说明C++ 允许在函数的任何位置声明变量。 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好。 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值。 特别是，应使用初始化的方式替代声明再赋值, 比如:1234567int i;i = f(); // 坏——初始化和声明分离int j = g(); // 好——初始化时声明vector&lt;int&gt; v;v.push_back(1); // 用花括号初始化更好v.push_back(2);vector&lt;int&gt; v = &#123;1, 2&#125;; // 好——v 一开始就初始化 属于 if, while 和 for 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言:1while (const char* p = strchr(str, '/')) str = p + 1; 例外有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数， 这会导致效率降低。12345// 低效的实现for (int i = 0; i &lt; 1000000; ++i) &#123; Foo f; // 构造函数和析构函数分别调用 1000000 次! f.DoSomething(i);&#125; 在循环作用域外面声明这类变量要高效的多:1234Foo f; // 构造函数和析构函数只调用 1 次for (int i = 0; i &lt; 1000000; ++i) &#123; f.DoSomething(i);&#125; 4.2 静态和全局变量 总述非基本类型变量的变量，不能作为全局变量和静态变量。静态变量或者全局变量不能通过函数调用来赋初始值 说明基本类型变量是指 char, int, float, double 等。全局变量和静态变量是在静态存储区的，它们的初始化顺序是不确定的， 如果一个 class 类型的变量作为作为静态变量，则它的构造函数、析构函数和初始化的顺序在 C++ 中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug。 4.3 非成员函数、静态成员函数和全局函数 总述使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数。 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关。 说明有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数。 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内。 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用命名空间(namespace) 。 示例对于头文件 myproject/foo_bar.h , 应当使用123456namespace myproject &#123;namespace foo_bar &#123;void Function1();void Function2();&#125; // namespace foo_bar&#125; // namespace myproject 而非1234567namespace myproject &#123;class FooBar &#123; public: static void Function1(); static void Function2();&#125;;&#125; // namespace myproject 定义在同一编译单元的函数, 被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖; 静态成员函数对此尤其敏感。 可以考虑提取到新类中, 或者将函数置于独立库的命名空间内。如果你必须定义非成员函数, 又只是在当前 .cpp 文件中使用它, 应该 static 关键字限定其作用域在当前文件内。如：123static void Foobar() &#123; DoSomething();&#125; 5. 类类是 C++ 中代码的基本单元。 显然, 它们被广泛使用。 本节列举了在写一个类时的主要注意事项。 5.1 构造函数 总述不要在构造函数中调用虚函数, 也不要在构造函数中抛异常。－说明这两个问题需要花点篇幅才能讲明白，这里不讨论，请参考 永远不要在构造函数和析构函数中调用虚函数 和 不要在构造函数和析构函数中抛异常 5.2 存取控制 总述将所有数据成员声明为 private, 除非是 static const 类型成员 (遵循 常量命名规则)。 5.3 声明顺序 总述将相似的声明放在一起, 将 public 部分放在最前。 说明类定义一般应以 public 开始, 后跟 protected, 最后是 private。在各个部分中, 建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括 typedef, using 和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它函数, 数据成员。 注意不要将大段的函数定义内联在类定义中。 通常，只有那些普通的, 或性能关键且短小的函数可以内联在类定义中。 6. 函数6.1 参数顺序 总述函数的参数顺序为: 输入参数在先, 输出参数在后。 说明C/C++ 中的函数参数或者是函数的输入, 或者是函数的输出, 或兼而有之。 输入参数通常是值参或 const 引用, 输出参数或输入/输出参数则一般为非 const 指针。 在排列参数顺序时, 将所有的输入参数置于输出参数之前。 特别要注意, 在加入新参数时不要因为它们是新参数就置于参数列表最后, 而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前。 示例1bool foobar(const int foo_in, const MyClass &amp;bar_in, int *result_out); 6.2 编写简短函数 总述我们倾向于编写简短, 凝练的函数。 说明我们承认长函数有时是合理的, 因此并不硬性限制函数的长度。 如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割。即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题, 甚至导致难以发现的 bug。 使函数尽量简短, 以便于他人阅读和修改代码。在处理代码时, 你可能会发现复杂的长函数。 不要害怕修改现有代码: 如果证实这些代码使用 / 调试起来很困难, 或者你只需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数。 6.3 引用参数 总述所有按引用传递的参数必须加上 const。 定义在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如 int foo(int *pval)。 在 C++ 中, 函数还可以声明为引用参数: int foo(int &amp;val)。 优点定义引用参数可以防止出现 (*pval)++ 这样丑陋的代码。 引用参数对于拷贝构造函数这样的应用也是必需的， 同时也更明确地不接受空指针。 缺点容易引起误解, 因为引用在语法上是值变量却拥有指针的语义。 结论 函数参数列表中, 所有引用参数都必须是 const: 1void Foo(const string &amp;in, string *out); 事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 const 引用, 输出参数为指针。 输入参数可以是 const 指针, 但决不能是非 const 的引用参数, 除非特殊要求, 比如 swap()。有时候, 在输入形参中用 const T* 指针比 const T&amp; 更明智， 比如: 可能会传递空指针。 函数要把指针或对地址的引用赋值给输入形参。总而言之, 大多时候输入形参往往是 const T&amp;。 若用 const T* 则说明输入另有处理。 所以若要使用 const T*, 则应给出相应的理由, 否则会使得读者感到迷惑。 6.4 函数重载 总述若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种。 这一规则也适用于构造函数。 定义你可以编写一个参数类型为 const string&amp; 的函数, 然后用另一个参数类型为 const char* 的函数对其进行重载:12345class MyClass &#123; public: void Analyze(const string &amp;text); void Analyze(const char *text, size_t textlen);&#125;; 优点通过重载参数不同的同名函数, 可以令代码更加直观。 模板化代码需要重载, 这同时也能为使用者带来便利。 缺点如果函数单靠不同的参数类型而重载 (acgtyrant 注：这意味着参数数量不变), 读者就得十分熟悉 C++ 五花八门的匹配规则, 以了解匹配过程具体到底如何。 另外, 如果派生类只重载了某个函数的部分变体, 继承语义就容易令人困惑。 结论如果打算重载一个函数, 可以试试改在函数名里加上参数信息。 例如, 用 AppendString() 和 AppendInt() 等, 而不是一口气重载多个 Append()。 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 std::vector 以便使用者可以用 列表初始化 指定参数。 6.5 缺省参数 总述只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致。 缺省参数与 函数重载 遵循同样的规则。 一般情况下建议使用函数重载, 尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下。 优点有些函数一般情况下使用默认参数, 但有时需要又使用非默认的参数。 缺省参数为这样的情形提供了便利, 使程序员不需要为了极少的例外情况编写大量的函数。和函数重载相比, 缺省参数的语法更简洁明了, 减少了大量的样板代码, 也更好地区别了 “必要参数” 和 “可选参数”。 缺点 缺省参数实际上是函数重载语义的另一种实现方式, 因此所有 不应当使用函数重载的理由 也都适用于缺省参数。 虚函数调用的缺省参数取决于目标对象的静态类型, 此时无法保证给定函数的所有重载声明的都是同样的缺省参数。 缺省参数是在每个调用点都要进行重新求值的, 这会造成生成的代码迅速膨胀。 作为读者, 一般来说也更希望缺省的参数在声明时就已经被固定了, 而不是在每次调用时都可能会有不同的取值。 缺省参数会干扰函数指针, 导致函数签名与调用点的签名不一致. 而函数重载不会导致这样的问题。 结论对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作。如果在每个调用点缺省参数的值都有可能不同, 在这种情况下缺省函数也不允许使用。 例如, 不要写像 void f(int n = counter++); 这样的代码。在其他情况下, 如果缺省参数对可读性的提升远远超过了以上提及的缺点的话, 可以使用缺省参数。 如果仍有疑惑, 就使用函数重载。 7. 注释注释虽然写起来很痛苦, 但对保证代码可读性至关重要。 下面的规则描述了如何注释以及在哪儿注释。 当然也要记住: 注释固然很重要, 但最好的代码应当本身就是文档。 有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字。你写的注释是给代码读者看的, 也就是下一个需要理解你的代码的人。 所以慷慨些吧, 下一个读者可能就是你! 7.1 注释风格 总述统一使用 // 注释风格。 说明除非是更改遗留代码，遗留代码的风格是使用 /* */，那就跟着用 /* */。除非你的英文很好，可以描述清楚，否则还是使用中文注释吧。 7.2 文件注释 总述在每一个文件开头加入版权公告。文件注释描述了该文件的内容. 如果一个文件只声明, 或实现, 或测试了一个对象, 并且这个对象已经在它的声明处进行了详细的注释, 那么就没必要再加上文件注释。 除此之外的其他文件都需要文件注释。 说明 作者信息版权信息里面包含作者信息，可以炫耀你的成就, 也是为了出问题别人可以找你。如果你对原始作者的文件做了重大修改, 请考虑删除原作者信息，增加你自己的信息。 文件内容如果一个 .h 文件声明了多个概念, 则文件注释应当对文件的内容做一个大致的说明, 同时说明各概念之间的联系。 一个一到两行的文件注释就足够了, 对于每个概念的详细文档应当放在各个概念中, 而不是文件注释中。不要在 .h 和 .cc 之间复制注释, 这样的注释偏离了注释的实际意义。具体的文件注释格式，请参考项目中现有的格式。 7.3 类注释 总述每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显。比如：12345678910// Iterates over the contents of a GargantuanTable.// Example:// GargantuanTableIterator* iter = table-&gt;NewIterator();// for (iter-&gt;Seek(\"foo\"); !iter-&gt;done(); iter-&gt;Next()) &#123;// process(iter-&gt;key(), iter-&gt;value());// &#125;// delete iter;class GargantuanTableIterator &#123; ...&#125;; 说明类注释应当为读者理解如何使用与何时使用类提供足够的信息, 同时应当提醒读者在正确使用此类时应当考虑的因素。 如果类有任何同步前提, 请用文档说明。 如果该类的实例可被多线程访问, 要特别注意文档说明多线程环境下相关的规则和常量使用。如果你想用一小段代码演示这个类的基本用法或通常用法, 放在类注释里也非常合适。如果类的声明和定义分开了(例如分别放在了 .h 和 .cc 文件中), 此时, 描述类用法的注释应当和接口定义放在一起。 描述类的操作和实现的注释应当和实现放在一起。 7.4 函数注释 总述函数声明处的注释描述函数功能; 定义处的注释描述函数实现。 说明 函数声明基本上每个函数声明处前都应当加上注释, 描述函数的功能和用途。 只有在函数的功能简单而明显时才能省略这些注释(例如, 简单的取值和设值函数)。函数声明处注释的内容: 函数的输入输出. 对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数. 函数是否分配了必须由调用者释放的空间. 参数是否可以为空指针. 是否存在函数使用上的性能隐患. 如果函数是可重入的, 其同步前提是什么? 举例如下: 123456789101112131415// Returns an iterator for this table. It is the client's// responsibility to delete the iterator when it is done with it,// and it must not use the iterator once the GargantuanTable object// on which the iterator was created has been deleted.//// The iterator is initially positioned at the beginning of the table.//// This method is equivalent to:// Iterator* iter = table-&gt;NewIterator();// iter-&gt;Seek(\"\");// return iter;// If you are going to immediately seek to another place in the// returned iterator, it will be faster to use NewIterator()// and avoid the extra seek.Iterator* GetIterator() const; 但也要避免罗罗嗦嗦, 或者对显而易见的内容进行说明. 下面的注释就没有必要加上 “否则返回 false”, 因为已经暗含其中了: 12// Returns true if the table cannot hold any more entries.bool IsTableFull(); 注释函数重载时, 注释的重点应该是函数中被重载的部分, 而不是简单的重复被重载的函数的注释。 多数情况下, 函数重载不需要额外的文档, 因此也没有必要加上注释。注释构造/析构函数时, 切记读代码的人知道构造/析构函数的功能, 所以 “销毁这一对象” 这样的注释是没有意义的。 你应当注明的是注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么。 如果都是些无关紧要的内容, 直接省掉注释。 析构函数前没有注释是很正常的。2. 函数定义如果函数的实现过程中用到了很巧妙的方式, 那么在函数定义处应当加上解释性的注释。 例如, 你所使用的编程技巧, 实现的大致步骤, 或解释如此实现的理由。 举个例子, 你可以说明为什么函数的前半部分要加锁而后半部分不需要。不要从 .h 文件或其他地方的函数声明处直接复制注释。 简要重述函数功能是可以的, 但注释重点要放在如何实现上。 7.5 变量注释 总述通常变量名本身足以很好说明变量用途。 某些情况下, 也需要额外的注释说明. 说明 类数据成员每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途。 如果有非变量的参数(例如特殊值, 数据成员之间的关系, 生命周期等)不能够用类型与变量名明确表达, 则应当加上注释。 然而, 如果变量类型与变量名已经足以描述一个变量, 那么就不再需要加上注释。特别地, 如果变量可以接受 NULL 或 -1 等警戒值, 须加以说明. 比如:1234private: // Used to bounds-check table accesses. -1 means // that we don't yet know how many entries the table has. int num_total_entries_; 全局变量和数据成员一样, 所有全局变量也要注释说明含义及用途, 以及作为全局变量的原因。 比如:12// The total number of tests cases that we run through in this regression test.const int kNumTestCases = 6; 7.6 实现注释 总述对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释。 说明 代码前注释巧妙或复杂的代码段前要加注释. 比如:1234567// Divide result by two, taking into account that x// contains the carry from the add.for (int i = 0; i &lt; result-&gt;size(); i++) &#123; x = (x &lt;&lt; 8) + (*result)[i]; (*result)[i] = x &gt;&gt; 1; x &amp;= 1;&#125; 行注释比较隐晦的地方要在行尾加入注释, 在行尾空两格进行注释. 比如:1234// If we have enough memory, mmap the data portion too.mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock)) return; // Error already logged. 注意, 这里用了两段注释分别描述这段代码的作用, 和提示函数返回时错误已经被记入日志.如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性:12DoSomething(); // Comment here so the comments line up.DoSomethingElseThatIsLonger(); // Two spaces between the code and the comment. 函数参数注释如果函数参数的意义不明显, 考虑用下面的方式进行弥补: 如果参数是一个字面常量, 并且这一常量在多处函数调用中被使用, 用以推断它们一致, 你应当用一个常量名让这一约定变得更明显, 并且保证这一约定不会被打破. 考虑更改函数的签名, 让某个 bool 类型的参数变为 enum 类型, 这样可以让这个参数的值表达其意义. 如果某个函数有多个配置选项, 你可以考虑定义一个类或结构体以保存所有的选项, 并传入类或结构体的实例. 这样的方法有许多优点, 例如这样的选项可以在调用处用变量名引用, 这样就能清晰地表明其意义. 同时也减少了函数参数的数量, 使得函数调用更易读也易写. 除此之外, 以这样的方式, 如果你使用其他的选项, 就无需对调用点进行更改. 用具名变量代替大段而复杂的嵌套表达式. 万不得已时, 才考虑在调用点用注释阐明参数的意义.比如下面的示例的对比:12// What are these arguments?const DecimalNumber product = CalculateProduct(values, 7, false, nullptr); 和1234ProductOptions options;options.set_precision_decimals(7);options.set_use_cache(ProductOptions::kDontUseCache);const DecimalNumber product = CalculateProduct(values, options, /*completion_callback=*/nullptr); 哪个更清晰一目了然。 不允许的行为不要描述显而易见的现象, 永远不要 用自然语言翻译代码作为注释, 除非即使对深入理解 C++ 的读者来说代码的行为都是不明显的。 要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意。你所提供的注释应当解释代码为什么要这么做和代码的目的, 或者最好是让代码自文档化.比较这样的注释:12345// Find the element in the vector. &lt;-- 差: 这太明显了!auto iter = std::find(v.begin(), v.end(), element);if (iter != v.end()) &#123; Process(element);&#125; 和这样的注释:12345// Process \"element\" unless it was already processed.auto iter = std::find(v.begin(), v.end(), element);if (iter != v.end()) &#123; Process(element);&#125; 自文档化的代码根本就不需要注释. 上面例子中的注释对下面的代码来说就是毫无必要的:123if (!IsAlreadyProcessed(element)) &#123; Process(element);&#125; 7.7 TODO 注释 总述对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 TODO 注释。 说明TODO 注释要使用全大写的字符串 TODO, 在随后的圆括号里写上你的名字, 邮件地址, bug ID, 或其它身份标识和与这一 TODO 相关的 issue。 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 TODO 格式进行查找. 添加 TODO 注释并不意味着你要自己来修正, 因此当你加上带有姓名的 TODO 时, 一般都是写上自己的名字。123// TODO(kl@gmail.com): Use a \"*\" here for concatenation operator.// TODO(Zeke) change this to use relations.// TODO(bug 12345): remove the \"Last visitors\" feature 如果加 TODO 是为了在 “将来某一天做某事”, 可以附上一个非常明确的时间 (“Fix by November 2005”), 或者一个明确的事项 (“Remove this code when all clients can handle XML responses.”)。 7.8 弃用注释 总述通过弃用注释（DEPRECATED comments）以标记某接口点已弃用。 说明您可以写上包含全大写的 DEPRECATED 的注释, 以标记某接口为弃用状态. 注释可以放在接口声明前, 或者同一行。在 DEPRECATED 一词后, 在括号中留下您的名字, 邮箱地址以及其他身份标识。弃用注释应当包涵简短而清晰的指引, 以帮助其他人修复其调用点。 在 C++ 中, 你可以将一个弃用函数改造成一个内联函数, 这一函数将调用新的接口。仅仅标记接口为 DEPRECATED 并不会让大家不约而同地弃用, 您还得亲自主动修正调用点（callsites）, 或是找个帮手。修正好的代码应该不会再涉及弃用接口点了, 着实改用新接口点。 如果您不知从何下手, 可以找标记弃用注释的当事人一起商量。 8. 格式每个人都可能有自己的代码风格和格式, 但如果一个项目中的所有人都遵循同一风格的话, 这个项目就能更顺利地进行。 每个人未必能同意下述的每一处格式规则, 而且其中的不少规则需要一定时间的适应, 但整个项目服从统一的编程风格是很重要的, 只有这样才能让所有人轻松地阅读和理解代码。 8.1 缩进 总述统一使用 4 个空格。 说明不要使用 Tab 键来缩进，不然其他同学看你的代码的时候，缩进可能就是乱七八糟的。虽然大多数文本编辑器上默认 Tab 键的长度是 4 个空格，你自己看起来没问题。但也有部分编辑器默认 tab 是 2 个空格或者 8 个空格的。比如 gerrit 的默认配置好像就是 tab 的显示宽度是 8 个空格。我在 gerrit 上 review 代码的时候，经常看到乱七八糟的缩进。所有的文本编辑器都是可以设置 tab 转换成 4 个空格的。最好设置一下自动转换，这样当你不小心使用了 tab 来缩进的时候，编辑器会帮你改成 4 个空格。 Attention 例外：Makefile 要求命令是以 tab 缩进的 8.2 函数声明与定义 总述返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行。 说明函数看上去像这样:1234ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) &#123; DoSomething(); ...&#125; 如果同一行文本太多, 放不下所有参数:12345ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2, Type par_name3) &#123; DoSomething(); ...&#125; 甚至连第一个参数都放不下:1234567ReturnType LongClassName::ReallyReallyReallyLongFunctionName( Type par_name1, Type par_name2, Type par_name3) &#123; DoSomething(); ...&#125; 注意以下几点: 使用好的参数名，参考命名规范。 只有在参数未被使用或者其用途非常明显时, 才能省略参数名。 如果返回类型和函数名在一行放不下, 分行。 如果返回类型与函数声明或定义分行了, 不要缩进。 左圆括号总是和函数名在同一行。 函数名和左圆括号间永远没有空格。 圆括号与参数间没有空格。 左大括号总在最后一个参数同一行的末尾处, 不另起新行。 右大括号总是单独位于函数最后一行, 或者与左大括号同一行。 右圆括号和左大括号间总是有一个空格。 8.3 函数调用 总述要么一行写完函数调用, 要么在圆括号里对参数分行, 要么参数另起一行且缩进四格。 如果没有其它顾虑的话, 尽可能精简行数, 比如把多个参数适当地放在同一行里. 说明函数调用遵循如下形式：1bool retval = DoSomething(argument1, argument2, argument3); 如果同一行放不下, 可断为多行, 后面每一行都和第一个实参对齐, 左圆括号后和右圆括号前不要留空格：12bool retval = DoSomething(averyveryveryverylongargument1, argument2, argument3); 参数也可以放在次行, 缩进四格：12345678if (...) &#123; ... ... if (...) &#123; DoSomething( argument1, argument2, // 4 空格缩进 argument3, argument4); &#125; 如果一系列参数本身就有一定的结构, 可以酌情地按其结构来决定参数格式：1234// 通过 3x3 矩阵转换 widget.my_widget.Transform(x1, x2, x3, y1, y2, y3, z1, z2, z3); 8.4 条件/循环语句 总述以下规则适用于 if 条件判断，和 for, while 循环。if 后面即使只有一行代码，也一定要加 {}if 与 () 之间有空格， () 与条件之间不需要空格。 说明有些同学觉得 if 条件后面就只有一行代码而已，加不加 {} 无所谓：12if (condition) doSomething(); 但我们强制要加 {}，因为我们经历过了几次不加 {}, 引起的惨痛教训。假如有以上代码，最初的时候只有一行，不加 {}，但是后来人维护的时候，需要在满足这个条件的情况下，做些其他操作，于是他加了一行代码：123if (condition) doSomething(); doOtherThing(); 于是坑就被埋下了。doOtherThing(); 在任何条件下都会执行的。 示例1234if(condition) // 差 - IF 后面没空格.if (condition)&#123; // 差 - &#123; 前面没空格.if(condition)&#123; // 变本加厉地差.if (condition) &#123; // 好 - IF 和 &#123; 都与空格紧邻. 8.5 指针和引用表达式 总述句点或箭头前后不要有空格。 指针/地址操作符 (*, &amp;) 之后不能有空格。 说明下面是指针和引用表达式的正确使用范例:1234x = *p;p = &amp;x;x = r.y;x = r-&gt;y; 在声明指针变量或参数时, 星号统一与变量名紧挨:1234567891011121314// 好, 星号统变量名紧挨char *c;const string &amp;str;// 差, 星号与类型紧挨char* c;const string&amp; str;// 差, */&amp; 两边都有空格char * c; const string &amp; str; // 不允许 - 在多重声明中不能使用 &amp; 或 *int x, *y; 8.6 预处理指令 总述预处理指令不要缩进, 从行首开始。 说明即使预处理指令位于缩进代码块中, 指令也应从行首开始。 示例1234567// 好 - 指令从行首开始 if (lopsided_score) &#123;#if DISASTER_PENDING DropEverything();#endif BackToNormal(); &#125; 1234567// 差 - 指令缩进 if (lopsided_score) &#123; #if DISASTER_PENDING DropEverything(); #endif BackToNormal(); &#125; 8.7 类格式 总述访问控制块的声明依次序是 public, protected, private。public 这些关键字不需要缩进。 说明类声明 (下面的代码中缺少注释, 参考 类注释) 的基本格式如下:123456789101112131415161718192021222324class MyClass : public OtherClass &#123;public: // 不需要空格缩进 // 先构造/析构函数 MyClass(); // 四空格缩进 explicit MyClass(int var); ~MyClass() &#123;&#125; // 对外提供的方法 void SomeFunction(); void SomeFunctionThatDoesNothing() &#123; &#125; // set/get 方法 void set_some_var(int var) &#123; some_var_ = var; &#125; int some_var() const &#123; return some_var_; &#125;private: // 内部处理，不对外提供的方法 bool SomeInternalFunction(); // 成员变量，所有成员变量都要是 private 的 int some_var_; int some_other_var_;&#125;; 8.8 命名空间格式化 总述命名空间内容不缩进. 说明命名空间 不要增加额外的缩进层次, 例如:1234567namespace &#123;void foo() &#123; // 正确. 命名空间内没有额外的缩进. ...&#125;&#125; // namespace 不要在命名空间内缩进:12345678namespace &#123; // 错, 缩进多余了. void foo() &#123; ... &#125;&#125; // namespace 声明嵌套命名空间时, 每个命名空间都独立成行.12namespace foo &#123;namespace bar &#123; 8.9 水平留白 总述水平留白的使用根据在代码中的位置决定. 永远不要在行尾添加没意义的留白. 说明 通用123456789101112void f(bool b) &#123; // 左大括号前总是有空格. ...int i = 0; // 分号前不加空格.// 继承与初始化列表中的冒号前后恒有空格.class Foo : public Bar &#123; public: // 对于单行函数的实现, 在大括号内加上空格 // 然后是函数实现 Foo(int b) : Bar(), baz_(b) &#123;&#125; // 大括号里面是空的话, 不加空格. void Reset() &#123; baz_ = 0; &#125; // 用括号把大括号与实现分开. ... 添加冗余的留白会给其他人编辑时造成额外负担. 因此, 行尾不要留空格. 如果确定一行代码已经修改完毕, 将多余的空格去掉; 或者在专门清理空格时去掉（尤其是在没有其他人在处理这件事的时候). (注: 现在大部分代码编辑器稍加设置后, 都支持自动删除行首/行尾空格, 如果不支持, 考虑换一款编辑器或 IDE) 循环和条件语句1234567891011121314if (b) &#123; // if 条件语句和循环语句关键字后均有空格.&#125; else &#123; // else 前后有空格.&#125;while (test) &#123;&#125; // 圆括号内部不紧邻空格.switch (i) &#123;for (int i = 0; i &lt; 5; ++i) &#123;switch ( i ) &#123; // 循环和条件语句的圆括号里可以与空格紧邻.if ( test ) &#123; // 圆括号, 但这很少见. 总之要一致.for ( int i = 0; i &lt; 5; ++i ) &#123;for ( ; i &lt; 5 ; ++i) &#123; // 循环里内 ; 后恒有空格, ; 前可以加个空格.switch (i) &#123; case 1: // switch case 的冒号前无空格. ... case 2: break; // 如果冒号有代码, 加个空格. 操作符1234567891011121314// 赋值运算符前后总是有空格.x = 0;// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.// 圆括号内部没有紧邻空格.v = w * x + y / z;v = w*x + y/z;v = w * (x + z);// 在参数和一元操作符之间不加空格.x = -5;++x;if (x &amp;&amp; !y) ... 模板和转换123456// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.vector&lt;string&gt; x;y = static_cast&lt;char*&gt;(x);// 在类型与指针操作符之间留空格也可以, 但要保持一致.vector&lt;char *&gt; x; 8.10垂直留白 总述垂直留白越少越好. 说明这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. 尤其是: 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行.基本原则是: 同一屏可以显示的代码越多, 越容易理解程序的控制流. 当然, 过于密集的代码块和过于疏松的代码块同样难看, 有时候在不同的逻辑块中添加空行分隔，会显示更有条理。 9. c++ 特性c++ 11 之后增加了一些新的语法特性，使用这些语法特性我觉得可以改善代码可读性，安全性。 9.1 nullptrnullptr 是为了补充并替代 NULL 的，由于之前老版本的 NULL 定义一般为 0， 但有时候又被编译器定义为((void*)0)。这样就会出现混乱，特别是进行函数重载的时候，就会让编译器搞不清楚 NULL 的具体类型，因此，引入 nullptr 可以更好的区分 0 和 空指针， 因此，在新版中，尽量使用 nullptr 代表空指针进行初始化。 9.2 initializer_list在C++11之前，我们无法以花括号的形式初始一个 vector： 1std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;; 但这在C++11却是可行的，因为其引入了初始化列表 std::initializer_list。initializer_list 为参数个数不固定的函数提供了一个简单的解决方案： 12345678910111213141516#include &lt;iostream&gt;#include &lt;initializer_list&gt;using namespace std;void error_msg(int ErrCode, initializer_list&lt;string&gt; il)&#123; cout &lt;&lt; \"errno(\" &lt;&lt; ErrCode &lt;&lt; \"): \"; for (auto beg = il.begin(); beg != il.end(); ++beg) cout &lt;&lt; *beg &lt;&lt; \" \" ; cout &lt;&lt; endl;&#125;int main()&#123; error_msg(2, &#123;\"ENOENT\", \"No such file or directory!\"&#125;);&#125; 9.3 auto 类型在C++中最烦的就算是各种类型声明的编写，太多字母了，而且有时候也会忘记，由于他们的类型定义太多太乱了！因此 C++11 中使用 auto 对数据类型进行自动推导。新版中，已经弃用了之前有类似功能的 register 关键字，变得更加强大，比如下面例子： 123for(vector&lt;int&gt;::const_iterator itr = vec.cbegin(); itr != vec.cend(); ++itr)// 可以改写为for(auto itr = vec.cbegin(); itr != vec.cend(); ++itr) 9.4 范围for语句相信学过 python 的同学都很清楚，在 python 中经常使用的 for 语句是 for….in….，十分的方便，而在 C 中 for 循环是又丑又长，C++ 标准为了简化代码量，提供了新的范围 for 语句：for(auto c : str); 12345678// C风格for(std::vector&lt;int&gt;::iterator i = arr.begin(); i != arr.end(); ++i) &#123; std::cout &lt;&lt; *i &lt;&lt; std::endl;&#125;// C++11for(auto &amp;i : arr)&#123; cout &lt;&lt; i &lt;&lt; \" \"; // 加上引用可以为左值，用于修改&#125; 智能指针我们知道c++的内存管理是让很多人头疼的事，当我们写一个new语句时，一般就会立即把delete语句直接也写了，但是我们不能避免程序还未执行到delete时就跳转了或者在函数中没有执行到最后的delete语句就返回了，如果我们不在每一个可能跳转或者返回的语句前释放资源，就会造成内存泄露。使用智能指针可以很大程度上的避免这个问题。智能指针本质上是使用了引用计数的方法来自动释放内存的。具体细节这里就不讨论了，感兴趣的同学请自行查找相关资料。","categories":[{"name":"c++","slug":"c","permalink":"http://qiushao.net/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://qiushao.net/tags/c/"}]},{"title":"Android系统开发进阶-init 进程启动流程","slug":"Android系统开发进阶/init启动流程","date":"2020-03-10T14:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/03/10/Android系统开发进阶/init启动流程/","link":"","permalink":"http://qiushao.net/2020/03/10/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/init%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/","excerpt":"","text":"上一篇文章我们详细解析了 init.rc 文件的语法规范。同学们可以对照着去看看 Android/system/core/rootdir/init.rc 这个文件。我们会发现里面有很多 event trigger, 比如 on boot, on fs 等，然后系统的各种核心服务，基本上都是在这些 event trigger 里面启动的。以前一直搞不明白这些 event trigger 的先后执行顺序。这次把源码看了一遍过，终于搞明白了。本文不会从源码的角度去分析 init 的启动流程，只是把自己看过源码之后的理解, 整理成一张思维导图，相信同学们看过这张图之后应该能大概明白 init 都干了哪些活。这些活的先后顺序，这就足够了。init 启动流程概要: 从上图来看， init 的初始化可以分为三个阶段： FirstStageMain这个阶段的工作主要是挂载一些虚拟文件系统，还有挂载两个系统最核心的分区 system, vendor。这两步都是为了后续的工作做准备。比如设置 selinux 需要从 system, vendor 分区中读取 sepolicy。 SecondStageMain 需要从 system, vendor 分区中读取 property 信息，需要启动系统核心服务。 SetupSelinux设置 Selinux 安全机制。 SecondStageMain启动 property 服务（从这里可以知道 property 服务是运行在 init 进程里面的），然后加载各分区下的 .rc 文件。然后把各种事件加入到事件队列。最后进入事件循环，按队列方式（先进先出）处理事件队列中的事件。 从上面的流程来看，其实 init 把大部分的初始化工作都放到 init.rc 中， 这样可以更灵活的适配各种平台的定制需求。 需要提一下的是各阶段的启动方式，第一阶段的启动是由 kernel 启动的，这里不讨论，第二，三阶段的启动比较有意思，都是通过 exec 来启动的： 123const char* path = \"/system/bin/init\";const char* args[] = &#123;path, \"selinux_setup\", nullptr&#125;;execv(path, const_cast&lt;char**&gt;(args)); 123const char* path = \"/system/bin/init\";const char* args[] = &#123;path, \"second_stage\", nullptr&#125;;execv(path, const_cast&lt;char**&gt;(args)); 我也不知道为什么要通过 execv 启动一个新进程替换旧进程的方式来切换各阶段呢？这样相比直接一个函数调用来说有什么好处呢？知道的同学麻烦指导一下哈。 单独把 secondStage 部分的流程拎出来扩展: 这张图主要是想表现一下各事件触发器的触发时序，各服务的启动时序。整理如下：0. 初始化 biner 驱动相关 early-init 事件启动了 ueventd, apexd-bootstrap 服务 init 事件 1234567891011on init # 创建各种系统运行所需的目录，更改各种目录的权限 mkdir &#x2F;mnt&#x2F;media_rw 0750 root media_rw mkdir &#x2F;mnt&#x2F;user 0755 root root # Start logd before any other services run to ensure we capture all of their logs. start logd # Start essential services. start servicemanager start hwservicemanager start vndservicemanager late-init 事件把一堆的事件按顺序加入事件队列 1234567891011on late-init trigger early-fs trigger fs trigger post-fs trigger late-fs trigger post-fs-data trigger load_persist_props_action trigger zygote-start trigger firmware_mounts_complete trigger early-boot trigger boot early-fs 事件启动 vold 服务，负责外接磁盘的挂载。 fs 事件Action 定义在 vendor/etc/init/init.ranchu.rc 中， 只有一个动作，根据 fstab 挂载所有分区。 1mount_all &#x2F;vendor&#x2F;etc&#x2F;fstab.ranchu 在挂完文件系统后，代码中会把 nonencrypted 事件加入到事件队列。 post-fs 事件重新挂载 / 根分区为只读分区，创建各种系统目录。 late-fs 事件启动 early_hal 类型的所有服务，当然被 disable 的除外。 post-fs-data 事件启动 bootchart, apexd， 等待 apexd 服务完成 load_persist_props_action 事件加载 /data 分区下的 persist property zygote-start 事件Android 世界的鼻祖在这里启动了 firmware_mounts_complete 事件这个不知道干啥用的了 early-boot 事件目前没有使用 boot 事件启动 hal, core 类型的所有服务，当然被 disable 的除外。 nonencrypted 事件启动 main 类型的所有服务，当然被 disable 的除外。 以上，我们可以知道各种服务的启动顺序了：最先启动的是 logd, 和三个 servicemanager 服务。接下来按这个顺序来启动各种类型的服务：early_hal –&gt; hal –&gt; core –&gt; main","categories":[{"name":"Android系统开发进阶","slug":"Android系统开发进阶","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发进阶-init.rc 详解","slug":"Android系统开发进阶/init.rc介绍","date":"2020-03-01T04:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/03/01/Android系统开发进阶/init.rc介绍/","link":"","permalink":"http://qiushao.net/2020/03/01/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/init.rc%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"init 是 Android 系统启动的第一个用户空间进程，它的主要工作是对系统进行初始化，然后启动系统的各种核心服务。我们知道，Android 可能运行在各种不同的产品上，不同的产品所需要启动的服务也是有很大的差异的。为了满足不同产品的需求，init 进程把一部分初始化工作交给 init.rc 配置文件来管理。init.rc 以 Android Init Language 作为语法，下文我们简称 Android Init Language 为 init 语言。配置文件的主入口文件是 /init.rc，这个文件会通过 import 引入其他的配置文件。本文中，我们统称这些文件为 init.rc。下面我们就来详细介绍一下 init.rc 的语法细节。 我们先来看一下 init.rc 的语法结构图： init.rc 由一个个 section 组成， 每一个 section 定义了一个 Action, 或者一个 Service。Action 由 trigger 和 一组 command 组成。trigger 表示触发这个 Action 的条件， command 表示这个 Action 被触发后所执行的一系列动作。Service 描述了一个服务的名字，执行路径，启动参数等信息。还可以通过 option 来约定服务的一些行为，权限等。比如是否只启动一次，服务进程的 uid, gid等。 init.rc 的所有语法介绍都可以在 Android/system/core/init/README.md 这个文件里面查找到，下面的大部分内容都是参考这个文档，顺便整理，扩展一下。 Android Init LanguageThe Android Init Language 主要由５种语法类型组成:Actions, Commands, Services, Options, 和 Imports. 每一行是一个语句，单词之间用空格分开，如果单词中有空格可以用反斜杠 \\ 转义，也可以用双引号 &quot;&quot; 来引用文本避免和空格冲突，如果一行语句太长可以用反斜杠 \\ 换行， 如果一行以 # 开头(当然 # 前面可以是空白符: space, tab)，则表示这行是注释。 在 init.rc 中我们可以使用系统属性 property，其使用方法跟 shell 语法中的变量引用是一样的，比如：import /init.recovery.${ro.hardware}.rc。其中 ro.hardware 就是一个系统属性，我们通过 ${property} 这种形式来引用。 每个 Action 和 Service 都定义了一个 Section, 所有的 Commands 和 Options 从属于紧挨着的 Actions 或 Services， 定义在第一个 Section 前的 Commands 和 Options 将被忽略掉。Service 的名称都唯一的， 如果定义了两个名称一样的 Service，那第二个 Service 将被忽略掉并打印错误日志。 Init .rc FilesAndroid Init Language 是用后缀为 .rc 的纯文本编写的, 而且是由多个分布在不同目录下的 .rc 文件组成, 如下所述:/init.rc 是最主要的一个 .rc 文件， 它由 init 进程在开始执行的时候加载，主要负责系统初始化。 系统通过 init 进程的第一阶段 mount 机制会挂载 /system, /vendor 分区。这里简要说明一下， init 进程的启动是分为三个阶段的: FirstStageMain 主是要挂载文件系统，包括虚拟文件系统(/dev, /sys, /proc等), 和部分实际的文件系统(/sytem, /vendor, /odm等)。还有一部分文件系统是在第三阶段通过 mount_all fstab 来挂载的，比如说 /data。 SetupSelinux 设置 Selinux 环境 SecondStageMain 这个阶段才会加载 init.rc 文件 init 进程在加载完 /init.rc 文件之后，会接着加载 /{system,vendor,odm,product}/etc/init/ 这些目录下的所有 .rc 文件：/system/etc/init/ 用于系统本身，比如 SurfaceFlinger, MediaService, and logcatd/vendor/etc/init/ 用于SoC(系统级核心厂商，如高通), 为他们提供一些核心功能和服务/odm/etc/init/ 用于设备制造商（odm定制厂商，如华为、小米），为他们的传感器或外围设备提供一些核心功能和服务/product/etc/init/ 用于产品机型的配置 一些旧的设备是没有第一个阶段的挂载文件系统机制的，那些设备的 .rc 加载流程是这样的： /init.rc 会 import soc 厂商提供的 .rc 文件： /init.${ro.hardware}.rc /init.${ro.hardware}.rc 里面会有 mount_all 指令。当执行到 mount_all 指令时，init 进程会挂载所有文件系统，然后加载 /{system,vendor,odm}/etc/init/ 这些目录下的所有 .rc 文件。 system, vendor, odm, 或者 product 分区下的所有 binaries services 都有一个对应的 .rc 文件。这些 .rc 文件都放在各分区的 $partion/etc/init 目录下。Android.mk 中提供了一个 LOCAL_INIT_RC 配置， Android.bp 中也提供了一个 init_rc 配置。这两个配置可以为服务指定它的 .rc 文件。这里需要说明的是 service bin 编译到哪个分区，它对应的 .rc 文件也会编译到对应分区的 etc/init 目录。比如 system/core 目录下的 logd 模块，它的 Android.bp 如下： 123456789101112cc_binary &#123; name: &quot;logd&quot;, init_rc: [&quot;logd.rc&quot;], srcs: [&quot;main.cpp&quot;], static_libs: [ &quot;liblog&quot;, &quot;liblogd&quot;, ], ...&#125; init_rc: [&quot;logd.rc&quot;] 配置指定了 logd 服务对应的 .rc 文件为当前目录下的 logd.rc。logd 会被编译到 /system/bin 目录，logd.rc 文件则会被编译到 /system/etc/init 目录。将 .rc 根据不同服务分拆到不同文件中，要比之前放在单个 init.rc 文件好。 这种方案确保 init 进程读取的 service 和 action 信息能和同目录下的 Services 二进制文件更加符合, 不再像以前单个 init.rc 那样。另外，这样还可以解决多个 services 加入到系统时发生的冲突，因为他们都拆分到了不同的文件中。 在 mount_all 命令中有 “early” 和 “late” 两个可选项，当 early 设置的时候，init 进程将跳过被 latemount 标记的挂载操作，并触发 fs encryption state 事件，当 late 被设置的时候，init 进程只会执行 latemount 标记的挂载操作，但是会跳过导入的 .rc 文件的执行. 默认情况下，不设置任何选项， init 进程将执行所有挂载操作 ActionsActions 由一行行的命令序列组成。 trigger 用来决定什么时候触发这些命令, 当一个事件满足 trigger 的触发条件时， 这个 action 就会被加入到处理队列中（除非队列中已经存在）。队列中的 action 按顺序取出执行， action 中的命令按顺序执行。 这些命令主要用来执行一些操作（设备创建/销毁，属性设置，进程重启等）。Actions的格式如下： 1234on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]* &lt;command&gt; &lt;command&gt; &lt;command&gt; Actions 被加进队列的顺序是由包含这个 Action 的文件被 init 解析的顺序（import 的顺序）决定的。同一个 .rc 文件的多个 Action 命令也是出现在前面的优先入队列。比如一个 .rc 文件有以下 Actions: 123456789on boot setprop a 1 setprop b on boot &amp;&amp; property:foobar&#x3D;true setprop c 1 setprop d 2on boot setprop e 1 setprop f 2 当 boot 事件被触发，且 property foobar 的值为 true 时，这些命令被执行的顺序是： 123456setprop a 1setprop b 2setprop c 1setprop d 2setprop e 1setprop f 2 ServicesServices 是 init 进程启动的程序, 我们可以配置 Services 在挂掉时是否自动重启。Services 的格式如下： 1234service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]* &lt;option&gt; &lt;option&gt; ... name : 服务名，也是服务运行的进程名 pathname : 服务的可执行程序入口 argument : 服务运行的参数 OptionsOptions是Services的参数配置. 它们影响Service如何运行及运行时机。下面对所有的 Options 进行说明： capabilities [ &lt;capability&gt;\\* ]执行服务的时候设置 capability。关于 capability 的概念，简单来说，就是一种权限控制机制，相对于 uid, gid 来说更细粒度的权限控制。详细的权限列表请参考 capabilities。参数中的 capability 不需要 CAP_ 前缀， 比如 NET_ADMIN，或者 SETPCAP。如果没有设置任何权限，则所有的权限都会被移除掉，即使这个服务是以 root 用户运行的也一样。 class &lt;name&gt; [ &lt;name&gt;\\* ]为服务指定 class 名字。 同一个 class 名字的服务会被一起启动或退出, 默认值是 default, 第二个 name 可以不设置， 用于service组。开机动画和关机动画服务都应该包含 animation 这个 class。因为开机动画在系统启动过程中启动得非常早，然后在关机的时候又需要运行到最后一个关机阶段。在运行动画的过程中不能保证 /data 分区是已经挂载可用的了。开机动画和关机动画服务可以操作 /data 分区下的文件，但不能一直打开 /data 分区下的文件。而且当 /data 分区还没挂载时，也不能影响服务的运行。 console [&lt;console&gt;]这个选项表明服务需要一个控制台。 第二个参数 console 的意思是可以设置你想要的控制台类型，默认控制台是 /dev/console, /dev 这个前缀通常是被省略的， 比如你要设置控制台 /dev/tty0, 那么只需要设置为console tty0 即可。 critical表示服务是严格模式。 如果这个服务在4分钟内或者启动完成前退出超过4次，那么设备将重启进入 bootloader 模式。 disabled这个服务不会随着 class 一起启动。只能通过服务名来显式启动。比如 foobar 服务的 class 是 core, 且是 disabled 的，当执行 class_start core 时，foobar 服务是不会被启动的。 foobar 服务只能通过 start foobar 这种方法来启动。 enter_namespace &lt;type&gt; &lt;path&gt;Enters the namespace of type type located at path. Only network namespaces are supported with type set to “net”. Note that only one namespace of a given type may be entered. file &lt;path&gt; &lt;type&gt;根据文件路径 path 来打开文件，然后把文件描述符 fd 传递给服务进程。type 表示打工文件的方式，只有三种取值 r, w, rw。对于 native 程序来说，可以通过 libcutils 库提供的 android_get_control_file() 函数来获取传递过来的文件描述符。举个例子， logd.rc 部分内容如下 1234567service logd &#x2F;system&#x2F;bin&#x2F;logd socket logd stream 0666 logd logd socket logdr seqpacket 0666 logd logd socket logdw dgram+passcred 0222 logd logd file &#x2F;proc&#x2F;kmsg r file &#x2F;dev&#x2F;kmsg w user logd 其中通过 file /proc/kmsg r 以只读方式打开了设备文件 /proc/kmsg, 然后在代码中这么获取打开的文件, 见 sytem/core/logd/main.cpp main 函数： 12345static const char dev_kmsg[] = \"/dev/kmsg\";fdDmesg = android_get_control_file(dev_kmsg);if (fdDmesg &lt; 0) &#123; fdDmesg = TEMP_FAILURE_RETRY(open(dev_kmsg, O_WRONLY | O_CLOEXEC));&#125; 这里可能有点奇怪，为什么要通过 file 这个选项来打开文件，而不直接在代码里面通过 open() 函数来打开呢？我觉得主要是权限问题，还是以 logd 为例子。/dev/kmsg 的权限是： 12pure:&#x2F; # ls -l &#x2F;dev&#x2F;kmsg crw------- 1 root root 1, 11 2020-02-27 21:49 &#x2F;dev&#x2F;kmsg 只有 root 用户可读写。而 logd 服务是以 user logd 选项来启动的，自然没有权限用 open() 函数来打开 /dev/kmsg 这个设备文件。file 选项则可以通过 init 进程把文件打开，然后把文件描述符传递给子进程， 从而解决了权限的问题。 group &lt;groupname&gt; [ &lt;groupname&gt;\\* ]在启动 Service 前将 Service 的用户组改为第一个 groupname, 第一个 groupname 是必须有的， 第二个 groupname 可以不设置，用于追加组（通过setgroups）。目前默认的用户组是 root 组。但我觉得为了安全起见，默认用户组应该是 nobody 才对。 interface &lt;interface name&gt; &lt;instance name&gt;将这个服务进程与这个进程提供的一系列 services 关联起来。interface name 参数必须是全限定名。这个配置的作用是允许 hwservicemanager 惰性启动服务进程。（我的理解是，这个服务不会开机自动启动，需要等其他进程显式的调用这个服务时，才会启动）。如果有多个 interfaces, 则多次使用 interface 这个选项来列举出来。比如 /vendor/etc/init/android.hardware.drm@1.0-service.rc ： 123456service vendor.drm-hal-1-0 &#x2F;vendor&#x2F;bin&#x2F;hw&#x2F;android.hardware.drm@1.0-service interface android.hardware.drm@1.0::ICryptoFactory default interface android.hardware.drm@1.0::IDrmFactory default class hal user media group mediadrm drmrpc ioprio &lt;class&gt; &lt;priority&gt;通过 SYS_ioprio_set 系统调用来设置此服务的 IO 优先级和 IO 优先级类别。 class 优先级类别必须是 rt(real-time)，be(best-effort) 或 idle 之一。 priority 优先级必须为 0 到 7 之间的整数。 keycodes &lt;keycode&gt; [ &lt;keycode&gt;\\* ]设置触发此服务的按键，可以是组合按键。如果这个组合键被按下了，这个服务就会启动。一般用来启动 bugreport 服务： 123456service bugreport &#x2F;system&#x2F;bin&#x2F;dumpstate -d -p -B -z \\ -o &#x2F;data&#x2F;user_de&#x2F;0&#x2F;com.android.shell&#x2F;files&#x2F;bugreports&#x2F;bugreport class main disabled oneshot keycodes 114 115 116 我们也可以用一个 property 来替代键值列表。这种情况下只需要提供一个 property 即可。这个 property 的值为：以逗号分隔的键值列表；或者 “none” 表示不禁用组合键启动服务。比如： keycodes ${some.property.name:-none}。 some.property.name 的值为 “123,124,125”。因为 keycodes 在 init 进程中是很早被处理的。所以只有在 PRODUCT_DEFAULT_PROPERTY_OVERRIDES 定义的 property 才可以使用。目前我还没见过这种用法，也不明白为什么要有这种用法。 memcg.limit_in_bytes &lt;value&gt; and memcg.limit_percent &lt;value&gt;这个主要是用来设置服务的内存使用限制。当服务的内存使用超出了限制，则会触发 oom kill。具体原理请搜索 cgroup memory 相关的知识。limit_in_bytes 指按字节来限制； limit_percent 指按物理内存的百分比来限制。value 的值必须要大于 0。这个配置需要 /dev/memcg 节点被挂载才会生效。 memcg.limit_property &lt;value&gt;通过 property 来设置 memory.limit_in_bytes 的值。这里 value 的值为一个 property 名。当设置了 memcg.limit_property 时，memcg.limit_in_bytes 和 memcg.limit_percent 的值将会被覆盖。 memcg.soft_limit_in_bytes &lt;value&gt;soft_limit_in_bytes: 内存软限制。如果超过了 memcg.limit_in_bytes 所定义的限制，那么进程会被 oom killer 干掉或者被暂停，这相当于硬限制，因为进程无法申请超过自身 cgroup 限制的内存，但是软限制确是可以突破的。我们假定一个场景，如果你的实体机上有四个 cgroup，实体机的内存总量是64G，那么一般情况我们会考虑给每个 cgroup 限制到16G内存。但是现实情况并不会这么理想，首先实体机上其他进程和内核会占用部分内存，这将导致实际上每个 cgroup 都不会真的有16G内存可用，如果四个 cgroup 都尽量占用内存的话，他们可能谁都不会到达内存的上限触发超限的行为，这可能将导致进程都抢不到内存而被饿死。 类似的情况还可能发上在内存超卖的环境中，比如，我们仍然只有64G内存，但是确开了8个cgroup，每个都限制了16G内存。这样每个 cgroup 分配的内存之和达到了128G，但是实际内存量只有64G。这种情况是出于绝大多数应用可能不会占用满所有的内存来考虑的，这样就可以把本来属于它的那份内存”借用”给其它 cgroup。如果全局内存已经耗尽了，但是某些 cgroup 还没达到他的内存使用上限，而它们此时如果要申请内存的话，此时该从哪里回收内存？如果我们配置了 memcg.soft_limit_in_bytes，那么内核将去回收那些内存超过了这个软限制的 cgroup 的内存，尽量缩减它们的内存占用达到软限制的量以下 ，以便让没有达到软限制的 cgroup 有内存可以用。在没有这样的内存竞争以及没有达到硬限制的情况下，软限制是不会生效的。还有，软限制的起作用时间可能会比较长，毕竟内核要平衡多个cgroup的内存使用。 根据软限制的这些特点，我们应该明白如果想要软限制生效，应该把它的值设置成小于硬限制。 memcg.swappiness &lt;value&gt;swappiness 的值的大小对如何使用 swap 分区是有着很大的联系的。swappiness=0 的时候表示最大限度使用物理内存，然后才是 swap 空间，swappiness＝100 的时候表示积极的使用 swap 分区，并且把内存上的数据及时的搬运到 swap 空间里面。不过在 Android 系统上好像没有见过 swap 分区。 namespace &lt;pid|mnt&gt;当 fork 这个 service 时，设置 pid 或 mnt namespace。目前也没发现哪个服务有用到这个 option。 oneshot当服务退出的时候，不自动重启。适用于那些开机只运行一次的服务。 onrestart在服务重启的时候执行一个命令。这个命令并不是 shell 命令哦，具体可以执行的命令有哪些，文章后面会介绍。 oom_score_adjust &lt;value&gt;设置服务的 /proc/$pid/oom_score_adj 的值为 value,在 -1000 ～ 1000之间。值越大，越可能被 oom Killer 杀掉。 override指定此服务要覆盖之前定义的同名服务。前面我们有说过，服务名是唯一的，重复定义的话，后面的定义会被忽略。但我们可以通过 override 来使用后面定义的服务来覆盖前面的。一般的使用场景是使用 /odm 分区定义的服务来覆盖 /vendor 分区定义的同名服务。init 进程将以最后解析到的服务定义为准，因此我们要特别关注 init.rc 文件被解析的顺序。 priority &lt;priority&gt;设置服务的 cpu 调试优先级。取值范围为 -20 ~ 19。默认值是 0。实质上是通过 setpriority() 函数调用来设置优先级。 restart_period &lt;seconds&gt;如果一个非 oneshot 的服务退出了，它将会在设置的 period 时间周期内重新启动。为了限制服务的崩溃频率，默认周期是 5 秒。对于一些本应该周期运行的服务来说，我们可以增加这个周期。比如说，可以设置成 3600 来指定服务每小时运行一次。或者指定为 86400 来指定服务每天运行一次。 rlimit &lt;resource&gt; &lt;cur&gt; &lt;max&gt;rlimit 是 resource limit 的意思。每个进程在运行时系统不会无限制的允许单个进程不断的消耗资源，因此都会设置资源限制。Linux 系统中使用 resource limit 来表示，每个进程都可以设置不同的资源限制，rlimit 的设置是会传递给子进程的，也就是以这个 service 为根节点的进程树上的所有进程都会受这个设置的影响。关于 rlimit 的介绍请自行搜索。 seclabel &lt;seclabel&gt;在启动 Service 前设置指定的 seclabel，默认使用init的安全策略。 主要用于在 rootfs 上启动的 service，比如 ueventd, adbd。 在系统分区上运行的 service 有自己的 SELinux安全策略。 setenv &lt;name&gt; &lt;value&gt;设置进程的环境变量。 shutdown &lt;shutdown_behavior&gt;设置关机时这个服务的行为。如果没有设置，这个服务在关机时将会被 SIGTERM 和 SIGKILL 杀掉。如果指定了 shutdown critical，则这个服务在关机过程中不会被杀掉，直接关机超时。如果这个服务指定了 shutdown critical，且在开始关机时这个服务没有在运行，则这个服务将会被启动。servicemanager， vold 等服务设置了这个 option。 sigstop在服务被启动的时候马上发送 SIGSTOP 信号给这个服务。这个选项一般是用来调试的。文章后面介绍 debugging 的时候会说明怎么使用这个选项。 socket &lt;name&gt; &lt;type&gt; &lt;perm&gt; [ &lt;user&gt; [ &lt;group&gt; [ &lt;seclabel&gt; ] ] ]创建一个 unix domain socket, 路径为 /dev/socket/name , 并将fd返回给Service。 type 只能是 “dgram”, “stream” or “seqpacket”。user 和 group 默认值是 0。 seclabel 是这个 socket 的 SELinux security context, 它的默认值是 service 的security context或者基于其可执行文件的security context。在代码中，可以通过 libcutils 库提供的 android_get_control_socket 函数来获取这个 socket 的 fd。logd 服务就使用到了这个 option。 1234567service logd &#x2F;system&#x2F;bin&#x2F;logd socket logd stream 0666 logd logd socket logdr seqpacket 0666 logd logd socket logdw dgram+passcred 0222 logd logd file &#x2F;proc&#x2F;kmsg r file &#x2F;dev&#x2F;kmsg w user logd timeout_period &lt;seconds&gt;设置一个超时周期，当到达超时周期，服务将会被 kill 掉。如果服务被设置了 oneshot 自然不会被重启。但其他非 oneshot 服务则会被自动重启。这个 option 通常和上面提到过的 restart_period 结合使用，定义一个周期性的服务。 updatable Mark that the service can be overridden (via the ‘override’ option) later inthe boot sequence by APEXes. When a service with updatable option is startedbefore APEXes are all activated, the execution is delayed until the activationis finished. A service that is not marked as updatable cannot be overridden byAPEXes. user &lt;username&gt;在启动 Service 前修改进程的所属用户, 默认启动时 user 为 root (安全起见，或许默认应该是 nobody)。在Android M版本，如果一个进程想拥有 Linux capabilities（相当于Android中的权限吧），也只能通过设置这个值。 以前，一个程序要想有 Linux capabilities，必须先以root身份运行，然后再降级到所需的uid。现在已经有一套新的机制取而代之，它通过 fs_config 允许厂商赋予特殊二进制文件 Linux capabilities。 这套机制的说明文档在 https://source.android.google.cn/devices/tech/config/filesystem.html。 当使用这套新的机制时，程序可以通过 user 参数选择自己所需的 uid, 而不需要以 root 权限运行. 在 Android O 版本，程序可以通过 capabilities option 直接申请所需的能力，参见上面的 capabilities 说明。 writepid &lt;file&gt; [ &lt;file&gt;\\* ]当 Service 调用 for 时将子进程的 pid 写入到指定文件. 用于 cgroup/cpuset 的使用，当 /dev/cpuset/ 下面没有文件但 ro.cpuset.default 的值却不为空时, 将pid的值写入到 /dev/cpuset/${ro.cpuset.default}/tasks 文件中。 TriggersTriggers 的作用是用来触发 Actions 的执行。Triggers 可以分为 event triggers 和 property triggers。event triggers 由 trigger 命令 或者在 init 中使用 QueueEventTrigger 函数触发。它的格式是个简单的字符串，比如’boot’ 或 ‘late-init’。property triggers 是在 property 被设置或发生改变时触发。 格式是on property:property_name=property_value。一个 Action 可以有多个 property triggers, 但是只能有一个 event trigger。比如：on boot &amp;&amp; property:a=b 定义的 Action 只有在 boot 这个 event trigger 被触发，且 property a = b 时，这个 Action 才会执行。on property:a=b &amp;&amp; property:c=d 定义的 Action 在以下三种情况都会执行: 系统启动时 property a=b 且 property c=d。 系统运行过程中， 当 property a 的值变成 b, 且这个时候 property c 的值已经是 d. 系统运行过程中， 当 property c 的值变成 d, 且这个时候 property a 的值已经是 b. CommandsCommand 是 Action 被触发后，可以执行的一系列命令。这些命令并不是 shell 命令。下面介绍一下都有哪些命令可以使用。 bootchart [start|stop]启动或者停止 bootchart。这两个 command 出现在 init.rc 这个文件中，但只有在 /data/bootchart/enabled 这个文件存在的时候 bootchart 才会执行。否则 bootchart start/stop 不做任何操作。 chmod &lt;octal-mode&gt; &lt;path&gt;修改文件的权限，这个跟我们使用 shell 命令的格式是一样的。权限以 8 进制数指定。 chown &lt;owner&gt; &lt;group&gt; &lt;path&gt;修改文件属主。格式跟 shell 命令有点差别。 shell 命令的格式是 chown [user][:[group]] class_start &lt;serviceclass&gt;启动所有 class 是 &lt;serviceclass&gt; 的 service(如果服务未启动的话，才启动)。 class_start_post_data &lt;serviceclass&gt;与 class_start 相似， 但是只考虑那些在 /data 分区被挂载之后才启动的服务， 或者系统运行过程中 class_reset_post_data 命令被调用。这个命令只适用于开启了 FDE(Full-Disk Encryption 全盘加密) 的设备。 class_stop &lt;serviceclass&gt;停止所有 class 为 &lt;serviceclass&gt; 且正在运行的服务。并且把这些服务设置为 disable。也就是不能再通过 class_star 来启动，只能通过 start service_name 这种指定服务名的方式显式启动。 class_reset &lt;serviceclass&gt;停止所有 class 为 &lt;serviceclass&gt; 且正在运行的服务。但不会 disable 这些服务。这些服务还可以通过 class_start 来启动。 class_reset_post_data &lt;serviceclass&gt;与 class_reset 相似，但是只考虑那些在 /data 分区被挂载之后才启动的服务。这个命令只适用于开启了 FDE(Full-Disk Encryption 全盘加密) 的设备。 class_restart &lt;serviceclass&gt;重启所有 class 是 &lt;serviceclass&gt; 的服务。 copy &lt;src&gt; &lt;dst&gt;复制一个文件，与 write 命令相似，但适用于二进制文件或者大文件拷贝。对于 src 文件来说，不允许从符号链接文件复制，也不可以从 world-writable(other用户可写) 或者 group-writable(组用户可写) 的文件复制。 linux 的文件权限位可以分为三组：文件属主权限，文件属主所在的用户组的权限，其他用户的权限。对于 dst 文件来说，如果文件不存在的话，创建的文件默认权限是 0600。如果文件已经存在的普通文件，则这个文件会被清空。 domainname &lt;name&gt;设置 domain name. enable &lt;servicename&gt;把一个 disable 的服务设置成 enable 状态。 exec [ &lt;seclabel&gt; [ &lt;user&gt; [ &lt;group&gt;\\* ] ] ] -- &lt;command&gt; [ &lt;argument&gt;\\* ]新建一个子进程并运行一个带指定参数的命令。 命令跟在 -- 后面，以便前面可以指定 seclabel（安全策略），user(所有者)，group(用户组)等选项。直到这个命令运行完才可以运行其他命令。seclabel 可以设置为 - 表示用默认值， argument 可以使用属性扩展形式 ${property}。直到子进程新建完毕，init进程才继续执行. exec_background [ &lt;seclabel&gt; [ &lt;user&gt; [ &lt;group&gt;\\* ] ] ] -- &lt;command&gt; [ &lt;argument&gt;\\* ]与 exec 相似，差别在于 exec_background 不会阻塞 init 进程的运行。 exec_start &lt;service&gt;与 exec 相似，但 exec_start 使用的是定义好的 service。 export &lt;name&gt; &lt;value&gt;设置全局环境变量。在执行这个命令之后再启动的所有进程都会继承这个环境变量。 hostname &lt;name&gt;设置 hostname ifup &lt;interface&gt;启动指定的网络接口 insmod [-f] &lt;path&gt; [&lt;options&gt;]安装 path 指定的内核驱动模块(ko 文件)。-f 参数：即使当前运行的内核版本与模块编译的内核版本不一致，也强制安装这个驱动模块。 load_system_props这个命令已经被 deprecated 了。 load_persist_props当 /data 分区被 decrypted 之后， 加载 /data 分区下的 persistent 属性。在 init.rc 这个文件里面有执行这个命令。 loglevel &lt;level&gt;设置 kernel 打印等级。level 可以使用属性扩展形式 ${property}。 mark_post_data/data 分区被挂载后，马上用这个命令来标志。用来实现 class_reset_post_data 和 class_start_post_data 命令。 mkdir &lt;path&gt; [mode] [owner] [group]创建目录。如果没有提供[mode] [owner] [group]的话，则默认权限是 755，默认用户，和组是 root。如果目录已经存在了，则目录的权限和用户属主会被更新。 mount_all &lt;fstab&gt; [ &lt;path&gt; ]\\* [--&lt;option&gt;]调用 fs_mgr_mount_all 来挂载 fstab 指定的分区。挂载完之后，马上 import 这些分区 etc/init/ 目录下面的 .rc 文件。 mount &lt;type&gt; &lt;device&gt; &lt;dir&gt; [ &lt;flag&gt;\\* ] [&lt;options&gt;]挂载 type 类型的 device 设备到 dir 目录。flag 包括 “ro”, “rw”, “remount”, “noatime” 等。options 包括 “barrier=1”, “noauto_da_alloc”, “discard” 等，使用逗号分隔，比如：barrier=1,noauto_da_alloc restart &lt;service&gt;重启服务。如果服务正在运行，先 stop 再 start，如果服务没有运行则只需要 start。 rm &lt;path&gt;删除指定文件，实际上是调用 unlink 函数。可以使用 exec -- rm path 来替代。需要确保 path 所在的分区已经被挂载。 rmdir &lt;path&gt;删除指定目录，实际上是调用 rmdir 函数。 readahead &lt;file|dir&gt; [--fully]调用 readahead 函数把文件或目录下的文件加载到页面缓冲区。–fully option 表示加载整个文件。Linux的文件预读 readahead，指Linux系统内核将指定文件的某区域预读进页缓存起来，便于接下来对该区域进行读取时，不会因缺页（page fault）而阻塞。因为从内存读取比从磁盘读取要快很多。预读可以有效的减少磁盘的寻道次数和应用程序的I/O等待时间，是改进磁盘读I/O性能的重要优化手段之一。 setprop &lt;name&gt; &lt;value&gt;设置 property。value 可以使用 property 扩展形式 ${property}。 setrlimit &lt;resource&gt; &lt;cur&gt; &lt;max&gt;设置资源限制。同上面 service option 里面提到的 rlimit。cur 和 max 可以设置为 ‘unlimited’ 或者 ‘-1’ 表示不做限制。 start &lt;service&gt;如果指定服务没有在运行的话，则启动这个服务。 stop &lt;service&gt;如果指定的服务正在运行的话，则停止这个服务。 symlink &lt;target&gt; &lt;path&gt;创建软链接。 sysclktz &lt;mins_west_of_gmt&gt;设置系统时区。 trigger &lt;event&gt;触发一个 event 事件。 umount &lt;path&gt;umount 分区 wait &lt;path&gt; [ &lt;timeout&gt; ]查看指定路径是否存在。 如果发现则返回, 可以设置超时时间，默认值是5秒。这个命令会阻塞 init 进程的运行。之前优化开机速度时，就发现有人在 init.rc 里面用了 wait 命令，导致系统启动慢了几秒。 wait_for_prop &lt;name&gt; &lt;value&gt;等待 property 的值变成 &lt;value&gt;。这个也会阻塞 init 进程的运行。 write &lt;path&gt; &lt;content&gt;打开 path 路径指定的文件，然后调用 write 函数往文件中写一个字符串 content。如果文件路径不存在，则会新创建一个文件。如果文件已经存在了，则文件会被清空。content 的值可以使用 property 扩展形式 ${property}。 Importsimport 我觉得可以按 c 语言的 include 头文件来理解即可。主要是为了把配置文件按模块进行拆分，方便维护。 import &lt;path&gt;导入 init rc 文件， 以括展当前文件的配置。如果 path 是个目录， 则导入这个目录下所有.rc文件，但是不会递归查找。 Propertiesinit 进程通过以下 property 可以提供一个状态信息: init.svc.&lt;name&gt;一个服务的运行状态：”stopped”, “stopping”, “running”, “restarting” Boot timinginit 进程记录了一些启动过程中的耗时信息在 property 里面。 ro.boottime.init从 boot 开始到 init 进程初始化第一阶段开始的时间，单位为 ns。 ro.boottime.init.selinux从初始化第一阶段开始到初始化 selinux 的耗时。其实也就是 init 进程第一阶段初始化的耗时了。 ro.boottime.init.cold_boot_waitueventd 的冷启动耗时。 ro.boottime.&lt;service-name&gt;从 boot 到 service 第一次启动的时间。 后面的部分内容跟 init.rc 文件的语法没有什么关系了，就不再展开了。后续再单独在其他文章中讨论以下部分的内容。看完以上的介绍，相信同学们应该对 init.rc 文件有了大概的了解了。编写自己的服务，或者 Action 应该不成问题了。 BootchartingThis version of init contains code to perform “bootcharting”: generating logfiles that can be later processed by the tools provided by http://www.bootchart.org/. On the emulator, use the -bootchart timeout option to boot with bootchartingactivated for timeout seconds. On a device: adb shell &apos;touch /data/bootchart/enabled&apos;Don’t forget to delete this file when you’re done collecting data! The log files are written to /data/bootchart/. A script is provided toretrieve them and create a bootchart.tgz file that can be used with thebootchart command-line utility: sudo apt-get install pybootchartgui # grab-bootchart.sh uses $ANDROID_SERIAL. $ANDROID_BUILD_TOP/system/core/init/grab-bootchart.shOne thing to watch for is that the bootchart will show init as if it startedrunning at 0s. You’ll have to look at dmesg to work out when the kernelactually started init. Comparing two bootchartsA handy script named compare-bootcharts.py can be used to compare thestart/end time of selected processes. The aforementioned grab-bootchart.shwill leave a bootchart tarball named bootchart.tgz at /tmp/android-bootchart.If two such barballs are preserved on the host machine under differentdirectories, the script can list the timestamps differences. For example: Usage: system/core/init/compare-bootcharts.py base-bootchart-dir exp-bootchart-dir process: baseline experiment (delta) - Unit is ms (a jiffy is 10 ms on the system) ------------------------------------ /init: 50 40 (-10) /system/bin/surfaceflinger: 4320 4470 (+150) /system/bin/bootanimation: 6980 6990 (+10) zygote64: 10410 10640 (+230) zygote: 10410 10640 (+230) system_server: 15350 15150 (-200) bootanimation ends at: 33790 31230 (-2560)SystraceSystrace (http://developer.android.com/tools/help/systrace.html) can beused for obtaining performance analysis reports during boottime on userdebug or eng builds. Here is an example of trace events of “wm” and “am” categories: $ANDROID_BUILD_TOP/external/chromium-trace/systrace.py \\ wm am --bootThis command will cause the device to reboot. After the device is rebooted andthe boot sequence has finished, the trace report is obtained from the deviceand written as trace.html on the host by hitting Ctrl+C. Limitation: recording trace events is started after persistent properties are loaded, sothe trace events that are emitted before that are not recorded. Severalservices such as vold, surfaceflinger, and servicemanager are affected by thislimitation since they are started before persistent properties are loaded.Zygote initialization and the processes that are forked from the zygote are notaffected. Debugging initLaunching init services without init is not recommended as init sets up a significant amount ofenvironment (user, groups, security label, capabilities, etc) that is hard to replicate manually. If it is required to debug a service from its very start, the sigstop service option is added.This option will send SIGSTOP to a service immediately before calling exec. This gives a windowwhere developers can attach a debugger, strace, etc before continuing the service with SIGCONT. This flag can also be dynamically controled via the ctl.sigstop_on and ctl.sigstop_off properties. Below is an example of dynamically debugging logd via the above: stop logd setprop ctl.sigstop_on logd start logd ps -e | grep logd &gt; logd 4343 1 18156 1684 do_signal_stop 538280 T init gdbclient.py -p 4343 b main c c c &gt; Breakpoint 1, main (argc=1, argv=0x7ff8c9a488) at system/core/logd/main.cpp:427Below is an example of doing the same but with strace stop logd setprop ctl.sigstop_on logd start logd ps -e | grep logd &gt; logd 4343 1 18156 1684 do_signal_stop 538280 T init strace -p 4343 (From a different shell) kill -SIGCONT 4343 &gt; strace runsHost Init Script VerificationInit scripts are checked for correctness during build time. Specifically the below is checked. 1) Well formatted action, service and import sections, e.g. no actions without a preceding ‘on’line, and no extraneous lines after an ‘import’ statement.2) All commands map to a valid keyword and the argument count is within the correct range.3) All service options are valid. This is stricter than how commands are checked as the serviceoptions’ arguments are fully parsed, e.g. UIDs and GIDs must resolve. There are other parts of init scripts that are only parsed at runtime and therefore not checkedduring build time, among them are the below. 1) The validity of the arguments of commands, e.g. no checking if file paths actually exist, ifSELinux would permit the operation, or if the UIDs and GIDs resolve.2) No checking if a service exists or has a valid SELinux domain defined3) No checking if a service has not been previously defined in a different init script. Early Init Boot SequenceThe early init boot sequence is broken up into three stages: first stage init, SELinux setup, andsecond stage init. First stage init is responsible for setting up the bare minimum requirements to load the rest of thesystem. Specifically this includes mounting /dev, /proc, mounting ‘early mount’ partitions (whichneeds to include all partitions that contain system code, for example system and vendor), and movingthe system.img mount to / for devices with a ramdisk. Note that in Android Q, system.img always contains TARGET_ROOT_OUT and always is mounted at / by thetime first stage init finishes. Android Q will also require dynamic partitions and therefore willrequire using a ramdisk to boot Android. The recovery ramdisk can be used to boot to Android insteadof a dedicated ramdisk as well. First stage init has three variations depending on the device configuration: 1) For system-as-root devices, first stage init is part of /system/bin/init and a symlink at /initpoints to /system/bin/init for backwards compatibility. These devices do not need to do anything tomount system.img, since it is by definition already mounted as the rootfs by the kernel. 2) For devices with a ramdisk, first stage init is a static executable located at /init. Thesedevices mount system.img as /system then perform a switch root operation to move the mount at/system to /. The contents of the ramdisk are freed after mounting has completed. 3) For devices that use recovery as a ramdisk, first stage init it contained within the shared initlocated at /init within the recovery ramdisk. These devices first switch root to/first_stage_ramdisk to remove the recovery components from the environment, then proceed the sameas 2). Note that the decision to boot normally into Android instead of bootinginto recovery mode is made if androidboot.force_normal_boot=1 is present in thekernel commandline. Once first stage init finishes it execs /system/bin/init with the “selinux_setup” argument. Thisphase is where SELinux is optionally compiled and loaded onto the system. selinux.cpp contains moreinformation on the specifics of this process. Lastly once that phase finishes, it execs /system/bin/init again with the “second_stage”argument. At this point the main phase of init runs and continues the boot process via the init.rcscripts.","categories":[{"name":"Android系统开发进阶","slug":"Android系统开发进阶","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"ubuntu 18.04 升级 Linux 5.4 内核","slug":"Linux/ubuntu-upgrade-kernel","date":"2020-03-01T03:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/03/01/Linux/ubuntu-upgrade-kernel/","link":"","permalink":"http://qiushao.net/2020/03/01/Linux/ubuntu-upgrade-kernel/","excerpt":"","text":"目前在用的系统是 ubuntu 18.04.4 版本，内核版本如下： 123qiushao@qiushao-pc:~$ uname -aLinux qiushao-pc 5.3.0-28-generic #30~18.04.1-Ubuntu SMP Fri Jan 17 06:14:09 UTC 2020 x86_64 x86_64 x86_64 GNU&#x2F;Linuxqiushao@qiushao-pc:~$ cpu 是: amd 3900x, 主板是: 华硕X570， cpu,主板是比较新的， 5.3 版本的内核还有很多问题，比如说耳机口不能用，蓝牙连接不稳定等。一开始我还以为是硬件本身的问题，还以为是我自己装机时接错线了。前两天看 manjaro 出了新的版本，内核是 5.4 的。就安装到另一个分区尝试了一下，发现耳机，蓝牙的问题都没有。猜测是新版本的内核对主板的支持更完善了。于是想试试给 ubuntu 升级下内核到 5.4 版本，看看能不能解决耳机，蓝牙的问题。 1. 下载官方编译好的内核升级内核有两种方法：1. 自己下载源码编译；2. 使用官方编译好的内核。一般来说最好都是使用官方编译好的。官方编译的内核可以从这里下载：https://kernel.ubuntu.com/~kernel-ppa/mainline/因为我的目的是升级到 5.4 版本的内核，找到 5.4 的最新版本是 5.4.23：https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.4.23/页面前面有一段描述： Build for amd64 succeeded (see BUILD.LOG.amd64): linux-headers-5.4.23-050423_5.4.23-050423.202002281329_all.deb linux-headers-5.4.23-050423-generic_5.4.23-050423.202002281329_amd64.deb linux-headers-5.4.23-050423-lowlatency_5.4.23-050423.202002281329_amd64.deb linux-image-unsigned-5.4.23-050423-generic_5.4.23-050423.202002281329_amd64.deb linux-image-unsigned-5.4.23-050423-lowlatency_5.4.23-050423.202002281329_amd64.deb linux-modules-5.4.23-050423-generic_5.4.23-050423.202002281329_amd64.deb linux-modules-5.4.23-050423-lowlatency_5.4.23-050423.202002281329_amd64.deb generic 用于支持通用硬件系统， lowlatency 用于低延迟硬件系统，amd64用于64位系统。我们的电脑一般用 generic 就行了， 不用下载 lowlatency 相关的安装包。只需要下载下面几个安装包即可： 1234wget https:&#x2F;&#x2F;kernel.ubuntu.com&#x2F;~kernel-ppa&#x2F;mainline&#x2F;v5.4.23&#x2F;linux-headers-5.4.23-050423_5.4.23-050423.202002281329_all.debwget https:&#x2F;&#x2F;kernel.ubuntu.com&#x2F;~kernel-ppa&#x2F;mainline&#x2F;v5.4.23&#x2F;linux-headers-5.4.23-050423-generic_5.4.23-050423.202002281329_amd64.debwget https:&#x2F;&#x2F;kernel.ubuntu.com&#x2F;~kernel-ppa&#x2F;mainline&#x2F;v5.4.23&#x2F;linux-image-unsigned-5.4.23-050423-generic_5.4.23-050423.202002281329_amd64.debwget https:&#x2F;&#x2F;kernel.ubuntu.com&#x2F;~kernel-ppa&#x2F;mainline&#x2F;v5.4.23&#x2F;linux-modules-5.4.23-050423-generic_5.4.23-050423.202002281329_amd64.deb 2. 安装内核进入下载内核的目录，然后执行以下命令即可： 123456789101112131415161718192021222324252627282930313233343536373839qiushao@qiushao-pc:~&#x2F;Downloads&#x2F;kernel$ lslinux-headers-5.4.23-050423_5.4.23-050423.202002281329_all.deb linux-image-unsigned-5.4.23-050423-generic_5.4.23-050423.202002281329_amd64.deblinux-headers-5.4.23-050423-generic_5.4.23-050423.202002281329_amd64.deb linux-modules-5.4.23-050423-generic_5.4.23-050423.202002281329_amd64.debqiushao@qiushao-pc:~&#x2F;Downloads&#x2F;kernel$qiushao@qiushao-pc:~&#x2F;Downloads&#x2F;kernel$ sudo dpkg -i *.deb(Reading database ... 244666 files and directories currently installed.)Preparing to unpack linux-headers-5.4.23-050423_5.4.23-050423.202002281329_all.deb ...Unpacking linux-headers-5.4.23-050423 (5.4.23-050423.202002281329) over (5.4.23-050423.202002281329) ...Preparing to unpack linux-headers-5.4.23-050423-generic_5.4.23-050423.202002281329_amd64.deb ...Unpacking linux-headers-5.4.23-050423-generic (5.4.23-050423.202002281329) over (5.4.23-050423.202002281329) ...Preparing to unpack linux-image-unsigned-5.4.23-050423-generic_5.4.23-050423.202002281329_amd64.deb ...Unpacking linux-image-unsigned-5.4.23-050423-generic (5.4.23-050423.202002281329) over (5.4.23-050423.202002281329) ...Preparing to unpack linux-modules-5.4.23-050423-generic_5.4.23-050423.202002281329_amd64.deb ...Unpacking linux-modules-5.4.23-050423-generic (5.4.23-050423.202002281329) over (5.4.23-050423.202002281329) ...Setting up linux-headers-5.4.23-050423 (5.4.23-050423.202002281329) ...Setting up linux-headers-5.4.23-050423-generic (5.4.23-050423.202002281329) ...Setting up linux-modules-5.4.23-050423-generic (5.4.23-050423.202002281329) ...Setting up linux-image-unsigned-5.4.23-050423-generic (5.4.23-050423.202002281329) ...Processing triggers for linux-image-unsigned-5.4.23-050423-generic (5.4.23-050423.202002281329) ...&#x2F;etc&#x2F;kernel&#x2F;postinst.d&#x2F;initramfs-tools:update-initramfs: Generating &#x2F;boot&#x2F;initrd.img-5.4.23-050423-genericW: Possible missing firmware &#x2F;lib&#x2F;firmware&#x2F;rtl_nic&#x2F;rtl8125a-3.fw for module r8169I: The initramfs will attempt to resume from &#x2F;dev&#x2F;nvme0n1p4I: (UUID&#x3D;5d386fca-a168-4aae-9b13-425eae5932ea)I: Set the RESUME variable to override this.&#x2F;etc&#x2F;kernel&#x2F;postinst.d&#x2F;zz-update-grub:Sourcing file &#96;&#x2F;etc&#x2F;default&#x2F;grub&#39;Generating grub configuration file ...Found linux image: &#x2F;boot&#x2F;vmlinuz-5.4.23-050423-genericFound initrd image: &#x2F;boot&#x2F;initrd.img-5.4.23-050423-genericFound linux image: &#x2F;boot&#x2F;vmlinuz-5.3.0-28-genericFound initrd image: &#x2F;boot&#x2F;initrd.img-5.3.0-28-genericFound linux image: &#x2F;boot&#x2F;vmlinuz-5.0.0-37-genericFound initrd image: &#x2F;boot&#x2F;initrd.img-5.0.0-37-genericFound Manjaro Linux (19.0.1) on &#x2F;dev&#x2F;nvme0n1p3Adding boot menu entry for EFI firmware configurationdoneqiushao@qiushao-pc:~&#x2F;Downloads&#x2F;kernel$ qiushao@qiushao-pc:~&#x2F;Downloads&#x2F;kernel$ reboot 3. 重启验证重启后，查看一下内核的版本信息： 123qiushao@qiushao-pc:~$ uname -aLinux qiushao-pc 5.3.0-28-generic #30~18.04.1-Ubuntu SMP Fri Jan 17 06:14:09 UTC 2020 x86_64 x86_64 x86_64 GNU&#x2F;Linuxqiushao@qiushao-pc:~$ 奇怪了啊，怎么还是 5.3 版本的内核呢！再看一下之前的安装日志也没有任何错误提示啊。又重复安装一遍，发现还是一样的问题。到 /boot 目录下看看： 12345qiushao@qiushao-pc:&#x2F;boot$ lsconfig-5.0.0-37-generic efi initrd.img-5.3.0-28-generic memtest86+.elf System.map-5.3.0-28-generic vmlinuz-5.3.0-28-genericconfig-5.3.0-28-generic grub initrd.img-5.4.23-050423-generic memtest86+_multiboot.bin System.map-5.4.23-050423-generic vmlinuz-5.4.23-050423-genericconfig-5.4.23-050423-generic initrd.img-5.0.0-37-generic memtest86+.bin System.map-5.0.0-37-generic vmlinuz-5.0.0-37-genericqiushao@qiushao-pc:&#x2F;boot$ 看起来已经有 5.4 的内核在里面了。为什么没有用新的内核来启动呢？不信邪了，再 reboot 一次看看。在 reboot 到 grub 选择要启动的系统时突然猜测到了原因。因为前两天才再另外一个分区上安装的 manjaro, 所以目前系统上的 grub 启动菜单其实是 manjaro 所在的分区的。而系统的启动内核是由 grub 指定的。而我没有在 manjaro 系统里面更新 grub， 所以还是使用旧版本的内核。系统的分区信息如下: partition 1 : uefi 分区， 指向的启动分区为 partition 3 partition 2 : ubuntu / 分区, 里面有 /boot/grub/grub.cfg 启动菜单配置文件 partition 3 : manjaro / 分区, 里面也有 /boot/grub/grub.cfg 启动菜单配置文件 partition 4 : ubuntu &amp; manjaro /home 分区 因为 manjaro 是后安装的，所以启动菜单使用的是 parition 3 中的 grub.cfg 配置文件， 但我们在安装内核的时候，自动更新的是 partition 2 中的 grub.cfg。我们看看 partition 2 里面的 grub.cfg 里面的配置内容： 12345678910111213141516menuentry &#39;Ubuntu&#39; --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option &#39;gnulinux-simple-697f7639-b38d-4e6c-a994-d36c5542dae5&#39; &#123; recordfail load_video gfxmode $linux_gfx_mode insmod gzio if [ x$grub_platform &#x3D; xxen ]; then insmod xzio; insmod lzopio; fi insmod part_gpt insmod ext2 if [ x$feature_platform_search_hint &#x3D; xy ]; then search --no-floppy --fs-uuid --set&#x3D;root 697f7639-b38d-4e6c-a994-d36c5542dae5 else search --no-floppy --fs-uuid --set&#x3D;root 697f7639-b38d-4e6c-a994-d36c5542dae5 fi linux &#x2F;boot&#x2F;vmlinuz-5.4.23-050423-generic root&#x3D;UUID&#x3D;697f7639-b38d-4e6c-a994-d36c5542dae5 ro quiet splash $vt_handoff initrd &#x2F;boot&#x2F;initrd.img-5.4.23-050423-generic&#125; 我们看到最后两行配置是内核相关的，其中指定了使用哪个版本的内核来启动系统。关于 grub 的知识，是 Linux 通用的，任何发行版都是一样的。 解决方案很简单，先进入 manjaro 系统先，然后执行这个命令更新 grub 启动信息： 1sudo update-grub 更新完之后， reboot 重启进入 ubuntu 再看看内核的版本： 123qiushao@qiushao-pc:~$ uname -aLinux qiushao-pc 5.4.23-050423-generic #202002281329 SMP Fri Feb 28 18:33:31 UTC 2020 x86_64 x86_64 x86_64 GNU&#x2F;Linuxqiushao@qiushao-pc:~$ 嗯，升级到了 5.4。再看看耳机接口，嗯，有声音了，看来的确是新版本的内核对新硬件的支持会好一点。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/tags/Linux/"},{"name":"Kernel","slug":"Kernel","permalink":"http://qiushao.net/tags/Kernel/"}]},{"title":"Android系统开发进阶-BootAnimation添加视频播放功能","slug":"Android系统开发进阶/BootAnimation添加视频播放功能","date":"2020-02-27T04:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/02/27/Android系统开发进阶/BootAnimation添加视频播放功能/","link":"","permalink":"http://qiushao.net/2020/02/27/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/BootAnimation%E6%B7%BB%E5%8A%A0%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%8A%9F%E8%83%BD/","excerpt":"","text":"对于手机用户来说，开机动画接触得比较少，因为用户可能一年也不会关开机一次。但对于 TV 设备跟盒子的用户来说，开机动画就是家常便饭了，每天都要开关机。反正都是要等待开机，看 Android logo 是看，看广告也是看，所以各厂商也就利用这个来顺便赚个广告费。Android 系统默认的开机动画只支持图片形式的动画，是不支持 mp4 等视频类型的，但我们的广告又是以视频为主的。所以我们需要给 BootAnimation 增加播放视频的功能，下面我们就来演示一下怎么实现这个功能。 1. BootAnimation 类添加 video 播放函数BootAnimation.h 12345bool android();bool movie();//qiushao patch add startbool video();//qiushao patch add end BootAnimation.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//qiushao patch add start#include &lt;media/mediaplayer.h&gt;#include &lt;media/IMediaHTTPService.h&gt;//qiushao patch add start//qiushao patch add startconst char *videoPath = \"/system/media/bootvideo.mp4\";bool BootAnimation::video() &#123; const float MAX_FPS = 60.0f; const float CHECK_DELAY = ns2us(s2ns(1) / MAX_FPS); eglMakeCurrent(mDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT); eglDestroySurface(mDisplay, mSurface); sp&lt;MediaPlayer&gt; mp = new MediaPlayer(); mp-&gt;reset(); mp-&gt;setDataSource(NULL, videoPath, NULL); mp-&gt;setVideoSurfaceTexture(mFlingerSurface-&gt;getIGraphicBufferProducer()); mp-&gt;prepare(); mp-&gt;start(); //设置音量 mp-&gt;setVolume(1.0, 1.0); //等Launcher启动完成 while(true) &#123; if(exitPending()) &#123; break; &#125; usleep(CHECK_DELAY); checkExit(); &#125; //等开机视频播放完成 while (mp-&gt;isPlaying()) &#123; usleep(200000); &#125; ALOGD(\"bootvideo play finish\"); mp-&gt;stop(); mp-&gt;disconnect(); mp.clear(); return true;&#125;//qiushao patch add endbool BootAnimation::threadLoop()&#123; //qiushao patch modify start if (access(videoPath, R_OK) == 0) &#123; video(); &#125; else if (!mZipFileName.isEmpty()) &#123; movie(); &#125; else &#123; android(); &#125; //qiushao patch modify end ...&#125; 2. 添加依赖因为我们要用到 MediaPlayer, 所以需要添加 libmedia 依赖：Android.bp 123456789101112131415161718192021222324cc_library_shared &#123; name: \"libbootanimation\", defaults: [\"bootanimation_defaults\"], srcs: [\"BootAnimation.cpp\"], shared_libs: [ \"libui\", \"libhwui\", \"libEGL\", \"libGLESv1_CM\", \"libgui\", \"libtinyalsa\", //qiushao patch add start \"libmedia\", //qiushao patch add end ], product_variables: &#123; product_is_iot: &#123; init_rc: [\"iot/bootanim_iot.rc\"], &#125;, &#125;,&#125; 3. selinux 设置selinux 的配置都是在执行后，看报什么错误，就加什么权限，最后需要给 bootanim 服务和 mediaserver 服务添加权限，直接看 diff 吧: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10&#x2F;system&#x2F;sepolicy$ git diff .diff --git a&#x2F;prebuilts&#x2F;api&#x2F;29.0&#x2F;public&#x2F;bootanim.te b&#x2F;prebuilts&#x2F;api&#x2F;29.0&#x2F;public&#x2F;bootanim.teindex e8cb98bbc..0b1ffd3ee 100644--- a&#x2F;prebuilts&#x2F;api&#x2F;29.0&#x2F;public&#x2F;bootanim.te+++ b&#x2F;prebuilts&#x2F;api&#x2F;29.0&#x2F;public&#x2F;bootanim.te@@ -8,6 +8,7 @@ hal_client_domain(bootanim, hal_graphics_composer) binder_use(bootanim) binder_call(bootanim, surfaceflinger)+binder_call(bootanim, mediaserver) binder_call(bootanim, audioserver) hwbinder_use(bootanim)@@ -23,6 +24,7 @@ allow bootanim audio_device:chr_file rw_file_perms; allow bootanim audioserver_service:service_manager find; allow bootanim surfaceflinger_service:service_manager find;+allow bootanim mediaserver_service:service_manager find; # Allow access to ion memory allocation device allow bootanim ion_device:chr_file rw_file_perms;diff --git a&#x2F;prebuilts&#x2F;api&#x2F;29.0&#x2F;public&#x2F;mediaserver.te b&#x2F;prebuilts&#x2F;api&#x2F;29.0&#x2F;public&#x2F;mediaserver.teindex 70d0a55b2..5a9d8fef0 100644--- a&#x2F;prebuilts&#x2F;api&#x2F;29.0&#x2F;public&#x2F;mediaserver.te+++ b&#x2F;prebuilts&#x2F;api&#x2F;29.0&#x2F;public&#x2F;mediaserver.te@@ -24,6 +24,7 @@ userdebug_or_eng(&#96; binder_use(mediaserver) binder_call(mediaserver, binderservicedomain) binder_call(mediaserver, appdomain)+binder_call(mediaserver, bootanim) binder_service(mediaserver) allow mediaserver media_data_file:dir create_dir_perms;diff --git a&#x2F;public&#x2F;bootanim.te b&#x2F;public&#x2F;bootanim.teindex e8cb98bbc..0b1ffd3ee 100644--- a&#x2F;public&#x2F;bootanim.te+++ b&#x2F;public&#x2F;bootanim.te@@ -8,6 +8,7 @@ hal_client_domain(bootanim, hal_graphics_composer) binder_use(bootanim) binder_call(bootanim, surfaceflinger)+binder_call(bootanim, mediaserver) binder_call(bootanim, audioserver) hwbinder_use(bootanim)@@ -23,6 +24,7 @@ allow bootanim audio_device:chr_file rw_file_perms; allow bootanim audioserver_service:service_manager find; allow bootanim surfaceflinger_service:service_manager find;+allow bootanim mediaserver_service:service_manager find; # Allow access to ion memory allocation device allow bootanim ion_device:chr_file rw_file_perms;diff --git a&#x2F;public&#x2F;mediaserver.te b&#x2F;public&#x2F;mediaserver.teindex 70d0a55b2..5a9d8fef0 100644--- a&#x2F;public&#x2F;mediaserver.te+++ b&#x2F;public&#x2F;mediaserver.te@@ -24,6 +24,7 @@ userdebug_or_eng(&#96; binder_use(mediaserver) binder_call(mediaserver, binderservicedomain) binder_call(mediaserver, appdomain)+binder_call(mediaserver, bootanim) binder_service(mediaserver) allow mediaserver media_data_file:dir create_dir_perms;qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10&#x2F;system&#x2F;sepolicy$ 4. bootvideo 预置我们把 bootvideo.mp4 视频文件放到 device/qiushao/pure/bootvideo.mp4， 我测试用的 bootvideo.mp4然后在 pure.mk 中添加以下配置： 1PRODUCT_COPY_FILES += device/qiushao/pure/bootvideo.mp4:system/media/bootvideo.mp4 5. 编译验证以上就完成了 BootAnimation 播放视频的功能，其实也很简单，就是调用一下 MediaPlayer 的 c++ 接口而已。音量设置也是可以的。我们编译验证一下，图像声音都是正常的。","categories":[{"name":"Android系统开发进阶","slug":"Android系统开发进阶","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发进阶-BootAnimation启动与结束流程","slug":"Android系统开发进阶/BootAnimation启动流程","date":"2020-02-23T04:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/02/23/Android系统开发进阶/BootAnimation启动流程/","link":"","permalink":"http://qiushao.net/2020/02/23/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/BootAnimation%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/","excerpt":"","text":"开机动画 Android 系统在启动过程中播放的一段动画，其目的是给用户一个良好的开机体验。在开机过程中能看到一个动画效果表示系统正在启动中，肯定比一直黑屏等待系统启动完成体验好很多。下面我们从源码层面了解一下 BootAnimation 的启动流程。 1. bootanim 服务声明BootAnimation 的源码路径为: Android/frameworks/base/cmds/bootanimation。进入这个目录后，我们看到有一个 bootanim.rc 文件，内容如下： 12345678service bootanim &#x2F;system&#x2F;bin&#x2F;bootanimation class core animation user graphics group graphics audio disabled oneshot ioprio rt 0 writepid &#x2F;dev&#x2F;stune&#x2F;top-app&#x2F;tasks 其中定义了一个 bootanim 服务， 但这个服务是被 disable 的状态，也就是 init 解析 init.rc 的时候不会自动启动这个服务。 再看 Android.bp : 123456cc_binary &#123; name: &quot;bootanimation&quot;, defaults: [&quot;bootanimation_defaults&quot;], ... init_rc: [&quot;bootanim.rc&quot;],&#125; 有个 init_rc: [&quot;bootanim.rc&quot;] 的配置。加了这个配置之后，在编译系统的时候会把 bootanim.rc 文件安装到 /system/etc/init/ 目录。init 进程在启动的时候会加载这个目录下的所有 rc 文件， 具体见代码路径 Android/system/core/init/init.cpp： 12345678910111213141516171819202122232425static void LoadBootScripts(ActionManager&amp; action_manager, ServiceList&amp; service_list) &#123; Parser parser = CreateParser(action_manager, service_list); std::string bootscript = GetProperty(\"ro.boot.init_rc\", \"\"); if (bootscript.empty()) &#123; parser.ParseConfig(\"/init.rc\"); if (!parser.ParseConfig(\"/system/etc/init\")) &#123; late_import_paths.emplace_back(\"/system/etc/init\"); &#125; if (!parser.ParseConfig(\"/product/etc/init\")) &#123; late_import_paths.emplace_back(\"/product/etc/init\"); &#125; if (!parser.ParseConfig(\"/product_services/etc/init\")) &#123; late_import_paths.emplace_back(\"/product_services/etc/init\"); &#125; if (!parser.ParseConfig(\"/odm/etc/init\")) &#123; late_import_paths.emplace_back(\"/odm/etc/init\"); &#125; if (!parser.ParseConfig(\"/vendor/etc/init\")) &#123; late_import_paths.emplace_back(\"/vendor/etc/init\"); &#125; &#125; else &#123; parser.ParseConfig(bootscript); &#125;&#125; 至此，我们已经定义好了 bootanim 服务，但是并没有自动启动，接下来我们看看是怎么启动的。 2. bootanim 服务启动我们先想一下为什么 bootanim 服务要定义成 disable 的？为什么不直接在 init 阶段启动？因为动画是需要显示屏幕上的。如果图像显示服务那个时候还没有初始化完，那 BootAnimation 就没法播放动画了。所以 bootanim 服务必须要等图形显示相关的服务初始化完了才启动。在 Android 系统中，图像合成显示的服务是 surfaceflinger，源码路径为：Android/frameworks/native/services/surfaceflinger。 我们进入 surfaceflinger 源码目录 grep 一下 : 123456789qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10&#x2F;frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger$ grep -nr bootanimStartPropertySetThread.cpp:33: property_set(&quot;service.bootanim.exit&quot;, &quot;0&quot;);StartPropertySetThread.cpp:35: property_set(&quot;ctl.start&quot;, &quot;bootanim&quot;);tests&#x2F;fakehwc&#x2F;FakeComposerUtils.cpp:162: property_set(&quot;debug.sf.nobootanimation&quot;, &quot;1&quot;);tests&#x2F;fakehwc&#x2F;FakeComposerUtils.cpp:165: property_get(&quot;debug.sf.nobootanimation&quot;, value, &quot;0&quot;);tests&#x2F;fakehwc&#x2F;FakeComposerUtils.cpp:178: property_set(&quot;debug.sf.nobootanimation&quot;, &quot;0&quot;);SurfaceFlinger.cpp:562: property_set(&quot;service.bootanim.exit&quot;, &quot;1&quot;);EventLog&#x2F;EventLogTags.logtags:39:60110 sf_stop_bootanim (time|2|3)qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10&#x2F;frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger$ 发现在 StartPropertySetThread.cpp 中有启动 bootanim 相关的代码： property_set(&quot;ctl.start&quot;, &quot;bootanim&quot;);设置 ctl.start=bootanim 属性，即让 init 进程启动 bootanim 服务。 12345678910bool StartPropertySetThread::threadLoop() &#123; // Set property service.sf.present_timestamp, consumer need check its readiness property_set(kTimestampProperty, mTimestampPropertyValue ? \"1\" : \"0\"); // Clear BootAnimation exit flag property_set(\"service.bootanim.exit\", \"0\"); // Start BootAnimation if not started property_set(\"ctl.start\", \"bootanim\"); // Exit immediately return false;&#125; 再看 SurfaceFlinger.cpp 中的 SurfaceFlinger::init() 函数的一段代码: 12345678910// set initial conditions (e.g. unblank default device)initializeDisplays();getRenderEngine().primeCache();// Inform native graphics APIs whether the present timestamp is supported:const bool presentFenceReliable = !getHwComposer().hasCapability(HWC2::Capability::PresentFenceIsNotReliable);mStartPropertySetThread = getFactory().createStartPropertySetThread(presentFenceReliable);if (mStartPropertySetThread-&gt;Start() != NO_ERROR) &#123; ALOGE(\"Run StartPropertySetThread failed!\");&#125; 先调用 initializeDisplays(); 初始化显示系统。再调用 mStartPropertySetThread-&gt;Start() 启动 mStartPropertySetThread 线程：mStartPropertySetThread-&gt;Start() –&gt; mStartPropertySetThread-&gt;run() –&gt; mStartPropertySetThread-&gt;threadLoop()。bootanim 服务就这样在显示系统初始化完成后，马上被 SurfaceFlinger 服务启动了。 SurfaceFlinger 的源码目录下也有个 rc 文件 surfaceflinger.rc： 123456789service surfaceflinger &#x2F;system&#x2F;bin&#x2F;surfaceflinger class core animation user system group graphics drmrpc readproc onrestart restart zygote writepid &#x2F;dev&#x2F;stune&#x2F;foreground&#x2F;tasks socket pdx&#x2F;system&#x2F;vr&#x2F;display&#x2F;client stream 0666 system graphics u:object_r:pdx_display_client_endpoint_socket:s0 socket pdx&#x2F;system&#x2F;vr&#x2F;display&#x2F;manager stream 0666 system graphics u:object_r:pdx_display_manager_endpoint_socket:s0 socket pdx&#x2F;system&#x2F;vr&#x2F;display&#x2F;vsync stream 0666 system graphics u:object_r:pdx_display_vsync_endpoint_socket:s0 surfaceflinger 没有被 disable, 那就是系统启动的时候， 由 init 进程自动启动的了。 3. BootAnimation 播放流程BootAnimation 的执行入口为 bootanimation_main.cpp 的 main 函数 12345678910111213141516171819202122int main()&#123; setpriority(PRIO_PROCESS, 0, ANDROID_PRIORITY_DISPLAY); //是否支持开机动画， 由 ro.boot.quiescent 这个属性决定。 bool noBootAnimation = bootAnimationDisabled(); ALOGI_IF(noBootAnimation, \"boot animation disabled\"); if (!noBootAnimation) &#123; sp&lt;ProcessState&gt; proc(ProcessState::self()); ProcessState::self()-&gt;startThreadPool(); // create the boot animation object (may take up to 200ms for 2MB zip) sp&lt;BootAnimation&gt; boot = new BootAnimation(audioplay::createAnimationCallbacks()); //等待SurfaceFlinger初始化完成并加入到 ServiceManager。 //因为 bootanim 服务是在 SurfaceFlinger.init() 里面启动的，但在 SurfaceFlinger 服务是在执行完 SurfaceFlinger.init() 之后才加入到 ServiceManager 的，所以这里需要等一下。 waitForSurfaceFlinger(); //运行动画线程，开始播放动画。 boot-&gt;run(\"BootAnimation\", PRIORITY_DISPLAY); ALOGV(\"Boot animation set up. Joining pool.\"); IPCThreadState::self()-&gt;joinThreadPool(); &#125; return 0;&#125; BootAnimation 继承了 Thread, Thread 又继承了 RefBase , RefBase 有一个函数 onFirstRef()，这个函数在对象第一次被引用的时候会调用，这是 RefBase 引用计数的一个机制。 BootAnimation 类重写了这个函数。因此在执行 sp&lt;BootAnimation&gt; boot = new BootAnimation(audioplay::createAnimationCallbacks()); 这行的时候， BootAnimation.onFirstRef() 会被自动调用。这个函数里面会加载动画文件： 12345678910111213void BootAnimation::onFirstRef() &#123; status_t err = mSession-&gt;linkToComposerDeath(this); SLOGE_IF(err, \"linkToComposerDeath failed (%s) \", strerror(-err)); if (err == NO_ERROR) &#123; // Load the animation content -- this can be slow (eg 200ms) // called before waitForSurfaceFlinger() in main() to avoid wait ALOGD(\"%sAnimationPreloadTiming start time: %\" PRId64 \"ms\", mShuttingDown ? \"Shutdown\" : \"Boot\", elapsedRealtime()); preloadAnimation(); ALOGD(\"%sAnimationPreloadStopTiming start time: %\" PRId64 \"ms\", mShuttingDown ? \"Shutdown\" : \"Boot\", elapsedRealtime()); &#125;&#125; 这里我有点不太明白，为什么要重写 onFirstRef，并在里面加载动画文件。为什么不直接在构造函数里面加载动画文件？绕这么一圈有什么意义呢？下面的疑问暂且不管，我们来看看怎么加载动画文件： 123456789101112131415161718192021222324252627282930313233static const char OEM_BOOTANIMATION_FILE[] = \"/oem/media/bootanimation.zip\";static const char PRODUCT_BOOTANIMATION_DARK_FILE[] = \"/product/media/bootanimation-dark.zip\";static const char PRODUCT_BOOTANIMATION_FILE[] = \"/product/media/bootanimation.zip\";static const char SYSTEM_BOOTANIMATION_FILE[] = \"/system/media/bootanimation.zip\";static const char APEX_BOOTANIMATION_FILE[] = \"/apex/com.android.bootanimation/etc/bootanimation.zip\";bool BootAnimation::preloadAnimation() &#123; findBootAnimationFile(); if (!mZipFileName.isEmpty()) &#123; mAnimation = loadAnimation(mZipFileName); return (mAnimation != nullptr); &#125; return false;&#125;...void BootAnimation::findBootAnimationFile() &#123; ... const bool playDarkAnim = android::base::GetIntProperty(\"ro.boot.theme\", 0) == 1; static const char* bootFiles[] = &#123;APEX_BOOTANIMATION_FILE, playDarkAnim ? PRODUCT_BOOTANIMATION_DARK_FILE : PRODUCT_BOOTANIMATION_FILE, OEM_BOOTANIMATION_FILE, SYSTEM_BOOTANIMATION_FILE&#125;; static const char* shutdownFiles[] = &#123;PRODUCT_SHUTDOWNANIMATION_FILE, OEM_SHUTDOWNANIMATION_FILE, SYSTEM_SHUTDOWNANIMATION_FILE, \"\"&#125;; for (const char* f : (!mShuttingDown ? bootFiles : shutdownFiles)) &#123; if (access(f, R_OK) == 0) &#123; mZipFileName = f; return; &#125; &#125;&#125; findBootAnimationFile() 函数的功能是根据优先级查找存在的动画文件，结果保存在 mZipFileName 中。bootFiles 是开机动画视频优先级列表， shutdownFiles 是关机动画优先级列表。这里我们只关心开机动画，其优先级如下:APEX_BOOTANIMATION_FILE &gt; PRODUCT_BOOTANIMATION_FILE &gt; OEM_BOOTANIMATION_FILE &gt; SYSTEM_BOOTANIMATION_FILE对应的具体路径看开关的常量定义。 如果找到动画文件，则调用 loadAnimation 来加载动画文件。具体的逻辑我们这里就不关注了。 接下来回到 main 函数中， 等待 SurfaceFlinger 初始化完成。然后启动 BootAnimation 线程。这里又有一个比较绕的地方：BootAnimation 的父类 Thread 有一个虚函数 readyToRun。BootAnimation 重写了这个函数。在调用 Thread.run 函数启动线程的时候会先调用 readyToRun，然后再调用 threadLoop。readyToRun 的主要工作是调用 SurfaceFlinger 服务创建 surface， 然后初始化 opengl(egl) 环境，这里我们也不用关注。 threadLoop 就是开始真正播放动画了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051bool BootAnimation::threadLoop()&#123; bool r; // We have no bootanimation file, so we use the stock android logo // animation. if (mZipFileName.isEmpty()) &#123; r = android(); &#125; else &#123; r = movie(); &#125; ...&#125;bool BootAnimation::movie()&#123; ... playAnimation(*mAnimation); ... releaseAnimation(mAnimation); ...&#125;bool BootAnimation::playAnimation(const Animation&amp; animation)&#123; ... for (size_t i=0 ; i&lt;pcount ; i++) &#123; //动画是分段的，依次播放各片段 ... for (int r=0 ; !part.count || r&lt;part.count ; r++) &#123; //每个片段循环播放次数 ... for (size_t j=0 ; j&lt;fcount &amp;&amp; (!exitPending() || part.playUntilComplete) ; j++) &#123; //一个片段的一次播放 //逐帧播放动画，这些 opengl 绘图细节我们不关注 ... //查检是否开机完成，可以退出动画了 checkExit(); &#125; usleep(part.pause * ns2us(frameDuration)); // For infinite parts, we've now played them at least once, so perhaps exit if(exitPending() &amp;&amp; !part.count &amp;&amp; mCurrentInset &gt;= mTargetInset) break; &#125; &#125; ...&#125;void BootAnimation::checkExit() &#123; // EXIT_PROP_NAME = \"service.bootanim.exit\" char value[PROPERTY_VALUE_MAX]; property_get(EXIT_PROP_NAME, value, \"0\"); int exitnow = atoi(value); if (exitnow) &#123; requestExit(); mCallbacks-&gt;shutdown(); &#125;&#125; 我把其中绘图相关的代码都删除掉了，只保留了个逻辑框架。播放线程开始后，先判断是否有动画文件存在，有的话，则调用 movie() 函数来播放动画。没有的话，则调用 android()函数来显示一个 android logo。movie 又调用了 playAnimation() 函数来做真正的播放工作。动画的分段，循环播放逻辑已经在上面的代码上注释了。在播放每一帧的最后都会调用 checkExit() 函数来检查是否要退出动画了。checkExit() 函数里面通过获取 service.bootanim.exit 这个属性值来判断是否要退出动画。如果这个属性被设置为 “1”, 则调用 requestExit() 请求结束线程, exitPending()函数的返回值就会变成 true。就退出播放线程。BootAnimation 的使命就完成了，可以退出了。 4. bootanim 服务结束经过上面的流程分析，我们知道了 BootAnimation 通过 service.bootanim.exit 这个属性来退出动画播放的。那这个属性是谁设置的呢？泛化点来说，我们怎么分析确定一条又长又复杂的调用链呢？我的方法是 grep + 堆栈打印。有了这两把梭，基本上大部分问题都能搞定。一般能用 grep 就用 grep 先，对于比较简单的调用链来说，grep 就已经能确定了。只有遇到调用关系比较乱，屡不清关系，才用堆栈打印。下面我们就用这两把梭来试试。先在 framework 目录下 grep : 123456789qiushao@qiushao-pc:~/source/android-10/frameworks$ grep -nr \"service.bootanim.exit\"base/core/proto/android/os/system_properties.proto:522: optional int32 service_bootanim_exit = 23;base/cmds/bootanimation/BootAnimation.cpp:98:static const char EXIT_PROP_NAME[] = \"service.bootanim.exit\";base/cmds/bootanimation/FORMAT.md:104:the system property `service.bootanim.exit` to a nonzero string.)base/cmds/bootanimation/iot/iotbootanimation_main.cpp:80: property_get(\"service.bootanim.exit\", value, \"0\");base/services/core/java/com/android/server/wm/WindowManagerService.java:3312: SystemProperties.set(\"service.bootanim.exit\", \"1\");native/services/surfaceflinger/StartPropertySetThread.cpp:33: property_set(\"service.bootanim.exit\", \"0\");native/services/surfaceflinger/SurfaceFlinger.cpp:562: property_set(\"service.bootanim.exit\", \"1\");qiushao@qiushao-pc:~/source/android-10/frameworks$ 我们发现有两处地方设置了 service.bootanim.exit = 1。WindowManagerService.java 和 SurfaceFlinger.cpp。这两条路我们分别分析，先看 c++ 层的调用： 1234567void SurfaceFlinger::bootFinished()&#123; ... // stop boot animation // formerly we would just kill the process, but we now ask it to exit so it // can choose where to stop the animation. property_set(\"service.bootanim.exit\", \"1\"); 那 bootFinished 函数是由谁来调用的呢？我们在 framework 目录下 grep 一下看看： 123456789qiushao@qiushao-pc:~/source/android-10/frameworks$ grep -nr bootFinishednative/services/surfaceflinger/SurfaceFlinger.cpp:532:void SurfaceFlinger::bootFinished()native/services/surfaceflinger/SurfaceFlinger.h:409: void bootFinished() override;native/libs/gui/include/gui/ISurfaceComposer.h:149: virtual void bootFinished() = 0;native/libs/gui/tests/Surface_test.cpp:568: void bootFinished() override &#123;&#125;Binary file native/libs/gui/.ISurfaceComposer.cpp.swp matchesnative/libs/gui/ISurfaceComposer.cpp:104: virtual void bootFinished()native/libs/gui/ISurfaceComposer.cpp:1058: bootFinished();qiushao@qiushao-pc:~/source/android-10/frameworks$ 看起来是 ISurfaceComposer.cpp 里面调用的： 1234567891011status_t BnSurfaceComposer::onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; switch(code) &#123; ... case BOOT_FINISHED: &#123; CHECK_INTERFACE(ISurfaceComposer, data, reply); bootFinished(); return NO_ERROR; &#125; ... 那又是谁通过 binder 调用了 BOOT_FINISHED 这个指令呢？继续在 framework 目录下 grep 1234567891011121314151617181920212223242526272829303132333435363738394041qiushao@qiushao-pc:~/source/android-10/frameworks$ grep -nr BOOT_FINISHEDbase/services/core/java/com/android/server/wm/WindowManagerService.java:3327: surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, // BOOT_FINISHEDnative/services/surfaceflinger/SurfaceFlinger.cpp:5189: case BOOT_FINISHED:native/libs/gui/include/gui/ISurfaceComposer.h:448: // Note: BOOT_FINISHED must remain this value, it is called fromnative/libs/gui/include/gui/ISurfaceComposer.h:450: BOOT_FINISHED = IBinder::FIRST_CALL_TRANSACTION,native/libs/gui/ISurfaceComposer.cpp:108: remote()-&gt;transact(BnSurfaceComposer::BOOT_FINISHED, data, &amp;reply);native/libs/gui/ISurfaceComposer.cpp:1056: case BOOT_FINISHED: &#123;qiushao@qiushao-pc:~/source/android-10/frameworks$ ``` 看起来是 WindowManagerService.java 里面调用的：```javaprivate void performEnableScreen() &#123; synchronized (mGlobalLock) &#123; ... if (!mBootAnimationStopped) &#123; Trace.asyncTraceBegin(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0); // stop boot animation // formerly we would just kill the process, but we now ask it to exit so it // can choose where to stop the animation. SystemProperties.set(\"service.bootanim.exit\", \"1\"); mBootAnimationStopped = true; &#125; if (!mForceDisplayEnabled &amp;&amp; !checkBootAnimationCompleteLocked()) &#123; if (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: Waiting for anim complete\"); return; &#125; try &#123; IBinder surfaceFlinger = ServiceManager.getService(\"SurfaceFlinger\"); if (surfaceFlinger != null) &#123; Slog.i(TAG_WM, \"******* TELLING SURFACE FLINGER WE ARE BOOTED!\"); Parcel data = Parcel.obtain(); data.writeInterfaceToken(\"android.ui.ISurfaceComposer\"); surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, // BOOT_FINISHED data, null, 0); data.recycle(); &#125; &#125; catch (RemoteException ex) &#123; Slog.e(TAG_WM, \"Boot completed: SurfaceFlinger is dead!\"); &#125; ... 在 performEnableScreen 这个函数中通过 binder 调用了 surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, data, null, 0);而实际上， IBinder.FIRST_CALL_TRANSACTION == BOOT_FINISHED, 所以也就是相当于调用了 BOOT_FINISHED。这里的代码风格就有点问题了，如果没有注释的话，估计就找不下去了。 我们再细心看的话，会发现其实这里已经直接设置了 SystemProperties.set(&quot;service.bootanim.exit&quot;, &quot;1&quot;);，这里就是我们最开始使用 grep “service.bootanim.exit” 时，得到的另一条线路。也就是 c++, java 这两条路都汇集到这里了。那 java 层都已经设置了，其实 c++ 层设置与否都没关系了。 我们继续顺藤摸瓜，看看是谁调用了 performEnableScreen : 1234567891011qiushao@qiushao-pc:~/source/android-10/frameworks$ grep -nr performEnableScreenbase/services/core/java/com/android/server/wm/WindowManagerService.java:3235: performEnableScreen();base/services/core/java/com/android/server/wm/WindowManagerService.java:3271: performEnableScreen();base/services/core/java/com/android/server/wm/WindowManagerService.java:3281: private void performEnableScreen() &#123;base/services/core/java/com/android/server/wm/WindowManagerService.java:3283: if (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: mDisplayEnabled=\" + mDisplayEnabledbase/services/core/java/com/android/server/wm/WindowManagerService.java:3317: if (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: Waiting for anim complete\");base/services/core/java/com/android/server/wm/WindowManagerService.java:3394: performEnableScreen();base/services/core/java/com/android/server/wm/WindowManagerService.java:4734: performEnableScreen();base/services/core/java/com/android/server/wm/WindowManagerService.java:4878: performEnableScreen();base/services/art-profile:17483:HSPLcom/android/server/wm/WindowManagerService;-&gt;performEnableScreen()Vqiushao@qiushao-pc:~/source/android-10/frameworks$ 看起来有好几个调用，稍微看了下这几个调用的上下文，还真不好确定是哪一处调用。这时候就该我们的第二把梭 堆栈打印 出场了。我们在 performEnableScreen 函数的入口添加一行打印： 12private void performEnableScreen() &#123; Slog.d(TAG_WM, \"qiushao performEnableScreen\", new Throwable()); 然后重新编译运行一下，看看 log， 找第一个 “qiushao performEnableScreen”: 12345678910111202-24 20:33:49.960 1657 1698 D WindowManager: qiushao performEnableScreen02-24 20:33:49.960 1657 1698 D WindowManager: java.lang.Throwable02-24 20:33:49.960 1657 1698 D WindowManager: at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:3282)02-24 20:33:49.960 1657 1698 D WindowManager: at com.android.server.wm.WindowManagerService.enableScreenAfterBoot(WindowManagerService.java:3235)02-24 20:33:49.960 1657 1698 D WindowManager: at com.android.server.wm.ActivityTaskManagerService$LocalService.enableScreenAfterBoot(ActivityTaskManagerService.java:6482)02-24 20:33:49.960 1657 1698 D WindowManager: at com.android.server.wm.ActivityTaskManagerService.lambda$postFinishBooting$6$ActivityTaskManagerService(ActivityTaskManagerService.java:5678)02-24 20:33:49.960 1657 1698 D WindowManager: at com.android.server.wm.-$$Lambda$ActivityTaskManagerService$oP6xxIfnD4kb4JN7aSJU073ULR4.run(Unknown Source:6)02-24 20:33:49.960 1657 1698 D WindowManager: at android.os.Handler.handleCallback(Handler.java:883)02-24 20:33:49.960 1657 1698 D WindowManager: at android.os.Handler.dispatchMessage(Handler.java:100)02-24 20:33:49.960 1657 1698 D WindowManager: at android.os.Looper.loop(Looper.java:214)02-24 20:33:49.960 1657 1698 D WindowManager: at android.os.HandlerThread.run(HandlerThread.java:67)02-24 20:33:49.960 1657 1698 D WindowManager: at com.android.server.ServiceThread.run(ServiceThread.java:44) 看上面的堆栈信息，可以知道大概的流程是这样的：ActivityTaskManagerService.java:5678 postFinishBooting –&gt;ActivityTaskManagerService.java:6482 enableScreenAfterBoot –&gt;WindowManagerService.java:3235 enableScreenAfterBoot –&gt;WindowManagerService.java:3282 performEnableScreen –&gt; 我们追踪到 ActivityTaskManagerService.java postFinishBooting 这里就没线索了。只能继续用 grep 大法： 123456qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10&#x2F;frameworks$ grep -nr postFinishBootingbase&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityStackSupervisor.java:1261: mService.postFinishBooting(booting, enableScreen);base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityTaskManagerService.java:5672: void postFinishBooting(boolean finishBooting, boolean enableScreen) &#123;base&#x2F;services&#x2F;art-profile:15371:HSPLcom&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityTaskManagerService;-&gt;lambda$postFinishBooting$6$ActivityTaskManagerService(ZZ)Vbase&#x2F;services&#x2F;art-profile:15394:HSPLcom&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityTaskManagerService;-&gt;postFinishBooting(ZZ)Vqiushao@qiushao-pc:~&#x2F;source&#x2F;android-10&#x2F;frameworks$ 只有一个地方有调用: ActivityStackSupervisor.java:1261 mService.postFinishBooting(booting, enableScreen);， 不知道还有多少层级的调用，懒得慢慢 grep 分析了，直接打印堆栈： 1234567891011121314private boolean checkFinishBootingLocked() &#123; Slog.d(TAG, \"qiushao checkFinishBootingLocked\", new Throwable()); final boolean booting = mService.isBooting(); boolean enableScreen = false; mService.setBooting(false); if (!mService.isBooted()) &#123; mService.setBooted(true); enableScreen = true; &#125; if (booting || enableScreen) &#123; mService.postFinishBooting(booting, enableScreen); &#125; return booting;&#125; 重新编译运行一下，看看 log: 1234567802-24 21:08:03.958 1593 2392 D ActivityTaskManager: qiushao checkFinishBootingLocked02-24 21:08:03.958 1593 2392 D ActivityTaskManager: java.lang.Throwable02-24 21:08:03.958 1593 2392 D ActivityTaskManager: at com.android.server.wm.ActivityStackSupervisor.checkFinishBootingLocked(ActivityStackSupervisor.java:1253)02-24 21:08:03.958 1593 2392 D ActivityTaskManager: at com.android.server.wm.ActivityStackSupervisor.activityIdleInternalLocked(ActivityStackSupervisor.java:1310)02-24 21:08:03.958 1593 2392 D ActivityTaskManager: at com.android.server.wm.ActivityTaskManagerService.activityIdle(ActivityTaskManagerService.java:1675)02-24 21:08:03.958 1593 2392 D ActivityTaskManager: at android.app.IActivityTaskManager$Stub.onTransact(IActivityTaskManager.java:1957)02-24 21:08:03.958 1593 2392 D ActivityTaskManager: at android.os.Binder.execTransactInternal(Binder.java:1021)02-24 21:08:03.958 1593 2392 D ActivityTaskManager: at android.os.Binder.execTransact(Binder.java:994) 根据堆栈信息，调用流程大概是这样的：IActivityTaskManager binder 调用 –&gt;ActivityTaskManagerService.java:1675 activityIdle –&gt;ActivityStackSupervisor.java:1310 activityIdleInternalLocked –&gt;ActivityStackSupervisor.java:1253 checkFinishBootingLocked 线索到 ActivityTaskManagerService.activityIdle 这里又断了，只能用 grep 了: 1234567891011121314151617qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10&#x2F;frameworks$ jgrep activityIdle.&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;ActivityThread.java:2060: am.activityIdle(a.token, a.createdConfig, stopProfiling);.&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;job&#x2F;controllers&#x2F;idle&#x2F;DeviceIdlenessTracker.java:43: private long mInactivityIdleThreshold;.&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;job&#x2F;controllers&#x2F;idle&#x2F;DeviceIdlenessTracker.java:70: mInactivityIdleThreshold &#x3D; context.getResources().getInteger(.&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;job&#x2F;controllers&#x2F;idle&#x2F;DeviceIdlenessTracker.java:71: com.android.internal.R.integer.config_jobSchedulerInactivityIdleThreshold);.&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;job&#x2F;controllers&#x2F;idle&#x2F;DeviceIdlenessTracker.java:148: final long when &#x3D; nowElapsed + mInactivityIdleThreshold;.&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityStackSupervisor.java:1269: final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout,.&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityStackSupervisor.java:1282: if (DEBUG_IDLE) Slog.d(TAG_IDLE, &quot;activityIdleInternalLocked: Callers&#x3D;&quot;.&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityStackSupervisor.java:1356: &quot;activityIdleInternalLocked&quot;);.&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityStackSupervisor.java:1764: activityIdleInternalLocked(null, false &#x2F;* fromTimeout *&#x2F;,.&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityStackSupervisor.java:2601: void activityIdleInternal(ActivityRecord r, boolean processPausingActivities) &#123;.&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityStackSupervisor.java:2603: activityIdleInternalLocked(r !&#x3D; null ? r.appToken : null, true &#x2F;* fromTimeout *&#x2F;,.&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityStackSupervisor.java:2633: activityIdleInternal((ActivityRecord) msg.obj,.&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityStackSupervisor.java:2638: activityIdleInternal((ActivityRecord) msg.obj,.&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityTaskManagerService.java:1666: public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) &#123;.&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityTaskManagerService.java:1675: final ActivityRecord r &#x3D; mStackSupervisor.activityIdleInternalLocked(token,qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10&#x2F;frameworks$ 这里我们用了 jgrep, 需要 source build/envsetup.sh; lunch 之后才可以用这个命令。jgrep 只 grep java 源文件。看 jgrep 的结果，只有 ActivityThread.java:2060: am.activityIdle(a.token, a.createdConfig, stopProfiling); 是我们要找的： 12345678private class Idler implements MessageQueue.IdleHandler &#123; @Override public final boolean queueIdle() &#123; ... if (a.activity != null &amp;&amp; !a.activity.mFinished) &#123; try &#123; am.activityIdle(a.token, a.createdConfig, stopProfiling); a.createdConfig = null; Idler 是 ActivityThread 的一个内部类，我们看年这个类是在哪里使用的： 1234567public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) &#123; ... final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); ... Looper.myQueue().addIdleHandler(new Idler());&#125; ActivityThread 是应用的 UI 线程，也就是主线程。handleResumeActivity 会调用 Acitvity类的 OnResume方法。Looper 我们可以理解为消息队列。在消息队列空闲的时候，会调用其中的 Idler Handler。而我们系统第一个起来的应用就是 Launcher。至此，我基本上理清楚 BootAnimation 的结束流程了：Launcher 启动完成， 消息队列 Looper 进入空闲状态 –&gt;Idler Handler –&gt;ActivityTaskManagerService.java:1675 activityIdle –&gt;ActivityStackSupervisor.java:1310 activityIdleInternalLocked –&gt;ActivityStackSupervisor.java:1253 checkFinishBootingLocked –&gt;ActivityStackSupervisor.java:1261 mService.postFinishBooting(booting, enableScreen); –&gt;ActivityTaskManagerService.java:5678 postFinishBooting –&gt;ActivityTaskManagerService.java:6482 enableScreenAfterBoot –&gt;WindowManagerService.java:3235 enableScreenAfterBoot –&gt;WindowManagerService.java:3282 performEnableScreen –&gt;SystemProperties.set(“service.bootanim.exit”, “1”); 这条路真是够复杂的。不知道为什么要设计得这么复杂。最后借用网上的一张图来总结一下，虽然这图与 Android 10 上的流程有点出入，还有一些细节不到位，但整体上是 OK 的： 开机动画的启动与结束流程我们已经分析完了，其中的逻辑复杂混乱，但我们有两把梭： grep + 堆栈打印， grep 可以快刀斩乱麻，堆栈打印可以抽丝剥茧。希望大家能够学会灵活运用。这个例子里面我们只在 java 层代码分析时使用了堆栈打印，其实在 c++ 层代码也是可以使用堆栈打印这个技巧的。关键字: anrdroid callstack。","categories":[{"name":"Android系统开发进阶","slug":"Android系统开发进阶","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发进阶-系统启动流程概要","slug":"Android系统开发进阶/Android系统启动流程","date":"2020-02-22T04:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/02/22/Android系统开发进阶/Android系统启动流程/","link":"","permalink":"http://qiushao.net/2020/02/22/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/","excerpt":"","text":"本文着重对 Android 系统启动流程做一个简析，旨在从宏观上了解 Android 启动流程，不涉及具体代码细节。先了解各模块的主要工作职责，以后遇到问题可以根据现象推测这个问题大概属于哪个模块，然后再具体深入的了解模块代码流程。 Android 系统的启动流程大概如下：(图片来自:http://gityuan.com/android/) Android系统启动过程由上图从下往上的一个过程是由 Boot Loader 引导开机，然后依次进入 -&gt; Kernel -&gt; Native -&gt; Framework -&gt; App，接来下简要说说每个过程。 1. BootLoader板子上电后，芯片从固化在 ROM 里预设的代码(BOOT ROM)开始执行， BOOT ROM 会加载 Bootloader 到 RAM，然后把控制权交给 BootLoader。BootLoader 并不隶属于 Android 系统，它的作用是初始化硬件设备，加载内核文件等，为 Android 系统内核启动搭建好所需的环境（可以把 Bootloader 类比成 PC 的 BIOS）。Bootloader 是针对特定的主板与芯片的（与 CPU 及电路板的配置情况有关），因此，对于不同的设备制造商，它们的引导程序都是不同的。目前大多数系统使都是使用 uboot来修改的。Bootloader 引导程序一般分两个阶段执行： 基本的硬件初始化，目的是为下一阶段的执行以及随后的 kernel 的执行准备好一些基本的硬件环境。这一阶段的代码通常用汇编语言编写，以达到短小精悍的目的。 初始化 Flash 设备，设置网络、内存等等，将 kernel 映像和根文件系统映像从 Flash 上读到 RAM 空间中，然后启动内核。这一阶段的代码通常用 C 语言来实现，以便于实现更复杂的功能和取得更好的代码可读性和可移植性。 实际上 Bootloader 还要根据 misc 分区的设置来决定是要正常启动系统内核还是要进入 recovery 进行系统升级，复位等工作。 2. Linux KernelLinux 内核负责初始化各种软硬件环境，加载驱动程序，挂载根文件系统(/)等，最重要的是，内核启动完成后，它会在根文件系统中寻找 ”init” 文件，然后启动 init 进程。 3. init 进程init 进程是 Linux 系统中用户空间的第一个进程，进程号为1，我们可以说它是 root 进程或者所有进程的父进程。源码路径为: Android/system/core/init/。init 进程的主要工作如下： 挂载虚拟文件系统：如 /sys、/dev、/proc 启动 property 服务 启动 SELinux 解析执行 init.rc 文件: init.rc 的内容比较复杂，干的活很多，比如文件系统的挂载(mount_all)， 各种 Native 系统服务的启动。我们常见的在 init.rc 中启动的系统服务有 servicemanager, adbd, mediaserver, zygote, bootanimation 等。我们在做系统开发的时候，也经常会创建一些 Native 服务，自然也是需要在 init.rc 里面配置启动的。关于 init.rc 的配置后续再讲解。 4. zygote 进程上面提到 init 进程在解析 init.rc 时，会创建 zygote 进程，它是 Android 系统最重要的进程之一。后续 Android 中的应用进程都是由 zygote 进程 fork 出来的。因此，zygote 是 Android 系统所有应用的父进程。zygote 进程的实际执行文件并不是 zygote，而是 /system/bin/app_process。源码路径为: Android/frameworks/base/cmds/app_process/。 它会调用 frameworks/base/core/jni/AndroidRuntime.cpp 提供的接口启动 java 层的代码 frameworks/base/core/java/com/android/internal/os/ZygoteInit.java。至此，我们就进入到了 java 的世界。 zygote 的主要工作如下： 创建 java 虚拟机 AndroidRuntime 通过 AndroidRuntime 启动 ZygoteInit 进入 java 环境。 ZygoteInit 的主要工作如下： 创建 socket 服务，接受 ActivityManagerService 的应用启动请求。 加载 Android framework 中的 class、res（drawable、xml信息、strings）到内存。Android 通过在 zygote 创建的时候加载资源，生成信息链接，再有应用启动，fork 子进程和父进程共享信息，不需要重新加载，同时也共享 VM。 启动 SystemServer。 监听 socket，当有启动应用请求到达，fork 生成 App 应用进程。 zygote 进程的出现是为了能更快的启动应用。因为在 Android 中，每个应用都有对应一个虚拟机实例（VM）为应用分配不同的内存地址。如果 Android 系统为每一个应用启动不同的 VM 实例，就会消耗大量的内存以及时间。因此，更好的办法应当是通过创建一个虚拟机进程，由该 VM 进程预加载以及初始化核心库类，然后，由该 VM 进程 Fork 出其他虚拟机进程，这样就能达到代码共享、低内存占用以及最小的启动时间，而这个 VM 进程就是 zygote。 5. SystemServer 进程与 Zygote 进程一样，SystemServer 进程同样是 Android 系统中最重要的进程之一。它的源码路径为: Android/frameworks/base/services/java/com/android/server/SystemServer.java。 SystemServer 的主要的作用是启动各种系统服务，比如 ActivityManagerService，PackageManagerService，WindowManagerService 以及硬件相关的 Service 等服务，我们平时熟知的各种系统服务其实都是在 SystemServer 进程中启动的，这些服务都运行在同一进程（即 SystemServer 进程）的不同线程中，而当我们的应用需要使用各种系统服务的时候其实也是通过与 SystemServer 进程通讯获取各种服务对象的句柄进而执行相应的操作的。在所有的服务启动完成后，会调用各服务的 service.systemReady(…) 来通知各对应的服务，系统已经就绪。 6. Launcher 的启动Launcher 的启动比较复杂，而且不同版本的 Android 系统启动逻辑可能也不太一样，所以这里就不具体讨论，后续再专门讨论。但我们可以大概说明一下启动的策略。我们知道 SystemServer 进程再启动的过程中会启动PackageManagerService，PackageManagerService启动后会将系统中的应用程序安装完成。SystemServer启动完所有的服务后，会调用各服务的 service.systemReady(…)。Ｌauncher 的启动逻辑就在 ActivityManagerService.systemReady() 中。 7. BootAnimation 退出Launcher 启动完之后，我们还看不到 Launcher，因为被 BootAnimation 的画面挡住了。BootAnimation 的退出也比较复杂，后续再详细讨论。大概是第一个应用起来之后，其 ActivityThread 线程进入空闲状态时，会通过某种机制把 BootAnimation 给退出。这里的第一个应用自然就是 Launcher了。这样就能确保在 BootAnimation 退出后，用户看到的不是黑屏，而是我们的桌面了。 至此，Android系统总算是启动完成了，上面提到的这些步骤都是非常复杂的，每个步骤都可以单独花一篇或者几篇来讨论。现在我们只需要有一个整体的概念就行，其他的细节问题后续再慢慢研究。 8. 主要参考文档 Android 操作系统架构开篇 [Android6.0] 启动流程分析 Android 系统启动流程简析","categories":[{"name":"Android系统开发进阶","slug":"Android系统开发进阶","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"docker-修改容器的挂载目录","slug":"Linux/docker-修改容器的挂载目录","date":"2020-02-18T06:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/02/18/Linux/docker-修改容器的挂载目录/","link":"","permalink":"http://qiushao.net/2020/02/18/Linux/docker-%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E6%8C%82%E8%BD%BD%E7%9B%AE%E5%BD%95/","excerpt":"","text":"今天新买的一块 ssd 到货了，把一些 Android系统平台的代码都迁移到这个 ssd 上去。这个 ssd 挂载到了 /media/qiushao/source-code 目录下。这样的话，我之前创建的 docker container 就读取不到这个目录的内容了。之前的 container 的创建命令为: 1docker run -it --name aosp_builder -v ~&#x2F;source:&#x2F;home&#x2F;builder&#x2F;source -u builder aosp_builder:V1.0 &#x2F;bin&#x2F;bash 挂载的路径是 /home/qiushao/source, 现在我要把路径修改为 /media/qiushao/source-code 的话，要怎么做呢。最简单的方法是把这个旧的 container 给删除了，重新创建一个 container， 用新的路径来挂载。但是之前的那个 container 我在使用过程中还不断修改了很多配置，安装了很多新软件。安装了哪些软件又不记得了。这些软件又是编译某些平台必要的。所以这个方法行不通。网上查了一下，有很多种方法，下面是我使用的一种方法介绍。 1. 提交现有 container 为镜像12345qiushao@qiushao-pc:~$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES41f6f5ff41af bestwu&#x2F;wechat &quot;&#x2F;entrypoint.sh&quot; 2 weeks ago Up 36 minutes script_wechat393ac94612d9 aosp_builder:V1.0 &quot;&#x2F;bin&#x2F;bash&quot; 2 months ago Exited (0) 36 hours ago aosp_builderqiushao@qiushao-pc:~$ 可以看到我们目前在用的 aosp_builder container id 为 393ac94612d9。我们把这个 container 提交一下，成为一个新的镜像： 123456789qiushao@qiushao-pc:~$ docker commit 393ac94612d9 aosp_builder:V2.0sha256:84f496a7977d0d9c65cb928308f6da98f4f40d3ae61dd97ed41a259d5b3c58fdqiushao@qiushao-pc:~$ docker images REPOSITORY TAG IMAGE ID CREATED SIZEaosp_builder V2.0 84f496a7977d 30 seconds ago 4.68GBaosp_builder V1.0 149ef2e2830b 2 months ago 1.23GBbestwu&#x2F;wechat latest 53c371b7016c 5 months ago 941MBubuntu 14.04 2c5e00d77a67 9 months ago 188MBqiushao@qiushao-pc:~$ 我们把新的镜像命名为 aosp_builder:V2.0。提交完之后，docker images 查看，发现多了一个镜像出来了。 2. 删除旧的 container旧的 container 已经被我们提交成镜像了，我们可以删除掉了： 12345678qiushao@qiushao-pc:~$ docker container stop aosp_builderaosp_builderqiushao@qiushao-pc:~$ docker container rm aosp_builderaosp_builderqiushao@qiushao-pc:~$ docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES41f6f5ff41af bestwu&#x2F;wechat &quot;&#x2F;entrypoint.sh&quot; 2 weeks ago Up 45 minutes script_wechatqiushao@qiushao-pc:~$ 3. 创建新的 container1234567qiushao@qiushao-pc:~$ docker run -it --name aosp_builder -v &#x2F;media&#x2F;qiushao&#x2F;source-code:&#x2F;home&#x2F;builder&#x2F;source -u builder aosp_builder:V2.0 &#x2F;bin&#x2F;bashbuilder@88da927b1ee5:~$ exitqiushao@qiushao-pc:~$ docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES88da927b1ee5 aosp_builder:V2.0 &quot;&#x2F;bin&#x2F;bash&quot; 14 seconds ago Exited (0) 9 seconds ago aosp_builder41f6f5ff41af bestwu&#x2F;wechat &quot;&#x2F;entrypoint.sh&quot; 2 weeks ago Up 47 minutes script_wechatqiushao@qiushao-pc:~$ 至此我们就完成修改挂载目录的目的啦。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/tags/Linux/"},{"name":"docker","slug":"docker","permalink":"http://qiushao.net/tags/docker/"}]},{"title":"Java-类的加载机制介绍","slug":"Java/Java-类的加载机制介绍","date":"2020-02-18T06:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/02/18/Java/Java-类的加载机制介绍/","link":"","permalink":"http://qiushao.net/2020/02/18/Java/Java-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"在开始介绍类的加载机制之前我们先看一个有趣的例子。新建一个 apk 工程，然后修改其中的 MainActivity 代码如下： 1234567891011121314151617package net.qiushao.classloadertest;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.os.IBinder;import android.os.ServiceManager;import android.util.Log;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //下面两行代码是我们添加的 IBinder binder = ServiceManager.getService(Context.POWER_SERVICE); Log.d(\"qiushao\", \"binder = \" + binder); &#125;&#125; 我们知道 ServiceManager 这个类是 hide 的，在 sdk 里面是没有这个类的，因此上面的代码会提示找不到 ServiceManager 这个类。我们来加点魔法。在工程里新建一个包 android.os， 然后在这个包下面新建一个 ServiceManager 类： 12345678package android.os;import android.util.Log;public class ServiceManager &#123; public static IBinder getService(String name) &#123; Log.d(\"qiushao\", \"qiushao define ServiceManager\"); return null; &#125;&#125; 这样就没有错误提示了。同学们猜测一下 Log.d(&quot;qiushao&quot;, &quot;qiushao define ServiceManager&quot;); 这行代码会不会被执行？ IBinder binder = ServiceManager.getService(Context.POWER_SERVICE); 获取到的服务会不会是 null？ 我们来运行一下 apk，看下 log 12345130|generic_x86:/ $ logcat -c;logcat -s qiushao--------- beginning of main--------- beginning of system02-17 22:27:44.932 9324 9324 D qiushao : binder = android.os.BinderProxy@6cfb07c130|generic_x86:/ $ 神奇的事情发生了，ServiceManager.getService(Context.POWER_SERVICE) 的返回结果竟然不是 null。如果你没有了解过 java 的类加载机制的话，肯定会一脸懵逼。但你看完下面对类的加载机制介绍之后应该就会明白其中的原理了。 1. 类加载机制基本概念我们首先从宏观上回顾一下 java 类的编译执行的流程，大概如下图: java 虚拟机把描述类的数据从 .class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 java 类型，这就是虚拟机的加载机制。.class 文件由类装载器装载后，在 JVM 中将形成一份描述 Class 结构的元信息对象，通过该元信息对象可以获知 Class 的结构信息：如构造函数，属性和方法等，Java允许用户借由这个Class 相关的元信息对象间接调用 Class 对象的功能, 这里就是我们经常能见到的 Class 类。如果你有看过前两篇文章关于反射的介绍，你就知道，我们在反射中用到的 Class 对象其实就是从这里来的了。 本文主要介绍的就是其中的 类加载器 的工作。 2. 类的加载过程类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。这七个阶段的发生顺序如下图所示： 其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段，这五个阶段的工作分别如下： 2.1. 加载：查找并加载类的二进制数据加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情： 通过一个类的全限定名来获取定义此类的的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的 java.lang.Class 对象， 作为方法区这个类的各种数据的访问入口。 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。下面我们会着重讲解类加载器这部分内容。加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class 类的对象，这样便可以通过该对象访问方法区中的这些数据。 2.2. 校验：检查载入Class文件数据的正确性验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证： 文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。 元数据的验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。 字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。 符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。 2.3. 准备：给类的静态变量分配存储空间准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意： 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 java 堆中。 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在 java 代码中被显式地赋予的值。假设一个类变量的定义为:1public static int value = 3； 那么变量 value 在准备阶段过后的初始值为 0，而不是 3，因为这时候尚未开始执行任何 java 方法，后面的初始化阶段会执行这个赋值语句，将 value 赋值为 3。 如果类字段的字段属性表中存在常量属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为常量属性所指定的值。假设上面的类变量 value 被定义为： 1public static final int value = 3； 编译时 javac 将会为 value 生成常量属性，在准备阶段虚拟机就会根据常量的设置将 value 赋值为 3。 2.4. 解析：将符号引用转成直接引用解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 2.5. 初始化：对类的静态变量，静态代码块执行初始化操作初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的 java 程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器 &lt;clinit&gt;() 方法的过程。这里简单说明下 &lt;clinit&gt;() 方法的执行规则: &lt;clinit&gt;() 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。 &lt;clinit&gt;() 方法与实例构造器 &lt;init&gt;() 方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的 &lt;clinit&gt;() 方法执行之前，父类的 &lt;clinit&gt;() 方法已经执行完毕。因此，在虚拟机中第一个被执行的 &lt;clinit&gt;() 方法的类肯定是 java.lang.Object。 &lt;clinit&gt;() 方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成 &lt;clinit&gt;() 方法。 接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成 &lt;clinit&gt;() 方法。但是接口与类不同的是：执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。 虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 &lt;clinit&gt;() 方法，其他线程都需要阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;() 方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。 3. 触发类加载的条件虚拟机规范严格规定了有且只有5中情况（jdk1.7）必须对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）： 遇到 new,getstatic,putstatic,invokestatic 这些字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的 java 代码场景是：使用 new 关键字实例化对象的时候、读取或设置一个类的静态字段（被 final 修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 当使用 jdk1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getstatic, REF_putstatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。 4. 类加载器 在 java 中内置有三类 ClassLoader：启动类加载器（Bootstrap ClassLoader）、扩展类加载器（ExtClassLoader）、应用类加载器（AppClassLoader）。不同的类加载器负责不同区域的类的加载。 启动类加载器：这个加载器不是一个 java 类，而是由底层c++实现的，负责加载存放在 $JAVA_HOME/jre/lib 目录中的类库，或者被 -Xbootclasspath 参数所指定的路径中的类库，比如 rt.jar。因为启动类加载器不属于 java 类库，无法被 java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用 null 代替即可。 扩展类加载器：由 sun.misc.Launcher$ExtClassLoader 实现。负责加载 $JAVA_HOME/jre/lib/ext 目录下的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。 应用类加载器：由 sun.misc.Launcher$AppClassLoader 实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader 方法的返回值，所以也叫系统类加载器。它负责加载用户类路径(CLASSPATH)上所指定的类库，可以被直接使用。如果未自定义类加载器，默认为该类加载器。 我们可以通过这种方式打印加载路径及相关jar： 123456789package qiushao.net;public class App &#123; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123; System.out.println(\"boot:\" + System.getProperty(\"sun.boot.class.path\")); System.out.println(\"ext:\" + System.getProperty(\"java.ext.dirs\")); System.out.println(\"app:\" + System.getProperty(\"java.class.path\")); &#125;&#125; 4.1 双亲委派模型类加载器查找 Class（也就是在loadClass时）所采用的是双亲委托模式，所谓双亲委托模式就是: 首先判断该 Class 是否已经加载 如果没有加载则委托给父加载器进行查找，这样依次的进行递归，直到委托到最顶层的 Bootstrap ClassLoader 如果 Bootstrap ClassLoader 找到了该 Class，就会直接返回 如果没找到，则继续依次向下查找，如果还没找到则最后会交由自身去查找 具体流程见下图：（图片来自http://liuwangshu.cn/application/classloader/1-java-classloader-.html） 红色虚线的箭头代表向上委托的方向，如果当前的类加载器没有从缓存中找到这个 Class 对象，就会请求父加载器进行操作。直到 Bootstrap ClassLoader。 黑色虚线的箭头代表的是查找方向，若 Bootstrap ClassLoader 可以从 $JAVA_HOME/jre/lib目录或者 -Xbootclasspath 指定目录查找到，就直接返回该对象，否则就让 ExtClassLoader 去查找。 ExtClassLoader 就会从 $JAVA_HOME/jre/lib/ext 或者 -Djava.ext.dir 指定位置中查找，找不到时就交给 AppClassLoader。 App ClassLoade 查找 CLASSPATH 目录下或者 -Djava.class.path 选项所指定的目录下的 jar 包和 .class文件，如果找到就返回，找不到交给我们自定义的类加载器 CustomClassLoader。 CustomClassLoader 是我们自定义的加载器，就要看我们怎么实现自定义 ClassLoader 的 findClass 方法了。 双亲委派模型是为了保证 java 核心库的类型安全。所有 java 应用都至少需要引用 java.lang.Object 类，在运行时这个类需要被加载到 java 虚拟机中。如果该加载过程由自定义类加载器来完成，可能就会存在多个版本的 java.lang.Object 类，而且这些类之间是不兼容的。通过双亲委派模型，对于 java 核心库的类的加载工作由启动类加载器来统一完成，保证了 java 应用所使用的都是同一个版本的 java 核心库的类，是互相兼容的。 下面我们来看一下双亲委派模型的代码是如何实现的。其实非常简单，相关的代码在 ClassLoader 类的 loadClass 方法： 1234567891011121314151617181920212223242526protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; //首先判断指定类是否已经被加载过 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; try &#123; if (parent != null) &#123; //如果当前类没有被加载且父类加载器不为null，则请求父类加载器进行加载操作 c = parent.loadClass(name, false); &#125; else &#123; //如果当前类没有被加载且父类加载器为null，则请求根类加载器进行加载操作 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; //如果父类加载器加载失败，则由当前类加载器进行加载 c = findClass(name); &#125; &#125; return c;&#125; 4.2 自定义类加载器系统提供的类加载器只能够加载系统配置目录下的 jar 包和 .class文件, 如果想要加载网络上或者指定的目录下的 jar 包或者 class 文件，我们可以实现一个自己的类加载器。自定义类加载器只需要继承 java.lang.ClassLoader 类，然后重写 findClass(String name) 方法即可，在方法中指明如何获取类的字节码流。下面来写个 Demo 试试看。我们先编写一个测试类，用来被我们自定义的类加载器加载： 123456package qiushao.net;public class Person &#123; public void say() &#123; System.out.println(\"hello class loader\"); &#125;&#125; 我们编译这个类生成 Person.class 文件，把这个文件放到 /home/qiushao/test/classloader/qiushao/net 目录下，然后删除 Person.java 源文件。接下来我们就定义一个可以从指定目录加载 .class 文件的类加载器 TestClassloader: 12345678910111213141516171819202122232425262728293031323334353637383940414243package qiushao.net;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class TestClassloader extends ClassLoader &#123; String mClassPath; public TestClassloader(String classPath) &#123; mClassPath = classPath; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] classData = getClassData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, classData, 0, classData.length); &#125; &#125; //很简单，其实就是把文件数据读取到 byte[] data 而已。 //如果有需求，我们可以把 class 文件加密，或者从网上下载，以免被别人破解核心代码。 private byte[] getClassData(String name) &#123; name = name.replaceAll(\"\\\\.\", \"/\"); FileInputStream fis = null; byte[] data = null; try &#123; fis = new FileInputStream(mClassPath + \"/\" + name + \".class\"); int len = fis.available(); data = new byte[len]; fis.read(data); fis.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return data; &#125;&#125; 接下来我们就可以使用这个自定义的类加载器来加载我们之前编译的 .class了 123456789101112131415package qiushao.net;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class App &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123; TestClassloader classloader = new TestClassloader(\"/home/qiushao/test/classloader\"); Class&lt;?&gt; claz = classloader.loadClass(\"qiushao.net.Person\"); Object obj = claz.newInstance(); Method method = claz.getMethod(\"say\"); method.invoke(obj); System.out.println(\"qiushao.net.Person is loaded by:\" + obj.getClass().getClassLoader()); &#125;&#125; 结果如下： 12hello class loaderqiushao.net.Person is loaded by:qiushao.net.TestClassloader@5e2de80c 的确加载到了我们指定路径下的 Class。 5. 开篇问题解答看到这里，大家可以思考一下我们开头提出来的问题了：为什么我们自己定义的 ServiceManager 类不起作用？答案就是双亲委派加载。这里给点提示，大家自己思考一下。 framework.jar 中有一个 android.os.ServiceManager 类。 framework.jar 在 BOOTCLASSPATH 中。这个可以 adb shell env 查看一下环境变量确认。 Bootstrap ClassLoader 会加载 $BOOTCLASSPATH 路径下的类。 以上大部分知识来源于 周志明老师的 &lt;深入理解 Java 虚拟机&gt;，这本书买了几年了，为了写这篇文章，又翻出来看了几遍。这本书写的是真不错，感兴趣的同学可以买来研究一下。","categories":[{"name":"Java","slug":"Java","permalink":"http://qiushao.net/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://qiushao.net/tags/Java/"}]},{"title":"Java-注解介绍","slug":"Java/Java-注解介绍","date":"2020-02-16T06:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/02/16/Java/Java-注解介绍/","link":"","permalink":"http://qiushao.net/2020/02/16/Java/Java-%E6%B3%A8%E8%A7%A3%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"1. 什么是注解Java 的官方文档是这么介绍的: Annotations, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate.Annotations have a number of uses, among them:Information for the compiler : Annotations can be used by the compiler to detect errors or suppress warnings.Compile-time and deployment-time processing : Software tools can process annotation information to generate code, XML files, and so forth.Runtime processing : Some annotations are available to be examined at runtime. 翻译过来就是：注解是一种元数据形式，它可以为程序提供数据，但这些数据并不是程序本身的一部分。注解对代码的执行并没有任何直接的影响。注解通常有以下几个使用场景： 为编译器提供信息：注解可以被编译器用来检查错误，或者忽略警告。 编译时和发布时处理：一些软件工具可以通过处理注解信息来生成代码，xml 文件等。 运行时处理：有些注解可以在运行时被使用。 说实话，我看了这个解析，觉得跟没说一样，我个人认为，比较糟糕的技术文档主要特征之一就是：用专业名词来介绍专业名词。对于一个不知道注解是什么东西的人，你跟他说元数据，这不是扯蛋嘛。在经过学习，整理，并自已运用注解实现了一个简易的 ORM 框架之后，我才明白了注解是什么，它的使用场景是什么。我个人的理解：注解是一种标签(tag)系统， 这里我们用博客文章来作类比。如果这篇文章是代码程序，我给这篇文章打了一个标签 Java，那么这个 Java 标签我们就可以理解为一个注解。一篇文章可以打多个标签，一段代码，也可以使用多个注解。标签本身对这篇文章没有任何影响，但我可以根据标签来对文章进行分类。注解本身对代码也没有任何影响，但我们要以编写注解处理器来处理注解生成代码或者其他处理。 2. 注解的使用场景注解的使用可以说是无处不在，如果你是 Java 语言的使用者，我相信你一定用过。下面根据官方文档列举的几个场景举些例子。 为编译器提供信息1234567public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; 这个 @Override 就是一个给编译器提供信息的注解了，我们常见的还有 @Deprecated, @SuppressWarnings 等。 编译时自动生成代码或者数据这种场景用得比较少， 一般是出于性能考虑， 因为运行时处理注解的话是要使用反射的，反射的性能比较差，为了尽可能的提高性能，所以把注解的处理放在编译期处理。Android 的 ORM 框架 GreenDao 就是一个典型。 运行时处理这种使用场景就比较广泛了，比如 ORM 框架 LiteOrm12345678910111213141516@Table(\"test_model\")public class TestModel &#123; // 指定自增，每个对象需要有一个主键 @PrimaryKey(AssignType.AUTO_INCREMENT) private int id; // 非空字段 @NotNull private String name; //忽略字段，将不存储到数据库 @Ignore private String password; // 默认为true，指定列名 @Default(\"true\") @Column(\"login\") private Boolean isLogin;&#125; 比如 Android View 注入框架 Butter Knife1234567891011121314class ExampleActivity extends Activity &#123; @BindView(R.id.user) EditText username; @BindView(R.id.pass) EditText password; @BindString(R.string.login_error) String loginErrorMessage; @OnClick(R.id.submit) void submit() &#123; // TODO call server... &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.simple_activity); ButterKnife.bind(this); // TODO Use fields... &#125;&#125; web 服务开发的应用就更多了，这里就不列举了。我们只需要知道注解是一种很有用的工具就行。 3. 注解的基本用法还是以一个简单的小 Demo 开始： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package qiushao.net;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.lang.reflect.Field;//创建一个注解@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface Table &#123; String name(); int version() default 1;&#125;//使用这个注解@Table(name = \"person\")class Person &#123; public int id; public String name;&#125;public class App &#123; //注解的解析处理 public static void save(Object obj) throws NoSuchFieldException, IllegalAccessException &#123; //通过反射获取注解信息，如果这个 obj 上有注解的话，返回对应的注解实例，没有的话，返回 null Class&lt;?&gt; claz = obj.getClass(); Table table = claz.getAnnotation(Table.class); if (null == table) &#123; System.out.println(\"no Table annotation on this object\"); return; &#125; System.out.println(\"there is annotation on this object\"); System.out.println(\"table name = \" + table.name() + \", table version = \" + table.version()); Field[] fields = claz.getFields(); for (Field field : fields) &#123; String fieldName = field.getName(); Object fieldValue = field.get(obj); System.out.println(fieldName + \" = \" + fieldValue); &#125; &#125; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123; Person person = new Person(); person.id = 1; person.name = \"qiushao\"; save(person); &#125;&#125; 运行结果如下： 1234there is annotation on this objecttable name &#x3D; person, table version &#x3D; 1id &#x3D; 1name &#x3D; qiushao 通过上面的例子，我们展示了注解的一些最基本用法，比如创建注解，使用注解，解析注解信息等。接下来我们详细的讨论注解的各种功能具体用法。 4. 注解的定义直接使用上面的例子来分析： 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface Table &#123; String name(); int version() default 1;&#125; 注解通过 @interface关键字进行定义。它的形式跟接口很类似，不过前面多了一个 @ 符号。上面的代码就创建了一个名字为 Table 的注解。这个注解有两个成员变量 name 和 version。注解的成员变量定义形式跟普通的 java 类成员定义有点差别。它的定义形式为：变量类型 变量名() [default value];，感觉是同时定义了一个变量和一个与变量同名的方法，这一点可以从后面获取注解的成员变量信息用法(table.name())看出来。 @Target @Retention 这两个叫做元注解。具体作用下面来介绍。 5. 元注解元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，它能够应用到其它的注解上面。元注解有@Retention、@Documented、@Target、@Inherited、@Repeatable，下面我们一一介绍。 5.1 @RetentionRetention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。它的取值如下： RetentionPolicy.SOURCE :注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 RetentionPolicy.CLASS :注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 RetentionPolicy.RUNTIME :注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。 5.2 @TargetTarget 是目标的意思，@Target 指定了注解可以被使用的地方。它的取值如下： ElementType.ANNOTATION_TYPE :可以给一个注解进行注解 ElementType.CONSTRUCTOR :可以给构造方法进行注解 ElementType.FIELD :可以给成员变量进行注解 ElementType.LOCAL_VARIABLE :可以给局部变量进行注解 ElementType.METHOD :可以给方法进行注解 ElementType.PACKAGE :可以给一个包进行注解 ElementType.PARAMETER :可以给一个方法内的参数进行注解 ElementType.TYPE :可以给一个类型进行注解，比如类、接口、枚举 比如我们标注 @Target(ElementType.TYPE) 后，这个注解就只能对 类、接口、枚举 进行注解了，不能对方法或者成员变量进行注解。 5.3 @InheritedInherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。说的比较抽象。show you the code: 12345678@Inherited@Retention(RetentionPolicy.RUNTIME)@interface Test &#123;&#125;@Testpublic class A &#123;&#125;public class B extends A &#123;&#125; 注解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解。 5.4 @Documented表示拥有该注解的元素可通过javadoc此类的工具进行文档化。 5.5 @RepeatableRepeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。什么样的注解会多次应用呢？通常是注解的值可以同时取多个。举个例子，一个人他既是程序员又是产品经理: 123456789101112131415161718192021222324252627282930313233343536373839package qiushao.net;import java.lang.annotation.*;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface Roles &#123; Role[] value();&#125;@Repeatable(Roles.class)@interface Role &#123; String role();&#125;@Role(role = \"Programmer\")@Role(role = \"Product Manager\")class Person &#123; public int id; public String name;&#125;public class App &#123; public static void save(Object obj) throws NoSuchFieldException, IllegalAccessException &#123; Class&lt;?&gt; claz = obj.getClass(); Roles roles = claz.getAnnotation(Roles.class); if (null != roles) &#123; System.out.println(\"has Roles Annotation\"); for (Role role : roles.value()) &#123; System.out.println(role); &#125; &#125; &#125; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123; Person person = new Person(); person.id = 1; person.name = \"qiushao\"; save(person); &#125;&#125; 运行结果如下： 123has Roles Annotation@qiushao.net.Role(role&#x3D;Programmer)@qiushao.net.Role(role&#x3D;Product Manager) 6. 注解的提取从前面的例子我们看到注解信息的提取是通过反射来获取的。我们可以通过 Class, Method, Field 对象来获取注解信息，有以下这些接口： 12345678//当存在该元素的指定类型注解，则返回true，否则返回falseboolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass);//返回此元素上存在的所有注解Annotation[] getAnnotations();//返回直接存在于此元素上的所有注解。Annotation[] getDeclaredAnnotations();//当存在该元素的指定类型注解，则返回相应注解，否则返回nullT getAnnotation(Class annotationClass); 我们已经学习了反射跟注解的基本使用方法了，这两个技术是实现 ORM 框架的一个基本要求，学以致用才能更深入的理解所学到的知识，所以我们可以自己尝试写个 ORM 框架来玩玩。DBHelper， 这个是我之前学习反射跟注解时写的一个练手项目，一个 Android ORM 框架。","categories":[{"name":"Java","slug":"Java","permalink":"http://qiushao.net/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://qiushao.net/tags/Java/"}]},{"title":"Java-反射机制介绍","slug":"Java/Java-反射机制介绍","date":"2020-02-15T12:46:26.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/02/15/Java/Java-反射机制介绍/","link":"","permalink":"http://qiushao.net/2020/02/15/Java/Java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"我觉得作为一个 java 语言的使用者，无论你是 web 开发，还是 Android 开发，你都有必要了解一下这几个知识点：反射，类的加载机制，注解,动态代理。作为一个普通的开发者，你可能没有意识到你有使用过这些技术，但实际上这些技术是应用非常广的，基本上我们使用的各种 web 框架， ORM 框架，插件化框架都会依赖这些技术去实现。如果你想对使用的各种框架有更深入的理解，或者甚至想开发自己的框架，那你一定要深入理解前面提到的几个基本知识点。这里先介绍反射，后面再依次介绍其他知识点。 1. 什么是反射反射机制是 Java 语言的一个重要特性。在学习 Java 反射机制前，大家应该先分清楚两个概念: 编译期和运行期。 编译期：是指把源码交给编译器编译成计算机可以执行的文件的过程。在 Java 中也就是把 Java 代码编成 class 文件的过程。编译期只是做了一些翻译功能，并没有把代码放在内存中运行起来，而只是把代码当成文本进行操作，比如检查错误。 运行期：是把编译后的文件交给计算机执行，直到程序运行结束。所谓运行期就把在磁盘中的代码放到内存中执行起来。 Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。简单来说，反射机制指的是程序在运行时能够获取自身的信息。在 Java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息，而这个类在编译过程中甚至是还未存在的。在运行的时候我们可以通过配置文件获取某个类的类名，然后使用反射机制构造这个类的对象，调用这个对象的方法，修改这个对象的成员变量。 2. 反射的使用场景Java 反射机制在 web 开发框架， ORM 框架， 插件化开发等场景中得到了广泛运用。比如说 web 开发框架 Spring 中，最重要的概念就是 IOC 控制反转。而 IOC 的实现原理就是反射。通过反射来构造 Java Bean 的对象，调用其方法。比如说 Android 开发中常用的 ORM 框架： GreenDao, LiteOrm 等， 也是通过反射来读写 Java Bean 对象的成员变量的。如果你只是使用这些框架，你可能感觉不到反射的存在，实际上反射却是无处不在。 3. 反射的基本用法我们先写个简单的 Demo，来感性的认识一下反射的基本用法: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package qiushao.net;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;class Person &#123; private String mName; public Person() &#123; mName = \"unknown\"; &#125; public Person(String name) &#123; mName = name; &#125; public String getName() &#123; return mName; &#125; public void setName(String name) &#123; mName = name; &#125; public void show() &#123; System.out.println(\"hello, my name is \" + mName); &#125;&#125;public class App &#123; public static void main( String[] args ) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123; //假设我们在编译时不能直接 import qiushao.net.Person; 这个类， 但我们知道系统有这么一个类存在，而且我们知道它的包名类名。 //1. 获取类对象 Class&lt;?&gt; claz = Class.forName(\"qiushao.net.Person\"); //2. 调用无参构造函数创建类实例 Object person = claz.newInstance(); //3. 调用方法 Method setNameMethod = claz.getMethod(\"setName\", String.class); setNameMethod.invoke(person, \"qiushao\"); Method showMethod = claz.getMethod(\"show\"); showMethod.invoke(person); //4. 设置成员变量值 Field nameField = claz.getDeclaredField(\"mName\"); nameField.setAccessible(true); nameField.set(person, \"foobar\"); showMethod.invoke(person); &#125;&#125; 通过上面的例子，我们展示了反射的一些最基本用法，比如获取类对象，构造类实例，调用实例的方法，修改成员变量的值等。接下来我们详细的讨论反射的各种功能具体用法。 4. 获取 Class 对象我们可以通过三种形式来获取一个类的 Class 对象： 直接通过 类名.class 的方式得到：Class&lt;?&gt; claz = Person.class;, 如果我们在编译时期可以 import Person 这个类的话，就可以这么用。 通过对象调用 getClass() 方法来获取: Class&lt;?&gt; claz = obj.getClass();, 比如你传过来一个 Object 类型的对象，而我不知道你具体是什么类，用这种方法 通过 Class 对象的 forName() 静态方法来获取: Class&lt;?&gt; claz = Class.forName(&quot;qiushao.net.Person&quot;);， 不能在编译时 import, 也不能在运行时获取类对象的话，只能用这种方法了。这种用法是最常用的了。forName 还有另外一个重载方法Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader), 可以传入一个 ClassLoader 对象来指定类的加载方法。这个就涉及到类的加载机制了，这里先不讨论。获取到 Class 之后，我们可以进而可以通过 claz 获取一些这个类的基本信息：12345678910111213141516// 获取“类名”， 值为 Person public String getSimpleName()// 获取“完整类名”， 值为 qiushao.net.Personpublic String getName()// 类是不是“枚举类”public boolean isEnum()// obj是不是类的对象public boolean isInstance(Object obj)// 类是不是“接口”public boolean isInterface()// 类是不是“本地类”。本地类,就是定义在方法内部的类。public boolean isLocalClass()// 类是不是“成员类”。成员类,是内部类的一种， 其定义请参考 https://blog.csdn.net/a327369238/article/details/52780442public boolean isMemberClass()// 类是不是“基本类型”。 基本类型，包括void和boolean、byte、char、short、int、long、float 和 double这几种类型。public boolean isPrimitive() 5. 创建类实例通过反射来创建类实例主要有两种方式: 调用无参构造函数无参构造函数是指没有参数的构造函数，如果一个类有无参构造函数的话，我们就可以通过这种方式来创建类的实例： 12Class&lt;?&gt; claz = Class.forName(\"qiushao.net.Person\");Object person = claz.newInstance(); 调用指定构造函数如果一个类没有无参构造函数，使用第一种方法就会报错，我们需要使用另外一种方法： 123Class&lt;?&gt; claz = Class.forName(\"qiushao.net.Person\");Constructor constructor = claz.getConstructor(String.class);Object person = constructor.newInstance(\"qiushao\"); 我们可以通过 claz.getConstructor 来获取指定参数类型的构造函数， 这个例子里面就是获取有一个 String 类型参数的构造函数。然后通过 constructor.newInstance 来创建实例，参数就是我们要传给构造函数的数据。 获取构造函数的接口还有其他几个，使用方法基本类似，就不再举例了： 12345678910// 获取“参数是parameterTypes”的public的构造函数public Constructor getConstructor(Class[] parameterTypes)// 获取全部的public的构造函数public Constructor[] getConstructors()// 获取“参数是parameterTypes”的，并且是类自身声明的构造函数，包含public、protected和private构造函数。public Constructor getDeclaredConstructor(Class[] parameterTypes)// 获取类自身声明的全部的构造函数，包含public、protected和private方法。public Constructor[] getDeclaredConstructors()// 如果这个类是“其它类的构造函数中的内部类”，调用getEnclosingConstructor()就是这个类所在的构造函数； 这种场景我还没见过，居然会在构造函数中声明一个类。public Constructor getEnclosingConstructor() 6. 调用方法参考上面的例子，通过反射调用类方法的基本形式为： 123Method setNameMethod = claz.getMethod(\"setName\", String.class);setNameMethod.setAccessible(true);setNameMethod.invoke(person, \"qiushao\"); 如果要调用的方法是 private 的，则需要调用 setAccessible(true) 来修改访问权限。如果要调用的方法是类的静态方法，则 invoke 的第一个参数传 null 即可。获取类的方法的接口有好几个，解析如下： 12345678910// 获取“名称是name，参数是parameterTypes”的public的函数(包括从基类继承的、从接口实现的所有public函数)public Method getMethod(String name, Class[] parameterTypes)// 获取全部的public的函数(包括从基类继承的、从接口实现的所有public函数)public Method[] getMethods()// 获取“名称是name，参数是parameterTypes”，并且是类自身声明的函数，包含public、protected和private方法。public Method getDeclaredMethod(String name, Class[] parameterTypes)// 获取全部的类自身声明的函数，包含public、protected和private方法。public Method[] getDeclaredMethods()// 如果这个类是“其它类中某个方法的内部类”，调用getEnclosingMethod()就是这个类所在的方法；若不存在，返回null。public Method getEnclosingMethod() 7. 访问变量参考上面的例子，通过反射访问类成员变量的基本形式为： 123456Field nameField = claz.getDeclaredField(\"mName\");nameField.setAccessible(true);//修改成员变量的值nameField.set(person, \"foobar\");//获取成员变量的值String value = (String) nameField.get(person); 如果要访问的变量是 private 的，则需要调用 setAccessible(true) 来修改访问权限。如果要访问的变量是类的静态变量，则 set/get 的第一个参数传 null 即可。如果要访问的变量是基本数据类型(int, double等)的话，则要通过 setInt/getInt 等形式去设置和获取值。获取变量的接口有好几个，解析如下： 12345678// 获取名称是\"name\"的public的成员变量(包括从基类继承的、从接口实现的所有public成员变量)public Field getField(String name)// 获取全部的public成员变量(包括从基类继承的、从接口实现的所有public成员变量)public Field[] getFields()// 获取名称是\"name\"，并且是类自身声明的成员变量，包含public、protected和private成员变量。public Field getDeclaredField(String name)// 获取全部的类自身声明的成员变量，包含public、protected和private成员变量。public Field[] getDeclaredFields() 8. 获取父类信息我们可以通过以下接口，获取父类的信息 12345678// 获取实现的全部接口，由于编译擦除，没有显示泛型参数Class&lt;?&gt;[] getInterfaces()// 获取实现的全部接口， 包含泛型参数public Type[] getGenericInterfaces()// 获取直接继承的父类, 由于编译擦除，没有显示泛型参数Class&lt;? super T&gt; getSuperclass();// 获取直接继承的父类, 包含泛型参数public Type getGenericSuperclass() 我们获取到父类的 Class 之后，就可以用我们前面学到的方法来访问父类的方法和变量了。 9. 枚举的反射枚举本质上就是一个类，所以上面介绍的方法，对于枚举来说是同样适用的。枚举常量我们可以理解为是类的 public static final int 变量。下面举个枚举的例子: 1234567891011121314151617181920212223enum COLOR &#123; RED, GREEN, BLUE&#125;public class App &#123; public static void showColor(COLOR color) &#123; System.out.println(color); &#125; public static void main( String[] args ) throws ClassNotFoundException, IllegalAccessException, NoSuchMethodException, NoSuchFieldException, InvocationTargetException &#123; Class&lt;?&gt; clazApp = App.class; Class&lt;?&gt; clazColor = COLOR.class; Method showColorMethod = clazApp.getMethod(\"showColor\", clazColor); // 这里我们可以把 GREEN 这个枚举值当作 COLOR 枚举类的一个变量 Field greenField = clazColor.getField(\"GREEN\"); // 枚举量可以当作是类的静态变量，所以获取它的值时，传 null 就行 Object color = greenField.get(null); showColorMethod.invoke(null, color); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://qiushao.net/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://qiushao.net/tags/Java/"}]},{"title":"Android-grade依赖下载加速","slug":"Android/grade依赖下载加速","date":"2020-02-14T02:00:00.000Z","updated":"2020-12-27T01:22:23.740Z","comments":true,"path":"2020/02/14/Android/grade依赖下载加速/","link":"","permalink":"http://qiushao.net/2020/02/14/Android/grade%E4%BE%9D%E8%B5%96%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/","excerpt":"","text":"在国内使用 Android studio 做开发时，第一次编译总是出奇的慢，有时甚至编译失败。因为自动生成的 build.gradle 文件配置默认是从 jcenter 和 google 上下载依赖的。这两个网站都是在国外的，访问速度是非常差。为了改善国内的开发环境，很多公司提供了国内加速镜像，比如阿里云。下面我们就看看如何使用阿里云的 gradle 镜像。 1. 单个工程修改修改项目根目录下 build.gradle 文件： 1234567891011121314151617181920buildscript &#123; &#x2F;&#x2F; gradle 编译工具配置 repositories &#123; &#x2F;&#x2F; 在 google, jcenter 之前添加 aliyun 的镜像，会优先使用 maven &#123; url &#39;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;public&#x2F;&#39; &#125; google() jcenter() &#125; dependencies &#123; classpath &#39;com.android.tools.build:gradle:3.4.2&#39; &#125;&#125;allprojects &#123; &#x2F;&#x2F; 项目依赖配置 repositories &#123; &#x2F;&#x2F; 在 google, jcenter 之前添加 aliyun 的镜像，会优先使用 maven &#123; url &#39;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;public&#x2F;&#39; &#125; google() jcenter() &#125;&#125; 2. 全局修改在 ~/.gradle/ 目录下创建文件 init.gradle : 1234567891011121314151617181920212223allprojects&#123; repositories &#123; google() def ALIYUN_REPOSITORY_URL &#x3D; &#39;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#39; def ALIYUN_JCENTER_URL &#x3D; &#39;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;repositories&#x2F;jcenter&#39; all &#123; ArtifactRepository repo -&gt; if(repo instanceof MavenArtifactRepository)&#123; def url &#x3D; repo.url.toString() if (url.startsWith(&#39;https:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&#39;)) &#123; project.logger.lifecycle &quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_REPOSITORY_URL.&quot; remove repo &#125; if (url.startsWith(&#39;https:&#x2F;&#x2F;jcenter.bintray.com&#x2F;&#39;)) &#123; project.logger.lifecycle &quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_JCENTER_URL.&quot; remove repo &#125; &#125; &#125; maven &#123; url ALIYUN_REPOSITORY_URL &#125; maven &#123; url ALIYUN_JCENTER_URL &#125; &#125;&#125; 这样修改之后，以后再创建新的项目，就会默认使用 aliyun 镜像加速了。阿里不仅做了 maven 的镜像，还有 npm的镜像， 还有 各Linux系统的软件源镜像, 还有很多其他镜像源， 具体可以在 阿里巴巴镜像站上查找。感谢阿里给开发者带来了便利。","categories":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Linux maven 设置阿里云镜像加速","slug":"Linux/linux-maven-aliyun","date":"2020-02-14T02:00:00.000Z","updated":"2020-12-27T13:17:23.948Z","comments":true,"path":"2020/02/14/Linux/linux-maven-aliyun/","link":"","permalink":"http://qiushao.net/2020/02/14/Linux/linux-maven-aliyun/","excerpt":"","text":"12mkdir -p ~/.m2vim ~/.m2/settings.xml settings.xml 的内容如下： 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 设置完之后，执行 mvn 命令看看是不是已经从 aliyun 的镜像上下载依赖了。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/categories/Linux/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://qiushao.net/tags/maven/"}]},{"title":"Android-logcat统计各进程的log输出","slug":"Android/logcat-stat","date":"2020-02-13T02:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/02/13/Android/logcat-stat/","link":"","permalink":"http://qiushao.net/2020/02/13/Android/logcat-stat/","excerpt":"","text":"logd 是 Android 的日志系统，其基本构架如下： 本质上也是个 c/s 构架。应用作为客户端往服务端 logd 写数据， logd 作为服务端收到数据后会把数据写到 LogBuf 中。logcat 作为另外一个客户端，从 LogBuf 中读取数据。这个其实也是个生产者/消费者模型。应用可以看作生产者，logcat 可以看作是消费者，logd 可以看作是消息队列。LogBuf 也是有一定大小限制的，当生产者写入 log 的速度太快，超出了 LogBuf 的容量，消费者 logcat 没来得及读取， 部分 log 就会被丢弃，因此有时候我们用 logcat 看日志可能会看不到我们关心日志。出现这种情况时，我们有两种方法来解决： logcat -G 50M 加大 LogBuf 的缓冲区，logcat -g 可以查看当前的缓冲区大小。 logcat &gt; /data/test.log 重定向到文件中，因为写入文件的速度远远大于写到终端的速度，这样可以加快消费者 logcat 的处理速度。 虽然我们可以通过以上两种方法来解决 log 丢失的问题，但我觉得本质上还是 log 太多了，应该要从根本上解决问题才行。而且 log 太多还会影响系统的性能。因此我们的目标是尽量减少 log 的输出。为了达到我们的目标，我们首先要统计一下哪些进程输出的 log 最多，然后制定一套 log 输出规范，让各应用负责人按规范执行。幸好，logd 已经帮我们统计了各进程的输出信息了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150pure:&#x2F; # logcat -Ssize&#x2F;num main system crash TotalTotal 813814&#x2F;6044 241364&#x2F;2849 0&#x2F;0 1055178&#x2F;8893Now 810598&#x2F;6038 234585&#x2F;2794 1045183&#x2F;8832Logspan 2:17.291 2:12.983 2:17.646Overhead 1148726 391049 1712031# main log buffer 按 UID 来统计的数据， Pruned 意思是被丢弃的行数。Chattiest UIDs in main log buffer: Size +&#x2F;- PrunedUID PACKAGE BYTES NUM1000 system 212928 0.7% 15 PID&#x2F;UID COMMAND LINE &quot; &quot; 1694&#x2F;1000 system_server 174427 9 1406&#x2F;1000 &#x2F;system&#x2F;bin&#x2F;hwservicemanager 9934 1545&#x2F;1000 &#x2F;system&#x2F;bin&#x2F;surfaceflinger 5283 1519&#x2F;1000 ...ndroid.hardware.graphics.allocator@2.0-service 3588 61047 cameraserver 1082451073 network_stack 77144 110039 com.android.calllogbackup 742030 root 659471001 radio 452191046 mediacodec 2850610078 com.android.systemui 2715910087 com.android.launcher3 1332810036 com.android.providers.media 108451041 audioserver 689310091 com.android.camera2 676710092 com.android.gallery3d 633210079 com.android.dialer 5686 +17%10090 com.android.calendar 466850039 com.android.calllogbackup 422050036 com.android.providers.media 42151013 media 349450101 com.android.webview 340110095 com.android.inputmethod.latin 3314 110056 com.android.messaging 282310052 com.android.permissioncontroller 2329# system log buffer 中按 UID 统计的数据Chattiest UIDs in system log buffer: Size +&#x2F;- PrunedUID PACKAGE BYTES NUM1000 system 181697 +0.3% 550 root 28799 -3.1% 201001 radio 15940 -1.4% 710078 com.android.systemui 257910097 com.android.email 25571010 wifi 2299# 根据 PID 进程号来统计的数据Chattiest PIDs: Size Pruned PID&#x2F;UID COMMAND LINE BYTES NUM 1694&#x2F;1000 system_server 416009 64 2519&#x2F;1001 com.android.phone 387115 111 2458&#x2F;1073 com.android.networkstack 75058 1 2830&#x2F;10039 android.process.acore 74329 1560&#x2F;1047 &#x2F;system&#x2F;bin&#x2F;cameraserver 29999 2282&#x2F;10078 com.android.systemui 29965 1410&#x2F;0 &#x2F;system&#x2F;bin&#x2F;vold 28365 20 1599&#x2F;1001 &#x2F;vendor&#x2F;bin&#x2F;hw&#x2F;rild 28060 1593&#x2F;1046 media.codec 24754 1564&#x2F;0 &#x2F;system&#x2F;bin&#x2F;installd 17057 2970&#x2F;10087 com.android.launcher3 13858 1502&#x2F;0 &#x2F;system&#x2F;bin&#x2F;netd 12354 3080&#x2F;10036 android.process.media 11172 1503&#x2F;0 zygote64 10013 1406&#x2F;1000 &#x2F;system&#x2F;bin&#x2F;hwservicemanager 9934 1559&#x2F;0 &#x2F;system&#x2F;bin&#x2F;bpfloader 9312 1504&#x2F;0 zygote 7089 3311&#x2F;10091 com.android.camera2 6767 3715&#x2F;10092 com.android.gallery3d 5692 2803&#x2F;10079 com.android.dialer 5686 1545&#x2F;1000 &#x2F;system&#x2F;bin&#x2F;surfaceflinger 5296 3286&#x2F;10090 com.android.calendar 4668 1479&#x2F;0 &#x2F;system&#x2F;bin&#x2F;apexd 4317# 根据 TID 线程号来统计的数据Chattiest TIDs: Size Pruned TID&#x2F;UID COMM BYTES NUM 2519&#x2F;1001 m.android.phon 237838 20 1694&#x2F;1000 system_server 137970 4 3381&#x2F;10039 Worker-1 71269 2458&#x2F;1073 id.networkstac 61782 1 1752&#x2F;1000 ActivityManager 46670 2663&#x2F;1001 HwBinder:2519_1 42183 1746&#x2F;1000 android.display 32051 1560&#x2F;1047 &#x2F;system&#x2F;bin&#x2F;cameraserver 29999 1751&#x2F;1000 android.bg 25443 3 3029&#x2F;1001 Binder:2519_F 23697 35 2282&#x2F;10078 com.android.systemui 23594 1822&#x2F;1000 NetworkWatchlis 19234 1593&#x2F;1046 android.hardwar 19122 1599&#x2F;1001 &#x2F;vendor&#x2F;bin&#x2F;hw&#x2F;rild 18694 1753&#x2F;1000 ActivityManager 17815 2908&#x2F;1001 Binder:2519_E 15796 26 2350&#x2F;1000 Binder:1694_4 14960 2672&#x2F;1001 DcHandlerThread 14187 1410&#x2F;0 &#x2F;system&#x2F;bin&#x2F;vold 12270 20 2390&#x2F;1000 Binder:1694_5 11318 6 1719&#x2F;1000 Binder:1694_2 11307 7 2970&#x2F;10087 re-initialized&gt; 10815 2565&#x2F;1000 Binder:1694_8 10600 2 2246&#x2F;1000 ConnectivitySer 10283 1 1406&#x2F;1000 hwservicemanage 9934 2729&#x2F;1001 Binder:2519_7 9717 17 1503&#x2F;0 main 9704 2243&#x2F;1000 ClientModeImpl 9314 1559&#x2F;0 &#x2F;system&#x2F;bin&#x2F;bpfloader 9312 2780&#x2F;1001 Binder:2519_C 9210 2 1809&#x2F;0 Binder:1564_6 9196 2706&#x2F;1001 CellularNetwork 8211# 根据 TAG 来统计的数据Chattiest TAGs: Size TID&#x2F;PID&#x2F;UID LOG_TAG NAME BYTES StrictMode 235216 dex2oat 103753 2519&#x2F;1001 SubscriptionController 79244 2519&#x2F;1001 SST 65952 2519&#x2F;1001 RILJ 47862 2519&#x2F;1001 DCT-C 44175 1694&#x2F;1000 PackageManager 39750 ServiceManagement 36339 &#x2F;1047 android.hardware.camera.provider@2.4-service 34224 1410&#x2F;0 vold 27758 1694&#x2F;1000 ActivityManager 27459 1694&#x2F;1000 PackageManager.DexOptimizer 26189 RefBase 26097 sysui_multi_action 22173 2519&#x2F;1001 IccSmsInterfaceManager 17960 1564&#x2F;0 installd 16945 1593&#x2F;1046 MediaCodecsXmlParser 166742663&#x2F;2519&#x2F;1001 RilRequest 16612 2519&#x2F;1001 DC-C-1 14478 2282&#x2F;10078 KeyguardUpdateMonitor 14429 1694&#x2F;1000 Telecom 14258 2519&#x2F;1001 TelecomFramework 14039 1599&#x2F;1001 RIL 13184 &lt;NULL&gt; 13046 &#x2F;1047 CamPrvdr@2.4-legacy 11868 1599&#x2F;1001 AT 11835 1694&#x2F;1000 SystemServerTiming 11492 ServiceManager 10807 1694&#x2F;1000 system_server 10281 1406&#x2F;1000 hwservicemanager 9934 1559&#x2F;0 LibBpfLoader 9169 2519&#x2F;1001 NRM-C 9072pure:&#x2F; # 统计结果我们可以分为几个维度来解读： uid 用户id，这个数据我们可以不用关注 pid 进程号，从上面的例子看 system_server 进程的 log 最多，有 416009 bytes tid 线程号，从上面的例子看 com.android.phone 这个线程的 log 最多， 有 237838 bytes。 TAG 从上面的例子看 StrictMode 这个 TAG 的 log 最多， 有 235216 bytes。","categories":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android-emmc性能测试","slug":"Android/emmc-performance-test","date":"2020-02-12T02:00:00.000Z","updated":"2020-12-27T01:22:23.740Z","comments":true,"path":"2020/02/12/Android/emmc-performance-test/","link":"","permalink":"http://qiushao.net/2020/02/12/Android/emmc-performance-test/","excerpt":"","text":"在 Android 可以用来测试 emmc io 性能的工具有很多， 比如 fio, iozone, dd 等。 看了大半天的 fio, iozone， 感觉用起来比较复杂，相对来说还是使用 dd 简单方便。接下来我们就以 dd 为主介绍一下如何测试 emmc 的 io 性能。 1. 页面缓存在开始之前，我们先了解一下页面缓存的概念。简单的说就是系统会把读取过的部分文件缓存到内存中，以此加快热点文件的读取速度，提高磁盘的 IO 速度。具体的原理见 Linux内核文件Cache机制。为了测试 emmc 的真实读写性能，我们需要先把页面缓存给清理： 1echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches 我们先看看页面缓存的例子： 12345678910111213141516KKHi3751V810:&#x2F; # busybox dd if&#x3D;&#x2F;dev&#x2F;block&#x2F;mmcblk0 of&#x3D;&#x2F;dev&#x2F;null bs&#x3D;1M count&#x3D;10241024+0 records in1024+0 records out1073741824 bytes (1.0GB) copied, 5.023993 seconds, 203.8MB&#x2F;sKKHi3751V810:&#x2F; # KKHi3751V810:&#x2F; # busybox dd if&#x3D;&#x2F;dev&#x2F;block&#x2F;mmcblk0 of&#x3D;&#x2F;dev&#x2F;null bs&#x3D;1M count&#x3D;1024 1024+0 records in1024+0 records out1073741824 bytes (1.0GB) copied, 0.564027 seconds, 1.8GB&#x2F;sKKHi3751V810:&#x2F; # KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches KKHi3751V810:&#x2F; # busybox dd if&#x3D;&#x2F;dev&#x2F;block&#x2F;mmcblk0 of&#x3D;&#x2F;dev&#x2F;null bs&#x3D;1M count&#x3D;1024 1024+0 records in1024+0 records out1073741824 bytes (1.0GB) copied, 5.103213 seconds, 200.7MB&#x2F;sKKHi3751V810:&#x2F; # 连续执行两次同样参数的 dd 命令， 从 /dev/block/mmcblk0 (也就是我们的 emmc) 块设备中读取内容， 写到 /dev/null 。/dev/null 是一个虚拟设备，写入这个路径并不会保存，我们可以认为这个设备的写入速度无限大， 也就是写入速度不会成为这个命令的瓶颈， 我们这个命令主要是为了测试 emmc 的读取速度。可以看到第一次执行的结果是 203.8MB/s， 第二次执行的结果是 1.8GB/s。从这个数据来看，页面缓存极大的提高了热点文件的读取速度。然后我们用 echo 1 &gt; /proc/sys/vm/drop_caches 命令清除一下页面缓存，再执行同样的 dd 命令，发现速度跟第一次差不多了。 2. 写入性能测试我们分为两种情况来测试 2.1 写入块设备cache 分区一般是用来存放 OTA 升级包的，正常状态下挂载失败也不影响系统的正常运行，所以我们拿 cache 分区来作写入测试，先找到 cache 对应的块设备文件 123KKHi3751V810:&#x2F; #ls -l &#x2F;dev&#x2F;block&#x2F;platform&#x2F;soc&#x2F;f9830000.emmc&#x2F;by-name&#x2F;cache &lt;lrwxrwxrwx 1 root root 21 1970-01-01 08:00 &#x2F;dev&#x2F;block&#x2F;platform&#x2F;soc&#x2F;f9830000.emmc&#x2F;by-name&#x2F;cache -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p18KKHi3751V810:&#x2F; # cache 分区的块设备文件为 /dev/block/mmcblk0p18。写入测试： 123456KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches KKHi3751V810:&#x2F; # busybox dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;dev&#x2F;block&#x2F;mmcblk0p18 bs&#x3D;1M count&#x3D;1024 conv&#x3D;fsync 1024+0 records in1024+0 records out1073741824 bytes (1.0GB) copied, 24.122624 seconds, 42.4MB&#x2F;sKKHi3751V810:&#x2F; # 输入文件为 /dev/zero，是一个虚拟设备，我们可以认为这个设备的读取速度无限大，也就是读取速度不会影响到写入的速度。bs=1M : 一次写入 1Mcount=1024 : 写入 1024 次，也就是写入的数据总量为 1Gconv=fsync : dd 结束前，把数据同步到 emmc，如果没加这个参数的话，数据可能还在缓存之中。为了确保数据准确，一定要加这个参数。 重复测试几次，速度基本在 42M/s 左右。 2.2 写入文件123456KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_cachesKKHi3751V810:&#x2F; # busybox dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;data&#x2F;ddtest.bin bs&#x3D;1M count&#x3D;1024 conv&#x3D;fsync &lt;1024+0 records in1024+0 records out1073741824 bytes (1.0GB) copied, 30.607905 seconds, 33.5MB&#x2F;sKKHi3751V810:&#x2F; # 重复测试几次，速度基本在 33M/s 左右。相对直接写块设备文件慢了 10M/s 左右。这可能是文件系统带来的影响。 3. 读取测试3.1 读取块设备直接用我们上面介绍清除缓存的例子就行，这里就不再重复了。从上面的例子得到的数据为 203M/s 左右。 3.1 读取文件123456KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches KKHi3751V810:&#x2F; # busybox dd if&#x3D;&#x2F;data&#x2F;ddtest.bin of&#x3D;&#x2F;dev&#x2F;null bs&#x3D;1M count&#x3D;10241024+0 records in1024+0 records out1073741824 bytes (1.0GB) copied, 4.915286 seconds, 208.3MB&#x2F;sKKHi3751V810:&#x2F; # 直接拿测试写入速度时生成的文件，重复测试几次，速度基本上在 208MB/s 左右。 4. 对比iozoneAndroid 系统源码中并没有 iozone，我们得自己人官网上下载编译，我下载时最新版本为 iozone3_489， 这个版本已经有 Android.mk 在代码里面了， 将源码放到 Android 系统源码里面 mm 即可。随机读写测试： 12345678910111213141516171819202122232425262728293031323334353637383940KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_cachesKKHi3751V810:&#x2F; # iozone -azecI -+n -L64 -S32 -r1m -s1024m -i0 -i2 -w -f &#x2F;data&#x2F;iozonetest.bin Iozone: Performance Test of File I&#x2F;O Version $Revision: 3.489 $ Compiled for 64 bit mode. Build: linux-arm Contributors:William Norcott, Don Capps, Isom Crawford, Kirby Collins Al Slater, Scott Rhine, Mike Wisner, Ken Goss Steve Landherr, Brad Smith, Mark Kelly, Dr. Alain CYR, Randy Dunlap, Mark Montague, Dan Million, Gavin Brebner, Jean-Marc Zucconi, Jeff Blomberg, Benny Halevy, Dave Boone, Erik Habbinga, Kris Strecker, Walter Wong, Joshua Root, Fabrice Bacchella, Zhenghua Xue, Qin Li, Darren Sawyer, Vangel Bojaxhi, Ben England, Vikentsi Lapa, Alexey Skidanov, Sudhir Kumar. Run began: Wed Feb 12 20:47:58 2020 Auto Mode Cross over of record size disabled. Include fsync in write timing Include close in write timing O_DIRECT feature enabled No retest option selected Record Size 1024 kB File size set to 1048576 kB Setting no_unlink Command line used: iozone -azecI -+n -L64 -S32 -r1m -s1024m -i0 -i2 -w -f &#x2F;data&#x2F;iozonetest.bin Output is in kBytes&#x2F;sec Time Resolution &#x3D; 0.000001 seconds. Processor cache size set to 32 kBytes. Processor cache line size set to 64 bytes. File stride size set to 17 * record size. random random bkwd record stride kB reclen write rewrite read reread read write read rewrite read fwrite frewrite fread freread 1048576 1024 74782 0 199299 71520 iozone test complete.KKHi3751V810:&#x2F; # 从结果来看，随机读速度为 199299 kB/s , 大概为 200M/s。 随机写速度为 71520 kB/s， 大概为 70M/s。重复测试几次结果差不多，读的速度基本跟 dd 的一致。写入的比 dd 的快了将近一倍。 5. 对比fio5.1 写入文件速度123456789101112131415161718192021222324252627282930313233KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches KKHi3751V810:&#x2F; # fio -filename&#x3D;&#x2F;dev&#x2F;block&#x2F;mmcblk0p18 -direct&#x3D;1 -iodepth 1 -thread -rw&#x3D;randwrite -ioengine&#x3D;psync -bs&#x3D;1m -size&#x3D;1G -numjobs&#x3D;4 -runtime&#x3D;60 -group_reporting -name&#x3D;rand_write_1mrand_write_1m: (g&#x3D;0): rw&#x3D;randwrite, bs&#x3D;1M-1M&#x2F;1M-1M&#x2F;1M-1M, ioengine&#x3D;psync, iodepth&#x3D;1...fio-2.2.6Starting 4 threadsJobs: 3 (f&#x3D;3): [w(3),_(1)] [98.1% done] [0KB&#x2F;80734KB&#x2F;0KB &#x2F;s] [0&#x2F;78&#x2F;0 iops] [eta 00m:01s]rand_write_1m: (groupid&#x3D;0, jobs&#x3D;4): err&#x3D; 0: pid&#x3D;8316: Wed Feb 12 21:03:34 2020 write: io&#x3D;4096.0MB, bw&#x3D;83067KB&#x2F;s, iops&#x3D;81, runt&#x3D; 50493msec clat (msec): min&#x3D;10, max&#x3D;1361, avg&#x3D;48.60, stdev&#x3D;44.45 lat (msec): min&#x3D;10, max&#x3D;1361, avg&#x3D;48.86, stdev&#x3D;44.44 clat percentiles (msec): | 1.00th&#x3D;[ 18], 5.00th&#x3D;[ 22], 10.00th&#x3D;[ 23], 20.00th&#x3D;[ 26], | 30.00th&#x3D;[ 34], 40.00th&#x3D;[ 37], 50.00th&#x3D;[ 46], 60.00th&#x3D;[ 48], | 70.00th&#x3D;[ 58], 80.00th&#x3D;[ 65], 90.00th&#x3D;[ 76], 95.00th&#x3D;[ 87], | 99.00th&#x3D;[ 104], 99.50th&#x3D;[ 114], 99.90th&#x3D;[ 758], 99.95th&#x3D;[ 1123], | 99.99th&#x3D;[ 1369] bw (KB &#x2F;s): min&#x3D; 1343, max&#x3D;41353, per&#x3D;25.49%, avg&#x3D;21171.93, stdev&#x3D;4637.55 lat (msec) : 20&#x3D;1.51%, 50&#x3D;60.52%, 100&#x3D;36.40%, 250&#x3D;1.37%, 500&#x3D;0.02% lat (msec) : 750&#x3D;0.05%, 1000&#x3D;0.05%, 2000&#x3D;0.07% cpu : usr&#x3D;0.43%, sys&#x3D;1.13%, ctx&#x3D;10620, majf&#x3D;0, minf&#x3D;6 IO depths : 1&#x3D;100.0%, 2&#x3D;0.0%, 4&#x3D;0.0%, 8&#x3D;0.0%, 16&#x3D;0.0%, 32&#x3D;0.0%, &gt;&#x3D;64&#x3D;0.0% submit : 0&#x3D;0.0%, 4&#x3D;100.0%, 8&#x3D;0.0%, 16&#x3D;0.0%, 32&#x3D;0.0%, 64&#x3D;0.0%, &gt;&#x3D;64&#x3D;0.0% complete : 0&#x3D;0.0%, 4&#x3D;100.0%, 8&#x3D;0.0%, 16&#x3D;0.0%, 32&#x3D;0.0%, 64&#x3D;0.0%, &gt;&#x3D;64&#x3D;0.0% issued : total&#x3D;r&#x3D;0&#x2F;w&#x3D;4096&#x2F;d&#x3D;0, short&#x3D;r&#x3D;0&#x2F;w&#x3D;0&#x2F;d&#x3D;0, drop&#x3D;r&#x3D;0&#x2F;w&#x3D;0&#x2F;d&#x3D;0 latency : target&#x3D;0, window&#x3D;0, percentile&#x3D;100.00%, depth&#x3D;1Run status group 0 (all jobs): WRITE: io&#x3D;4096.0MB, aggrb&#x3D;83067KB&#x2F;s, minb&#x3D;83067KB&#x2F;s, maxb&#x3D;83067KB&#x2F;s, mint&#x3D;50493msec, maxt&#x3D;50493msecDisk stats (read&#x2F;write): mmcblk0: ios&#x3D;54&#x2F;8332, merge&#x3D;5&#x2F;888, ticks&#x3D;60872&#x2F;378355, in_queue&#x3D;439181, util&#x3D;100.00%KKHi3751V810:&#x2F; # 4个线程的平均写入速度为 bw=83067KB/s，大概是 80M/s， 比 dd 也快了一倍多。 5.2 读取文件速度123456789101112131415161718192021222324252627282930313233KKHi3751V810:&#x2F; # echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches KKHi3751V810:&#x2F; # fio -filename&#x3D;&#x2F;dev&#x2F;block&#x2F;mmcblk0 -direct&#x3D;1 -iodepth 1 -thread -rw&#x3D;randread -ioengine&#x3D;psync -bs&#x3D;1m -size&#x3D;1G -numjobs&#x3D;4 -runtime&#x3D;60 -group_reporting -name&#x3D;rand_read_1mrand_read_1m: (g&#x3D;0): rw&#x3D;randread, bs&#x3D;1M-1M&#x2F;1M-1M&#x2F;1M-1M, ioengine&#x3D;psync, iodepth&#x3D;1...fio-2.2.6Starting 4 threadsJobs: 1 (f&#x3D;1): [_(3),r(1)] [96.2% done] [148.5MB&#x2F;0KB&#x2F;0KB &#x2F;s] [148&#x2F;0&#x2F;0 iops] [eta 00m:01s] rand_read_1m: (groupid&#x3D;0, jobs&#x3D;4): err&#x3D; 0: pid&#x3D;7889: Wed Feb 12 20:56:21 2020 read : io&#x3D;4096.0MB, bw&#x3D;171813KB&#x2F;s, iops&#x3D;167, runt&#x3D; 24412msec clat (msec): min&#x3D;4, max&#x3D;9350, avg&#x3D;19.50, stdev&#x3D;215.06 lat (msec): min&#x3D;4, max&#x3D;9350, avg&#x3D;19.50, stdev&#x3D;215.06 clat percentiles (msec): | 1.00th&#x3D;[ 7], 5.00th&#x3D;[ 8], 10.00th&#x3D;[ 8], 20.00th&#x3D;[ 11], | 30.00th&#x3D;[ 11], 40.00th&#x3D;[ 11], 50.00th&#x3D;[ 11], 60.00th&#x3D;[ 14], | 70.00th&#x3D;[ 14], 80.00th&#x3D;[ 14], 90.00th&#x3D;[ 14], 95.00th&#x3D;[ 14], | 99.00th&#x3D;[ 16], 99.50th&#x3D;[ 30], 99.90th&#x3D;[ 2638], 99.95th&#x3D;[ 4113], | 99.99th&#x3D;[ 9372] bw (KB &#x2F;s): min&#x3D; 964, max&#x3D;145420, per&#x3D;46.41%, avg&#x3D;79740.53, stdev&#x3D;25495.41 lat (msec) : 10&#x3D;13.77%, 20&#x3D;85.55%, 50&#x3D;0.29%, 100&#x3D;0.12%, 500&#x3D;0.05% lat (msec) : 750&#x3D;0.05%, 2000&#x3D;0.05%, &gt;&#x3D;2000&#x3D;0.12% cpu : usr&#x3D;0.22%, sys&#x3D;3.16%, ctx&#x3D;9195, majf&#x3D;0, minf&#x3D;1030 IO depths : 1&#x3D;100.0%, 2&#x3D;0.0%, 4&#x3D;0.0%, 8&#x3D;0.0%, 16&#x3D;0.0%, 32&#x3D;0.0%, &gt;&#x3D;64&#x3D;0.0% submit : 0&#x3D;0.0%, 4&#x3D;100.0%, 8&#x3D;0.0%, 16&#x3D;0.0%, 32&#x3D;0.0%, 64&#x3D;0.0%, &gt;&#x3D;64&#x3D;0.0% complete : 0&#x3D;0.0%, 4&#x3D;100.0%, 8&#x3D;0.0%, 16&#x3D;0.0%, 32&#x3D;0.0%, 64&#x3D;0.0%, &gt;&#x3D;64&#x3D;0.0% issued : total&#x3D;r&#x3D;4096&#x2F;w&#x3D;0&#x2F;d&#x3D;0, short&#x3D;r&#x3D;0&#x2F;w&#x3D;0&#x2F;d&#x3D;0, drop&#x3D;r&#x3D;0&#x2F;w&#x3D;0&#x2F;d&#x3D;0 latency : target&#x3D;0, window&#x3D;0, percentile&#x3D;100.00%, depth&#x3D;1Run status group 0 (all jobs): READ: io&#x3D;4096.0MB, aggrb&#x3D;171813KB&#x2F;s, minb&#x3D;171813KB&#x2F;s, maxb&#x3D;171813KB&#x2F;s, mint&#x3D;24412msec, maxt&#x3D;24412msecDisk stats (read&#x2F;write): mmcblk0: ios&#x3D;8365&#x2F;46, merge&#x3D;15&#x2F;47, ticks&#x3D;633927&#x2F;61332, in_queue&#x3D;695214, util&#x3D;99.20%KKHi3751V810:&#x2F; # ４个线程的平均读速度为 bw=171813KB/s， 大概为 170M/s。 综合对比 dd, iozone, fio 这几个工具发现，读的速度基本上差不多，但写速度差距比较大，可能跟设置的参数有关。为了简单起见，我们只采用 dd 的结果作为参考数据即可。 参考文章:[IO测试工具之fio详解]:https://www.cnblogs.com/raykuan/p/6914748.html[emmc读写速度性能分析]:https://blog.csdn.net/jekenzhuang/article/details/81142178[dd命令的conv=fsync,oflag=sync/dsync]:https://blog.csdn.net/menogen/article/details/38059671[页面缓存：内存和文件之间的那些事]:https://linux.cn/article-9528-1.html[在 Linux 上如何清除内存的 Cache、Buffer 和交换空间]:https://linux.cn/article-5627-1.html[iozone的使用]:http://wowothink.com/b871283/[eMMC读写性能和稳定性验证]:http://wowothink.com/7ffb6593/","categories":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android-io统计","slug":"Android/iostat","date":"2020-02-11T02:00:00.000Z","updated":"2020-12-27T01:22:23.740Z","comments":true,"path":"2020/02/11/Android/iostat/","link":"","permalink":"http://qiushao.net/2020/02/11/Android/iostat/","excerpt":"","text":"年前遇到客户的板子 emmc 被写坏的问题，当时还没时间去研究分析，现在疫情在家就把之前遇到的问题慢慢研究一下。emmc 是有一定使用寿命的，它的寿命跟擦写次数相关的。正常来说应该在５，６年以上。但这个客户才使用了半年多就坏了。怀疑是某个进程在疯狂的写入磁盘数据，导致擦写次数达到寿命期限。下面介绍一些查看 emmc io 状态的工具方法。我们可以用这些工具方法来查看 emmc 是不是擦写寿命到了，找出到底是哪个应用把 emmc 写坏了。 1. emmc 擦写次数和判断 emmc 使用寿命是否到期方法1.1 适用于大部分机芯：在系统启动之后查看 emmc 擦写次数，串口打印信息输入命令如下： 1cat &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;mmc0&#x2F;mmc0:0001&#x2F;ext_csd 执行命令后会出现一长串的数字，将这些数字拷贝到文本文档中，用文本编辑工具打开，然后查看第537-538位数字/字母（即268byte)。 对于这个数字的解释如下: 如果此值是00，则表示这个机芯不支持这种方法来查询EMMC擦写次数。 01-0A为正常的范围，其他数值都不正常。 这个数值只是百分比，不是明确次数。例如 0x01 表示使用了 0% - 10% 寿命，依次类推。 如果此值是0B，则便是这颗EMMC的擦写次数已经超过最大擦写次数。这种情况EMMC的状态不稳定，可能就会出现开不了机的情况了。 1.2 适合Mstar机芯：开机后一直按住电脑上的Enter键，进入 mboot，然后输入命令 mmc ecsd ，然后查看ecsd[268]的数值，例如ecsd[268]:0x1，表示擦写次数在10%以内。方法2看到的数值和方法1是一致的。只是对于开机启动不了的机芯板来说，更加实用。 1.3 emmc 理论寿命与实际寿命验证emmc 理论寿命可以从 emmc 厂家提供的规则书上获取。我们在实际生产要使用某款 emmc 芯片的之前，都需要对 emmc 的寿命进行验证。一般板子的芯片方案商都会提供验证工具，验证方法。本质上就是暴力写 emmc，看在暴力写入情况下，能写多久。这类实验，测试一次都要进行一两个月左右。 2. 查看系统整体的 io 状态2.1 iostat用法如下： 1234567891011121314KKHi3751V810:&#x2F; # busybox iostat --help BusyBox v1.26.2 (2020-02-10 02:26:18 UTC) multi-call binary.Usage: iostat [-c] [-d] [-t] [-z] [-k|-m] [ALL|BLOCKDEV...] [INTERVAL [COUNT]]Report CPU and I&#x2F;O statistics -c Show CPU utilization -d Show device utilization -t Print current time -z Omit devices with no activity -k Use kb&#x2F;s -m Use Mb&#x2F;sKKHi3751V810:&#x2F; # 比如说我们想查看当前系统的 io 状态，以 kb/s 作为单位: 12345678910111213141516171819KKHi3751V810:&#x2F; # busybox iostat -d -k Linux 4.9.44_s5 (localhost) 02&#x2F;11&#x2F;20 _aarch64_ (4 CPU)Device: tps kB_read&#x2F;s kB_wrtn&#x2F;s kB_read kB_wrtnzram0 0.01 0.02 0.00 176 4mmcblk0 5.21 35.64 47.65 299644 400596mmcblk0p1 0.66 0.00 0.00 0 0mmcblk0p7 0.00 0.00 0.01 0 48mmcblk0p10 0.00 0.00 0.00 32 0mmcblk0p16 0.01 0.05 0.01 402 60mmcblk0p18 0.01 0.10 0.01 806 68mmcblk0p20 0.24 15.19 0.11 127717 928mmcblk0p21 0.02 1.00 0.00 8421 0mmcblk0p22 0.00 0.02 0.00 130 12mmcblk0p23 0.00 0.04 0.01 362 44mmcblk0p25 4.28 19.24 47.51 161774 399436sda 0.03 1.37 0.00 11546 0KKHi3751V810:&#x2F; # 其中 mmcblk0 代码整个 emmc， mmcblk0pxx 代表某个分区， 可以通过以下方法来查找对应的分区： 123456789ls -l &#x2F;dev&#x2F;block&#x2F;platform&#x2F;soc&#x2F;f9830000.emmc&#x2F;by-name&#x2F; &lt;...lrwxrwxrwx 1 root root 21 1970-01-01 08:00 system -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p20lrwxrwxrwx 1 root root 20 1970-01-01 08:00 tconparam -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p8lrwxrwxrwx 1 root root 20 1970-01-01 08:00 trustedcore -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p9lrwxrwxrwx 1 root root 21 1970-01-01 08:00 userdata -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p25lrwxrwxrwx 1 root root 21 1970-01-01 08:00 vendor -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p21lrwxrwxrwx 1 root root 21 1970-01-01 08:00 versioninfo -&gt; &#x2F;dev&#x2F;block&#x2F;mmcblk0p11KKHi3751V810:&#x2F; # 我们看到 mmcblk0p25 对应的是 userdata 分区。综合以上知道当前系统只有 userdata 有写入， 写入速度为 47 KB/s。 2.2 iotopiostat 只能查看系统的整体 io 状态，当 io 状态异常高时， 不能定位是哪个进程引起的问题， 这时我们可以使用 iotop 这个工具来查看每个进程的 io 占用比例。使用方法如下： 1234567891011KKHi3751V810:&#x2F; # iotop --helpUsage: iotop [-h] [-P] [-d &lt;delay&gt;] [-n &lt;cycles&gt;] [-s &lt;column&gt;] -a Show byte count instead of rate -d Set the delay between refreshes in seconds. -h Display this help screen. -m Set the number of processes or threads to show -n Set the number of refreshes before exiting. -P Show processes instead of the default threads. -s Set the column to sort by: pid, read, write, total, io, swap, sched, mem or delay.KKHi3751V810:&#x2F; # 比如我们查看前10个io占用最大的进程，就可以使用以下方法： 1234567891011121314130|KKHi3751V810:&#x2F; # iotop -m 10 -P -s write --- IO (KiB&#x2F;s) --- ----------- delayed on ---------- PID Command read write total IO swap sched mem total 25227 :filedownloader 0 7208 7208 0.00% 0.00% 0.00% 0.00% 0.00% 24323 logcat 0 12 12 0.00% 0.00% 0.00% 0.00% 0.00% 1 init 0 0 0 0.00% 0.00% 0.00% 0.00% 0.00% 2 kthreadd 0 0 0 0.00% 0.00% 0.00% 0.00% 0.00% 3 ksoftirqd&#x2F;0 0 0 0 0.00% 0.00% 0.00% 0.00% 0.00% 5 kworker&#x2F;0:0H 0 0 0 0.00% 0.00% 0.00% 0.00% 0.00% 7 rcu_preempt 0 0 0 0.00% 0.00% 0.00% 0.00% 0.00% 8 rcu_sched 0 0 0 0.00% 0.00% 0.00% 0.00% 0.00% 9 rcu_bh 0 0 0 0.00% 0.00% 0.00% 0.00% 0.00% 10 migration&#x2F;0 0 0 0 0.00% 0.00% 0.00% 0.00% 0.00% TOTAL 0 7220 7220 0 12 12 从结果可以看到 25227 :filedownloader 这个进程 io 占用最高，写入速度为 7208KB/s。因为这时我正在下载文件。 3. 查看某个进程的 io 总量iotop 只可以查看某个时间点的 io 速率， 我们需要统计某个进程总共的 io 总量时就得使用 cat /proc/$pid/io 这个方法了。 123456789KKHi3751V810:&#x2F;proc&#x2F;25227 # cat iorchar: 170665wchar: 81578559syscr: 555syscw: 13095read_bytes: 36864write_bytes: 82153472cancelled_write_bytes: 0KKHi3751V810:&#x2F;proc&#x2F;25227 # 各字段的解析如下：rchar: 170665 // 读出的总字节数，read()或者pread()中的长度参数总和(pagecache中统计而来，不代表实际磁盘的读入)wchar: 81578559 // 写入的总字节数，write()或者pwrite()中的长度参数总和syscr: 555 // read()或者pread()总的调用次数syscw: 13095 // write()或者pwrite()总的调用次数read_bytes: 36864 // 实际从磁盘中读取的字节总数write_bytes: 82153472 // 实际写入到磁盘中的字节总数cancelled_write_bytes: 0 // 由于截断pagecache导致应该发生而没有发生的写入字节数 实际写入磁盘的数据总量为 write_bytes: 82153472 字节。 4. 查看某个进程打开的文件当我们发现某个进程的 io 异常时，想了解一下这个进程是在对哪个文件进行读写导致的，可以使用以下方法： 12345678KKHi3751V810:&#x2F;proc&#x2F;24323&#x2F;fd # ls -ltotal 0lrwx------ 1 root root 64 2020-02-11 12:50 0 -&gt; &#x2F;dev&#x2F;pts&#x2F;0l-wx------ 1 root root 64 2020-02-11 12:50 1 -&gt; &#x2F;data&#x2F;io.loglrwx------ 1 root root 64 2020-02-11 12:50 12 -&gt; socket:[9872]lrwx------ 1 root root 64 2020-02-11 12:50 2 -&gt; &#x2F;dev&#x2F;pts&#x2F;0lrwx------ 1 root root 64 2020-02-11 12:28 3 -&gt; socket:[382495]KKHi3751V810:&#x2F;proc&#x2F;24323&#x2F;fd # /proc/$pid/fd 目录下保存了这个进程打开的所有文件描述符。我们可以用 ls -l 来查看这些文件描述符指向的实际文件。这个例子中文件描述符 1 就表示文件 /data/io.log。我们再通过 strace 来查看某个进程的系统调用，看看是不是一直在调用 write 接口写文件 12345678910111213KKHi3751V810:&#x2F;proc&#x2F;24323&#x2F;fd # strace -p 24323 strace: Process 24323 attachedrecvfrom(3, &quot;\\204\\0\\34\\0\\302k\\0\\0\\302k\\0\\0\\3053B^\\200\\263&#125;\\34\\0\\0\\0\\0\\0\\0\\0\\0\\4str&quot;..., 5120, 0, NULL, NULL) &#x3D; 160write(1, &quot;02-11 12:55:33.478 27586 27586 I&quot;..., 167) &#x3D; 167recvfrom(3, &quot;\\264\\0\\34\\0\\302k\\0\\0\\302k\\0\\0\\3053B^@z\\253\\34\\0\\0\\0\\0\\0\\0\\0\\0\\4str&quot;..., 5120, 0, NULL, NULL) &#x3D; 208write(1, &quot;02-11 12:55:33.481 27586 27586 I&quot;..., 215) &#x3D; 215recvfrom(3, &quot;\\r\\1\\34\\0\\224\\n\\0\\0\\320\\f\\0\\0\\3063B^CS\\303\\22\\3\\0\\0\\0\\350\\3\\0\\0\\5Con&quot;..., 5120, 0, NULL, NULL) &#x3D; 297write(1, &quot;02-11 12:55:34.314 2708 3280 W&quot;..., 302) &#x3D; 302recvfrom(3, &quot;r\\0\\34\\0u\\10\\0\\0\\275\\t\\0\\0\\3063B^\\354\\253\\327\\22\\3\\0\\0\\0\\350\\3\\0\\0\\3AMS&quot;..., 5120, 0, NULL, NULL) &#x3D; 142write(1, &quot;02-11 12:55:34.316 2165 2493 D&quot;..., 152) &#x3D; 152recvfrom(3, &quot;i\\4\\34\\0u\\10\\0\\0\\275\\t\\0\\0\\3063B^\\307&#96;\\350\\22\\0\\0\\0\\0\\350\\3\\0\\0\\5Pac&quot;..., 5120, 0, NULL, NULL) &#x3D; 1157write(1, &quot;02-11 12:55:34.317 2165 2493 W&quot;..., 1749) &#x3D; 1749madvise(0x7a6ac2e000, 28672, MADV_DONTNEED) &#x3D; 0 从以上 log 看，我们知道 24323 这个进程一直在往文件描述符 1 里面写内容， 而从 ls -l /proc/24323/fd 的结果中我们知道文件描述符 1 代表的是 /data/io.log 文件。我们从 log 上还可以看出写入的部分内容和数据大小。 至此，所有的工具都介绍完啦，以后再遇到 io 的问题，我们就可以灵活运用这些工具来分析问题了。","categories":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android-服务阻塞调试小技巧","slug":"Android/android-service-debug-skill","date":"2020-02-09T02:00:00.000Z","updated":"2020-12-27T01:22:23.740Z","comments":true,"path":"2020/02/09/Android/android-service-debug-skill/","link":"","permalink":"http://qiushao.net/2020/02/09/Android/android-service-debug-skill/","excerpt":"","text":"最近遇到好几起系统服务阻塞，导致应用ANR的问题。还好胖增找到一个调试此类问题的技巧：打印服务进程的堆栈信息。服务阻塞一般来说有两种情况：1. 耗时工作。 2. 死锁。如果我们单纯从 logcat 日志分析的话，有时候感觉无从下手。如果我们能从服务进程的内部窥视服务内部到底都在干什么的话，那我们就能够快速找到问题的原因了。打印进程堆栈信息的目的就是为了能够窥视服务内部到底在干什么活。堆栈信息描述了某个进程的所有线程的执行状态，是空闲，还是在执行某段代码，还是等待某个锁。我们有两种方法来触发进程堆栈信息的打印。 kill -3 $pid这种方法适用于 java 进程， 比如 system_server 进程。使用这个命令后，会在 /data/anr 下生成 trace 文件。 debuggerd -b $pid这种方法适用于 native 进程，比如 audioserver 进程。使用这个命令后，直接在终端输出进程的堆栈信息了","categories":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发进阶-Android编译系统介绍","slug":"Android系统开发进阶/Android编译系统介绍","date":"2020-02-06T02:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/02/06/Android系统开发进阶/Android编译系统介绍/","link":"","permalink":"http://qiushao.net/2020/02/06/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/Android%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"1. 编译系统变化Android 最初是用 Android.mk 来定义模块的， Android.mk 本质上就是 Makefile。随着 Android 工程越来越大，包含的模块越来越多，以 Makefile 组织的项目编译花费的时间越来越多。google 在 Android 7.0 开始引入了 ninja 编译系统。相对于 make 来说 ninja 在大的项目管理中速度和并行方面有突出的优势，因此 google 采用了 ninja 来取代之前使用的 make。关于 ninja 的介绍，请参考 ninja 构建系统 和 ninja 官方说明文档。由于 Android.mk 的数量巨大且复杂，不可能把所有的 Android.mk 改写成 ninja 的构建规则，因此 google 搞了个 kati 工具，用于将 Androd.mk 转换成 ninja 的构建规则文件 build.ninja，再使用 ninja 来进行构建工作。 Android 8.0 开始，google 引入了 Android.bp 文件来替代之前的 Android.mk 文件，Android.bp 只是纯粹的配置文件，不包括分支、循环等流程控制， 本质上就是一个 json 配置文件。同时还引入 Soong 这个工具，用于将 Android.bp 转换为 ninja 的构建规则文件 build.ninja，再使用 ninja 来进行构建工作。但之前的模块全部是用 Android.mk 来定义的，google 不可能一下子把所有模块都修改成 Android.bp，只能逐步替换，目前 Android 10 上还有少部分 Android.mk 的模块，按这进度，估计要到 Android 12 才能完全替换成 Android.bp 了。无论是 Android.mk 还是 Android.bp 最后都是转化成 ninja 的构建规则，再进行编译的。 各种文件跟工具的关系如下： 2. 编译参数配置Android编译系统的配置，可以分为三个层级，从下到上依次是: 2.1 平台级(Board)参数配置平台级配置主要在 BoardConfig.mk 文件中参数主要有以下几个类别的配置： CPU 体系结构: TARGET_ARCH, TARGET_CPU_ABI, TARGET_ARCH_VARIANT等。配置 CPU 是 x86 架构还是 arm 架构， arm 架构下又分好几个版本。编译系统会根据这个配置去加载对应 CPU 构架的 mk:build/core/combo/arch/$(TARGET_ARCH)/$(TARGET_ARCH_VARIANT).mk 内核参数配置： BOARD_KERNEL_BASE， BOARD_KERNEL_PAGESIZE， BOARD_KERNEL_CMDLINE 等， 这些参数最终会被打包到 boot 分区的镜像文件中(boot.img)，作为内核的启动参数。 分区镜像: TARGET_USERIMAGES_USE_EXT4, BOARD_BOOTIMAGE_PARTITION_SIZE, BOARD_SYSTEMIMAGE_PARTITION_SIZE 等与分区格式、分区大小相关的参数。system， vendor 等分区的大小就是在这里面配置的。 外设参数配置： 蓝牙， wifi 等外接设备的参数配置。 2.2 产品级(Product)的参数配置同一块板子可以做不同的产品，各产品之间的差异主要是软件方面的差异，比如内置的应用不一样， 默认语言不一样等。AndroidProducts.mk 文件中的 PRODUCT_MAKEFILES 列出了所有产品的配置文件。每一个产品都会有一个对应的 $(PRODUCT_NAME).mk 文件， 这个产品的所有配置都在里面列出，主要的配置项目如下： PRODUCT_NAME : 产品名， 我们通过 lunch 选择的产品， 就要与这个配置保持一致, 同时产品的 mk 文件也要命名为 $(PRODUCT_NAME).mk。 PRODUCT_DEVICE : 板子的名称，编译系统会使用该名称查找 BoardConfig.mk。产品的输出目录也是根据该名称创建 out/target/product/$PRODUCT_DEVICE。 PRODUCT_BRAND ： 对软件进行自定义所针对的品牌（如果有），例如运营商。 PRODUCT_MANUFACTURER ： 制造商的名称， 会赋值给 ro.product.manufacturer 属性。 PRODUCT_MODEL ： 最终产品的最终用户可见名称， 或者叫机型名。 PRODUCT_LOCALES ： 以空格分隔的列表，用于列出由双字母语言代码和双字母国家/地区代码组成的代码对，以便说明针对用户的一些设置，例如界面语言和时间、日期以及货币格式。PRODUCT_LOCALES 中列出的第一个语言区域会被用作产品的默认语言区域。 PRODUCT_PACKAGES : 列出要安装的 APK 和模块。 PRODUCT_COPY_FILES : 预置文件列表，例如 source_path:destination_path。在编译相应产品时，应将源路径下的文件复制到目标路径。 PRODUCT_PROPERTY_OVERRIDES : 系统属性列表（采用“key=value”格式）列表。 PRODUCT_PACKAGE_OVERLAYS ： 资源 overlay 目录。 以上是一个产品的常见配置， 基本上每一个产品都会用到这些配置， 作为一个系统 rom 开发者， 我们要非常熟悉这些配置的作用。对于产品的配置还有一个重要的配置：编译类型（TARGET_BUILD_TYPE）， 这个配置是我们在 lunch 选择要编译的产品的时候选择的。我们在添加产品的时候有以下配置，把产品添加到 lunch 的选择列表中，其中的形式就是 $(PRODUCT_NAME)-$(TARGET_BUILD_TYPE) 1234COMMON_LUNCH_CHOICES :&#x3D; \\ pure-eng \\ pure-userdebug \\ pure-user 编译类型的取值范围为：eng, user, userdebug。这三者的区别如下： eng 工程师版本， 主要用于开发调试阶段: 安装带有 eng 或 debug 标记的模块。 除了带有标记的模块之外，还会根据产品定义文件安装相应模块。 ro.secure=0 ro.debuggable=1 ro.kernel.android.checkjni=1 adb 默认处于启用状态。 WITH_DEXPREOPT 可以设置为 false， 即在编译时不对系统映像上安装的 DEX 代码调用 dex2oat。 具体作用下面单独讲。 user 用户发布版本: 安装带有 user 标记的模块。 除了带有标记的模块之外，还会根据产品定义文件安装相应模块。 ro.secure=1 ro.debuggable=0 adb 默认处于停用状态。 WITH_DEXPREOPT 只能为 true， 不能设置为 false。 userdebug 用户调试版本， 除了以下几点之外，其余均与 user 相同： 还会安装带有 debug 标记的模块。 ro.debuggable=1 adb 默认处于启用状态。 WITH_DEXPREOPT 意思为预优化， 也就是把 Android 在启动或 APP 在运行时所需要做的一些事情，把这些事情转移到编译 APK 时完成，来达到更快的 Android 系统启动速度和更快的APP运行速度。Android 在首次启动和首次安装应用时，需要将字节码翻译成机器码，这样 Android 系统的启动速度将会大大减慢，如果没有预优化，APP 的运行速度也会加上翻译所需要的时间。所以，这个翻译的工作需要转移到编译上面来，也就是所，在编译 APK 文件时，将会预先对 APK 进行翻译的优化，然后再打包到系统里面去，这样 Android 系统在首次启动时，就不再需要花费大量的时间去翻译 APK 的字节码。 WITH_DEXPREOPT 虽然能够提高系统的首次开机速度和APP的首次运行速度， 但是会大大增加镜像的大小，从经验上来看，会增加1.5倍左右。而且 jar 经过预优化之后， 就没法简单的直接替换生效了。我们在开发过程经常需要修改 framework.jar, services.jar 等， 如果系统不是 eng 版本，替换之后是不生效的， 需要重新编译升级。所以为了提高开发验证速度， 我们需要替换 jar 包的话，就要使用 eng 版本的系统。 2.3 模块级(Module)参数配置目前模块配置有两种形式，Android.mk 和 Android.bp。这两种模块定义系统是独立的，也就是 Android.mk 中定义的模块，不能被 Android.bp 中的模块依赖。 我们分别讨论一下这两种模块配置形式。 2.3.1 Android.mk一个模块最基本的四个要素为：模块名， 源文件列表， 依赖关系， 模块类型。对于 Android.mk 模块来说，这几个基本要素的配置方法如下： 1234567LOCAL_PATH :&#x3D; $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE :&#x3D; hello # 模块名LOCAL_SRC_FILES :&#x3D; hello.cpp # 源文件列表LOCAL_SHARED_LIBRARIES :&#x3D; liblog # 依赖关系LOCAL_xxx :&#x3D; xxx include $(BUILD_EXECUTABLE) # 模块类型 一个模块通常以以下两行配置作为开头： 12LOCAL_PATH :&#x3D; $(call my-dir) include $(CLEAR_VARS) 这两行配置的作用是： 设置当前模块的编译路径为当前文件夹路径。 清理（可能由其他模块设置过的）编译环境中用到的变量。具体来说是重置除了 LOCAL_PATH 之外的所有以 LOCAL_ 开头的编译环境变量。 Android 源码是一个非常庞大的系统，包含了成千上万个模块，各模块之间的依赖关系也很复杂。为了方便模块的编译， Android 开发团队最初在 Makefile 的基础上，开发了一套编译系统，在这套编译系统下，我们要定义一个模块变得非常简单，只需要定义一系列的编译环境变量就行了，根本不用关心具体的编译细节。下面举例解析一下部分重要的编译环境变量： LOCAL_MODULE：当前模块的名称，这个名称在系统中应当是唯一的，模块间的依赖关系就是通过这个名称来引用的。编译系统会自动添加适当的后缀。例如，libfoo，要产生动态库，则生成libfoo.so。 LOCAL_SRC_FILES：当前模块包含的所有源代码文件。 LOCAL_C_INCLUDES：C 或 C++ 语言需要的头文件的路径。 LOCAL_STATIC_LIBRARIES：当前模块依赖的静态库。 LOCAL_SHARED_LIBRARIES：当前模块依赖的动态库。 LOCAL_CFLAGS：提供给 C/C++ 编译器的额外编译参数。 LOCAL_JAVA_LIBRARIES：当前模块依赖的 Java 共享库。 LOCAL_STATIC_JAVA_LIBRARIES：当前模块依赖的 Java 静态库。 LOCAL_CERTIFICATE： APK 签名类型。 LOCAL_DEX_PREOPT： 禁止对当前模块进行预优化。 LOCAL_JACK_ENABLED： 禁止使用Jack编译工具链编译该模块。 LOCAL_MODULE_TAGS：当前模块所包含的标签，一个模块可以包含多个标签。标签的值可能是 user，eng, debug, optional。其中，optional 是默认标签。标签是提供给编译类型使用的。具体的规则见上面的 2.2 小节（产品级(Product)的参数配置 ）中对编译类型的解析。 在 Android 10 中取消了 eng, debug 这两种类型，具体说明见路径 Android/build/make/Changes.md 中的说明。 除此以外，Build 系统中还定义了一些便捷的函数以便在 Android.mk 中使用，包括： $(call all-java-files-under, )：获取指定目录下的所有 Java 文件。 $(call all-c-files-under, )：获取指定目录下的所有 C 语言文件。 $(call all-Iaidl-files-under, ) ：获取指定目录下的所有 AIDL 文件。 $(call all-makefiles-under, )：获取指定目录下的所有 Make 文件。 定义完 LOCAL_XXX 变量之后， 最后一步是 include $(BUILD_XXX)其中 BUILD_XXX 的可选项在 build/make/core/config.mk 文件中有定义： 1234567891011121314151617181920CLEAR_VARS:&#x3D; $(BUILD_SYSTEM)&#x2F;clear_vars.mkBUILD_HOST_STATIC_LIBRARY:&#x3D; $(BUILD_SYSTEM)&#x2F;host_static_library.mkBUILD_HOST_SHARED_LIBRARY:&#x3D; $(BUILD_SYSTEM)&#x2F;host_shared_library.mkBUILD_STATIC_LIBRARY:&#x3D; $(BUILD_SYSTEM)&#x2F;static_library.mkBUILD_HEADER_LIBRARY:&#x3D; $(BUILD_SYSTEM)&#x2F;header_library.mkBUILD_AUX_STATIC_LIBRARY:&#x3D; $(BUILD_SYSTEM)&#x2F;aux_static_library.mkBUILD_AUX_EXECUTABLE:&#x3D; $(BUILD_SYSTEM)&#x2F;aux_executable.mkBUILD_SHARED_LIBRARY:&#x3D; $(BUILD_SYSTEM)&#x2F;shared_library.mkBUILD_EXECUTABLE:&#x3D; $(BUILD_SYSTEM)&#x2F;executable.mkBUILD_HOST_EXECUTABLE:&#x3D; $(BUILD_SYSTEM)&#x2F;host_executable.mkBUILD_PACKAGE:&#x3D; $(BUILD_SYSTEM)&#x2F;package.mkBUILD_PHONY_PACKAGE:&#x3D; $(BUILD_SYSTEM)&#x2F;phony_package.mkBUILD_RRO_PACKAGE:&#x3D; $(BUILD_SYSTEM)&#x2F;build_rro_package.mkBUILD_HOST_PREBUILT:&#x3D; $(BUILD_SYSTEM)&#x2F;host_prebuilt.mkBUILD_PREBUILT:&#x3D; $(BUILD_SYSTEM)&#x2F;prebuilt.mkBUILD_MULTI_PREBUILT:&#x3D; $(BUILD_SYSTEM)&#x2F;multi_prebuilt.mkBUILD_JAVA_LIBRARY:&#x3D; $(BUILD_SYSTEM)&#x2F;java_library.mkBUILD_STATIC_JAVA_LIBRARY:&#x3D; $(BUILD_SYSTEM)&#x2F;static_java_library.mkBUILD_HOST_JAVA_LIBRARY:&#x3D; $(BUILD_SYSTEM)&#x2F;host_java_library.mk... 可见 BUILD_XXX 变量都是一个 mk 文件路径，每一个 BUILD_XXX 定义了一种编译规则。当我们 include $(BUILD_XXX) ，编译系统就根据前面所定义的 LOCAL_XXX 变量，来定义模块的目标， 依赖关系，及编译命令，编译参数等。需要注意的是，这个时候只是定义了模块的目标而已，并没有开始编译。 2.3.3 Android.bp对于 Android.bp 模块来说，四个基本要素的配置方法如下： 1234567cc_binary &#123; &#x2F;&#x2F; 模块类型 name: &quot;hello&quot;, &#x2F;&#x2F; 模块名 srcs: [&quot;hello.cpp&quot;], &#x2F;&#x2F; 源文件列表 shared_libs: [ &#x2F;&#x2F; 依赖关系 &quot;liblog&quot;, ],&#125; Android.bp 支持的模块类型基本上跟 Android.mk 是一样的。它们的对应关系如下（Android/build/soong/androidmk/cmd/androidmk/android.go）： 123456789101112131415161718192021222324252627282930313233var moduleTypes &#x3D; map[string]string&#123; &quot;BUILD_SHARED_LIBRARY&quot;: &quot;cc_library_shared&quot;, &quot;BUILD_STATIC_LIBRARY&quot;: &quot;cc_library_static&quot;, &quot;BUILD_HOST_SHARED_LIBRARY&quot;: &quot;cc_library_host_shared&quot;, &quot;BUILD_HOST_STATIC_LIBRARY&quot;: &quot;cc_library_host_static&quot;, &quot;BUILD_HEADER_LIBRARY&quot;: &quot;cc_library_headers&quot;, &quot;BUILD_EXECUTABLE&quot;: &quot;cc_binary&quot;, &quot;BUILD_HOST_EXECUTABLE&quot;: &quot;cc_binary_host&quot;, &quot;BUILD_NATIVE_TEST&quot;: &quot;cc_test&quot;, &quot;BUILD_HOST_NATIVE_TEST&quot;: &quot;cc_test_host&quot;, &quot;BUILD_NATIVE_BENCHMARK&quot;: &quot;cc_benchmark&quot;, &quot;BUILD_HOST_NATIVE_BENCHMARK&quot;: &quot;cc_benchmark_host&quot;, &quot;BUILD_JAVA_LIBRARY&quot;: &quot;java_library_installable&quot;, &#x2F;&#x2F; will be rewritten to java_library by bpfix &quot;BUILD_STATIC_JAVA_LIBRARY&quot;: &quot;java_library&quot;, &quot;BUILD_HOST_JAVA_LIBRARY&quot;: &quot;java_library_host&quot;, &quot;BUILD_HOST_DALVIK_JAVA_LIBRARY&quot;: &quot;java_library_host_dalvik&quot;, &quot;BUILD_PACKAGE&quot;: &quot;android_app&quot;, &quot;BUILD_CTS_EXECUTABLE&quot;: &quot;cc_binary&quot;, &#x2F;&#x2F; will be further massaged by bpfix depending on the output path &quot;BUILD_CTS_SUPPORT_PACKAGE&quot;: &quot;cts_support_package&quot;, &#x2F;&#x2F; will be rewritten to android_test by bpfix &quot;BUILD_CTS_PACKAGE&quot;: &quot;cts_package&quot;, &#x2F;&#x2F; will be rewritten to android_test by bpfix &quot;BUILD_CTS_TARGET_JAVA_LIBRARY&quot;: &quot;cts_target_java_library&quot;, &#x2F;&#x2F; will be rewritten to java_library by bpfix &quot;BUILD_CTS_HOST_JAVA_LIBRARY&quot;: &quot;cts_host_java_library&quot;, &#x2F;&#x2F; will be rewritten to java_library_host by bpfix&#125;var prebuiltTypes &#x3D; map[string]string&#123; &quot;SHARED_LIBRARIES&quot;: &quot;cc_prebuilt_library_shared&quot;, &quot;STATIC_LIBRARIES&quot;: &quot;cc_prebuilt_library_static&quot;, &quot;EXECUTABLES&quot;: &quot;cc_prebuilt_binary&quot;, &quot;JAVA_LIBRARIES&quot;: &quot;java_import&quot;, &quot;ETC&quot;: &quot;prebuilt_etc&quot;,&#125; 每一种模块类型都有很多配置选项，这里就不一一列举了，请参考 soong官方文档 需要注意的是目前 Android.bp 还不支持预置APK模块。所以我们还是需要 Android.mk 来定义预置 APK。 3. 编译流程我们编译 Android 系统一般有三个步骤： source build/envsetup.sh ： 配置编译环境 lunch ： 选择要编译的产品 make -j ： 开始编译 我们接下来就从这三步骤入手， 分析一下编译系统的源码， 梳理一下系统的编译流程， 看看编译系统是怎么根据我们上面的模块，产品，平台配置等信息最终编译成各个系统镜像的。","categories":[{"name":"Android系统开发进阶","slug":"Android系统开发进阶","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发入门-15.Android.bp 条件编译","slug":"Android系统开发入门/15-Anroid.bp条件编译","date":"2020-02-05T02:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/02/05/Android系统开发入门/15-Anroid.bp条件编译/","link":"","permalink":"http://qiushao.net/2020/02/05/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/15-Anroid.bp%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/","excerpt":"","text":"在工作中我们经常会遇到一套代码需要兼容多个 Android 版本的情况，不同的 Android 版本，代码逻辑可能不一样。我们又不可能每个 Android 版本拉一个代码分支，这样维护成本太高。因此我们一般都是根据 Android 版本进行条件编译。Android 7.0 之前的模块都是使用 Android.mk 来定义的，本质上就是 makefile，自然是支持条件编译的。但 Android7.0 之后，系统模块逐步替换成 Android.bp。但 Android.bp 本质上就是一个 json 配置文件，是不支持条件判断的。但条件编译又是强需求，所以 google 还是提供了一种条件编译的方法，下面我们就来学习一下。 我们的目标是把 platform sdk version 传给一个 Android.bp 模块的 cpp 代码。 直接在之前写过的 hello 模块上进行修改。 1. Android.bp 修改在 Android.bp 中添加以下配置 123456789101112131415161718192021222324252627282930&#x2F;&#x2F; add startbootstrap_go_package &#123; name: &quot;soong-hello&quot;, pkgPath: &quot;android&#x2F;soong&#x2F;hello&quot;, deps: [ &quot;soong-android&quot;, &quot;soong-cc&quot;, ], srcs: [ &quot;hello.go&quot;, ], pluginFor: [&quot;soong_build&quot;],&#125;cc_hello_binary &#123; name: &quot;hello_defaults&quot;,&#125;&#x2F;&#x2F; add endcc_binary &#123; name: &quot;hello&quot;, &#x2F;&#x2F; add start defaults: [&quot;hello_defaults&quot;], &#x2F;&#x2F; add end vendor: true, srcs: [&quot;hello.cpp&quot;],&#125; 主要是添加了一个 bootstrap_go_package 模块 soong-hello， 指定源文件为 hello.go， 在解析到这个模块的 Android.bp 时，会对 hello.go 进行编译。然后我们定义了一个 cc_hello_binary 模块 hello_defaults。这个类型是我们在 hello.go 中定义的。最后我们指定了 hello 模块的 defaults 为 hello_defaults, 这样我们对 hello_defaults 模块的配置，就会附加到 hello 模块上。 2. 添加 hook在 hello 目录下添加 hello.go 文件 123456789101112131415161718192021222324252627282930package helloimport ( &quot;android&#x2F;soong&#x2F;android&quot; &quot;android&#x2F;soong&#x2F;cc&quot; &quot;fmt&quot;)func init() &#123; android.RegisterModuleType(&quot;cc_hello_binary&quot;, helloDefaultsFactory)&#125;func helloDefaultsFactory() (android.Module) &#123; module :&#x3D; cc.DefaultsFactory() android.AddLoadHook(module, helloHook) return module&#125;func helloHook(ctx android.LoadHookContext) &#123; &#x2F;&#x2F;AConfig() function is at build&#x2F;soong&#x2F;android&#x2F;config.go fmt.Println(&quot;PlatformSdkVersion &#x3D; &quot;, ctx.AConfig().PlatformSdkVersion()) fmt.Println(&quot;DeviceName &#x3D; &quot;, ctx.AConfig().DeviceName()) type props struct &#123; Cflags []string &#125; p :&#x3D; &amp;props&#123;&#125; p.Cflags &#x3D; append(p.Cflags, &quot;-DPLATFORM_SDK_VERSION&#x3D;&quot; + ctx.AConfig().PlatformSdkVersion()) ctx.AppendProperties(p)&#125; init 函数会先被执行， 在 init 里面注册了一个新的模块类型 cc_hello_binary， 对应的函数是 helloDefaultsFactory。需要注意的是其中 cc.DefaultsFactory 要根据模块类型的不同而不同。 cc_binary –&gt; cc.DefaultsFactory cc_library_shared –&gt; cc.LibrarySharedFactory() java_library –&gt; java.LibraryFactory() 这个可以在 build/soong/cc/library.go 和 java.go 中查看, 如 library.go 12345678func init() &#123; android.RegisterModuleType(&quot;cc_library_static&quot;, LibraryStaticFactory) android.RegisterModuleType(&quot;cc_library_shared&quot;, LibrarySharedFactory) android.RegisterModuleType(&quot;cc_library&quot;, LibraryFactory) android.RegisterModuleType(&quot;cc_library_host_static&quot;, LibraryHostStaticFactory) android.RegisterModuleType(&quot;cc_library_host_shared&quot;, LibraryHostSharedFactory) android.RegisterModuleType(&quot;cc_library_headers&quot;, LibraryHeaderFactory)&#125; 然后我们给 cc_hello_binary 模块类型添加了一个 hook：helloHook，当有 cc_hello_binary 类型的模块定义是， helloHook 就会被触发执行。我们希望的条件编译就可以在这个 hook 里面进行操作了。我们可以通过 ctx 来获取各种编译信息， 比如 PlatformSdkVersion， DeviceName。我们可以通过 ctx.AppendProperties 来添加各种配置，可以配置的东西如下： 12345678910type props struct &#123; &#x2F;&#x2F; 定义Android.bp中的各个字段 Cflags []string Srcs []string Include_dirs []string Shared_libs []string Local_include_dirs []string Static_libs []string Export_shared_lib_headers []string&#125; 这个例子中我们只是添加了一个 Cflags 而已， 如果需要的话，我们可以添加源码文件及头文件目录，及依赖等。 3. 使用传进来的宏1234567#include &lt;cstdio&gt;int main() &#123; printf(&quot;hello qiushao\\n&quot;); printf(&quot;PLATFORM_SDK_VERSION &#x3D; %d\\n&quot;, PLATFORM_SDK_VERSION); return 0;&#125; 4. 编译验证1234pure:&#x2F; # hellohello qiushaoPLATFORM_SDK_VERSION &#x3D; 29pure:&#x2F; #","categories":[{"name":"Android系统开发入门","slug":"Android系统开发入门","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发入门-14.Android studio 导入系统源码","slug":"Android系统开发入门/14-Android-studio导入系统源码","date":"2020-02-04T02:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/02/04/Android系统开发入门/14-Android-studio导入系统源码/","link":"","permalink":"http://qiushao.net/2020/02/04/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/14-Android-studio%E5%AF%BC%E5%85%A5%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/","excerpt":"","text":"目前流行的阅读 Android 系统源码的工具主要有以下几种： source insight, understand, vscode, vim 等。也有同学不用导工程直接 find + grep + 文本编辑器的， 这些工具我也都用过很长一段时间， 但总有不满意的地方。后来 Android studio 发布了 3.0 版本， 开始支持 NDK 开发了，体验了一下之后，就觉得这功能不就是我想要的嘛，同时写 java 和 c++ 代码。于是开始各种折腾，折腾了几个星期后，终于找到一种将 Android系统源码导入到 Android studio 的方法，使用 gradle + cmake + NDK 支持同时解析 java 和 c++ 代码。理论上来说支持任何 java, c++ 工程或者混合工程。这种方法是我个人原创的，跟官方的使用 ideagen 生成工程不一样。使用 ideagen 只能导入 java 代码，c++ 代码没法解析。但这种方法对电脑的性能要求比较高，最好满足以下条件： 代码要下载到本机，而不是通过 samba 挂载。 代码最好是下载到 ssd，而不是机械硬件。 内存最好 32G 以上。 Linux 系统， Windows 总会有各种乱七八糟的问题。 如果不满足以上条件，可能在查看，修改代码过程中会有卡顿出现。满足条件的话，则是飞一般的感觉。下面就来演示一下源码导入过程，基于 Android studio 版本 3.4.1。 1. 准备工作如果需要解析C/C++代码的话，则需要安装 cmake, ndk。打开 SDKManager 选择 SDK Tools， 勾选 cmake 和 NDK 然后 install 即可。 2. 新建顶层 build.gradle在 Android 根目录新建一个 build.gradle 文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253buildscript &#123; repositories &#123; maven &#123; url &#39;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;public&#x2F;&#39; &#125; google() jcenter() &#125; dependencies &#123; classpath &#39;com.android.tools.build:gradle:3.4.2&#39; &#125;&#125;allprojects &#123; repositories &#123; maven &#123; url &#39;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;public&#x2F;&#39; &#125; google() jcenter() &#125;&#125;apply plugin: &quot;idea&quot;idea &#123; module &#123; excludeDirs &#x3D; [ file(&quot;.repo&quot;), file(&quot;abi&quot;), file(&quot;art&quot;), file(&quot;bionic&quot;), file(&quot;bootable&quot;), file(&quot;build&quot;), file(&quot;cts&quot;), file(&quot;dalvik&quot;), file(&quot;developers&quot;), file(&quot;development&quot;), file(&quot;docs&quot;), file(&quot;external&quot;), file(&quot;hardware&quot;), file(&quot;kernel&quot;), file(&quot;libcore&quot;), file(&quot;libnativehelper&quot;), file(&quot;ndk&quot;), file(&quot;out&quot;), file(&quot;packages&quot;), file(&quot;pdk&quot;), file(&quot;platform_testing&quot;), file(&quot;prebuilts&quot;), file(&quot;sdk&quot;), file(&quot;system&quot;), file(&quot;test&quot;), file(&quot;toolchain&quot;), file(&quot;tools&quot;) ] &#125;&#125; 这个文件与普通的 Android 应用的顶层 build.gradle 文件的差别就是多加了一个 apply plugin: “idea”， 然后在配置 idea 插件的 excludeDirs。即忽略哪些不目录。这些目录被忽略之后，Android studio 就不会扫描分析里面的文件了。因为 Android 源码非常庞大， 如果没有配置 excludeDirs 的话，导入工程可能得导一整天了。一般来说我们只需要关注很少的一部分代码而已，我们只需要保留我们要关注的代码目录即可，其他目录都加到 excludeDirs 里面。 3. 导入 java 模块一般情况下我们关注的是 frameworks/base 目录下的源码而已， 因此我们在 frameworks/base 目录下创建一个 build.gradle 文件 123456789101112131415161718192021222324252627282930313233343536373839apply plugin: &#39;java&#39;sourceSets &#123; main.java.srcDirs +&#x3D; &#39;core&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;graphics&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;keystore&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;location&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;lowpan&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;media&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;media&#x2F;apex&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;opengl&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;sax&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;accessibility&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;appprediction&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;appwidget&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;autofill&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;backup&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;companion&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;contentcapture&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;contentsuggestions&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;core&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;coverage&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;devicepolicy&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;midi&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;net&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;print&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;restrictions&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;robotests&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;startop&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;systemcaptions&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;usage&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;usb&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;voiceinteraction&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;services&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;telecomm&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;telephony&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;wifi&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;..&#x2F;..&#x2F;out&#x2F;soong&#x2F;.intermediates&#x2F;frameworks&#x2F;base&#x2F;framework&#x2F;android_common&#x2F;gen&#x2F;aidl&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#39; main.java.srcDirs +&#x3D; &#39;..&#x2F;..&#x2F;out&#x2F;soong&#x2F;.intermediates&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;res&#x2F;framework-res&#x2F;android_common&#x2F;gen&#x2F;aapt2&#x2F;R&#39;&#125; 4. 导入 c++ 模块上面的方法只能解析 java 代码而已， 做系统层的开发经常是要接触到 c++ 代码的， 若是有一个强大的 ide 的辅助便能省心不少。下面就演示一下导入 c++ 模块的方法。以 recovery 模块为例， 在 bootable目录下新建一个 build.gradle 文件： 1234567891011121314151617181920212223apply plugin: &#39;com.android.application&#39;android &#123; compileSdkVersion 29 defaultConfig &#123; applicationId &quot;com.android.recovery&quot; minSdkVersion 28 targetSdkVersion 29 versionCode 1 versionName &quot;1.0&quot; externalNativeBuild &#123; cmake &#123; cppFlags &quot;-std&#x3D;c++11&quot; &#125; &#125; &#125; externalNativeBuild &#123; cmake &#123; path &quot;CMakeLists.txt&quot; version &quot;3.10.2&quot; &#125; &#125;&#125; 再新建一个 CMakeLists.txt 文件： 12345678910111213141516171819202122232425cmake_minimum_required(VERSION 2.6)project(recovery)set(CMAKE_CXX_STANDARD 11)include_directories(..&#x2F;system&#x2F;core&#x2F;base&#x2F;include)include_directories(..&#x2F;system&#x2F;core&#x2F;libcutils&#x2F;include)include_directories(..&#x2F;hardware&#x2F;interfaces&#x2F;health&#x2F;2.0&#x2F;utils&#x2F;libhealthhalutils&#x2F;include)include_directories(..&#x2F;system&#x2F;core&#x2F;libziparchive&#x2F;include)include_directories(..&#x2F;system&#x2F;core&#x2F;liblog&#x2F;include)include_directories(..&#x2F;external&#x2F;selinux&#x2F;libselinux&#x2F;include)include_directories(recovery&#x2F;applypatch&#x2F;include)include_directories(recovery&#x2F;bootloader_message&#x2F;include)include_directories(recovery&#x2F;edify&#x2F;include)include_directories(recovery&#x2F;fuse_sideload&#x2F;include)include_directories(recovery&#x2F;install&#x2F;include)include_directories(recovery&#x2F;minui&#x2F;include)include_directories(recovery&#x2F;otautil&#x2F;include)include_directories(recovery&#x2F;recovery_ui&#x2F;include)include_directories(recovery&#x2F;update_verifier&#x2F;include)include_directories(recovery&#x2F;updater&#x2F;include)FILE(GLOB_RECURSE recovery_cpp_list &quot;.&#x2F;*.cpp&quot;)add_library(recovery $&#123;recovery_cpp_list&#125;)set_target_properties(recovery PROPERTIES LINKER_LANGUAGE CXX) 在 bootable 目录下新建 src/main 目录， 在此目录下新建 AndroidManifest.xml 文件: 1234&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; package&#x3D;&quot;com.android.recovery&quot;&gt;&lt;&#x2F;manifest&gt; 这个文件对于我们来说并没有什么用， 但是 gradle 的 android 插件要求要有这么一个文件，不然会报错， 我们创建这么个文件，简单声明一下 package 信息即可，其他内容都不需要。 5. settings.gradle 配置子模块在 Android 源码根目录下新建 settings.gradle 文件 12include &quot;:frameworks:base&quot;include &quot;:bootable&quot; 把我们前面添加的两个模块加进来。 6. 使用 Android studio 打开工程使用 Android studio file –&gt; open 打开 build.gradle 文件，选择 open as a project。如果网络好的话，这一步应该几分钟就OK了。网络慢的话，可能要卡在下载 gradle 依赖这里很久，耐心等待便是。第一次打开耐心等待很长时间，才能解析完代码。这个得看网络速度，电脑性能，我自己的电脑十几分钟就解析完了，公司的电脑得半个多小时。待解析完代码后，打开 framework/base 下面的代码和 recovery 下面的代码，发现都可以跳转了。而且那些被配置为 excludeDirs 的目录应该变成了黄色的，表示这些目录下的文件不会被索引，下次再打开工程时速度就快很多了。","categories":[{"name":"Android系统开发入门","slug":"Android系统开发入门","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发入门-13.Binder服务死亡讣告","slug":"Android系统开发入门/13-binder死亡讣告","date":"2020-02-03T02:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/02/03/Android系统开发入门/13-binder死亡讣告/","link":"","permalink":"http://qiushao.net/2020/02/03/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/13-binder%E6%AD%BB%E4%BA%A1%E8%AE%A3%E5%91%8A/","excerpt":"","text":"前面我们花了几小节来实现了各种类型的服务及客户端调用验证，这些服务本质上都是 Binder 通信，而 Binder 通信本质上也是 C/S 通信。既然是 C/S 通信，那就会存在 client 或者 server 异常挂掉的情况。如果 server 挂掉了， client 就没法再调用 server 的接口了。同样，client 挂掉的话，server 也没法再调用 client 的回调接口。如果继续调用一个已经挂掉的 Binder 接口， Android 8.0 之后的 hidl 机制会导致调用进程也跟着挂掉，而 Android 8.0 之前的 Binder 通信模式只是会返回一个错误状态。无论何种情况，我们都需要处理好 Binder 挂掉的问题。Binder实现了一套 死亡讣告 的功能，即：服务端挂了，或者正常退出，Binder驱动会向客户端发送一份讣告，告诉客户端Binder服务挂了。下面我们以 hidl 服务为例来学习一下死亡讣告的使用方法。 直接在之前的 hidl TVServer 基础上进行修改。实现双向挂掉监听。 1. client 监听 server 是否挂掉TVServerTest.cpp 修改如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;device&#x2F;qiushao&#x2F;pure&#x2F;tvserver&#x2F;1.0&#x2F;ITVServer.h&gt;#include &lt;device&#x2F;qiushao&#x2F;pure&#x2F;tvserver&#x2F;1.0&#x2F;ITVServerListener.h&gt;#include &lt;hidl&#x2F;Status.h&gt;#include &lt;utils&#x2F;misc.h&gt;#include &lt;hidl&#x2F;HidlSupport.h&gt;#include &lt;stdio.h&gt;#include &lt;string&gt;using namespace std;using ::android::hardware::hidl_string;using ::android::hardware::hidl_death_recipient;using ::android::sp;using device::qiushao::pure::tvserver::V1_0::ITVServer;using device::qiushao::pure::tvserver::V1_0::ITVServerListener;android::sp&lt;ITVServer&gt; service &#x3D; nullptr;class TVServerListener : public ITVServerListener &#123;public: android::hardware::Return&lt;void&gt; onMessage(const hidl_string&amp; message) override &#123; printf(&quot;onMessage:%s\\n&quot;, message.c_str()); return android::hardware::Return&lt;void&gt;(); &#125;&#125;;class ServerDeathRecipient : public hidl_death_recipient &#123; virtual void serviceDied(uint64_t cookie, const android::wp&lt;::android::hidl::base::V1_0::IBase&gt;&amp; who) &#123; printf(&quot;serviceDied cookie &#x3D; %d\\n&quot;, cookie); service &#x3D; nullptr; &#125;&#125;;int main()&#123; sp&lt;ITVServerListener&gt; listener &#x3D; new TVServerListener(); sp&lt;ServerDeathRecipient&gt; deathRecipient &#x3D; new ServerDeathRecipient(); service &#x3D; ITVServer::getService(); if (service &#x3D;&#x3D; nullptr)&#123; printf(&quot;Failed to get service\\n&quot;); return -1; &#125; service-&gt;linkToDeath(deathRecipient, 0); service-&gt;registerListener(getpid(), listener); service-&gt;hello(&quot;qiushao&quot;, [&amp;](hidl_string result)&#123; printf(&quot;%s\\n&quot;, result.c_str()); &#125;); sleep(10); &#x2F;&#x2F;service-&gt;unregisterListener(getpid()); return 0;&#125; 增加了一个 ServerDeathRecipient 类作为一个监听器，通过 service-&gt;linkToDeath(deathRecipient, 0); 来注册监听器。当service 挂掉的时候， ServerDeathRecipient 监听器的 serviceDied 方法会被调用。我们可以在这个方法里面做些善后工作。 完整编译，启动虚拟机，查看 TVServer 的进程号，然后启动 TVServiceTest， 我们在代码里面 sleep 了 10 秒钟， 在 TVServiceTest 退出之前， 手动 kill 掉 TVServer ， 看 log serviceDied 方法的确被调用了。 12345130|pure:&#x2F; # TVServerTest hello qiushao from TVServeronMessage:message from serverserviceDied cookie &#x3D; 0pure:&#x2F; # 2. server 监听 client 是否挂掉TVServer.h 修改如下 123456789101112131415...using ::android::hardware::hidl_death_recipient;class ClientDeathRecipient;class TVServer : public ITVServer &#123;public: TVServer(); &#x2F;&#x2F; Methods from ::device::qiushao::pure::tvserver::V1_0::ITVServer follow. Return&lt;void&gt; hello(const hidl_string&amp; name, hello_cb _hidl_cb) override; Return&lt;void&gt; registerListener(const uint32_t pid, const sp&lt;ITVServerListener&gt;&amp; listener) override; Return&lt;void&gt; unregisterListener(const uint32_t pid) override;private: map&lt;uint32_t, sp&lt;ITVServerListener&gt; &gt; mListeners; sp&lt;ClientDeathRecipient&gt; mDeathRecipient;&#125;; 只是声明了一个 mDeathRecipient。 TVServer.cpp 修改如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &quot;TVServer.h&quot;#include &lt;android&#x2F;log.h&gt;#define LOG_TAG &quot;TVServer&quot;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)namespace device &#123;namespace qiushao &#123;namespace pure &#123;namespace tvserver &#123;namespace V1_0 &#123;namespace implementation &#123;class ClientDeathRecipient : public hidl_death_recipient &#123;private: sp&lt;TVServer&gt; mTVServer;public: ClientDeathRecipient(sp&lt;TVServer&gt; tvserver): mTVServer(tvserver) &#123;&#125; virtual void serviceDied(uint64_t cookie, const android::wp&lt;::android::hidl::base::V1_0::IBase&gt;&amp; who) &#123; uint32_t pid &#x3D; cookie; LOGD(&quot;client died pid &#x3D; %d&quot;, pid); mTVServer-&gt;unregisterListener(pid); &#125;&#125;;TVServer::TVServer() &#123; LOGD(&quot;TVServer start...&quot;); mDeathRecipient &#x3D; new ClientDeathRecipient(this);&#125;&#x2F;&#x2F; Methods from ::device::qiushao::pure::tvserver::V1_0::ITVServer follow.Return&lt;void&gt; TVServer::hello(const hidl_string&amp; name, hello_cb _hidl_cb) &#123; char buf[100]; ::memset(buf, 0, 100); ::snprintf(buf, 100, &quot;hello %s from TVServer&quot;, name.c_str()); hidl_string result(buf); _hidl_cb(result); LOGD(&quot;listener size &#x3D; %d&quot;, mListeners.size()); map&lt;uint32_t, sp&lt;ITVServerListener&gt; &gt;::iterator it; for (it &#x3D; mListeners.begin(); it !&#x3D; mListeners.end(); ++it) &#123; sp&lt;ITVServerListener&gt; listener &#x3D; it-&gt;second; listener-&gt;onMessage(&quot;message from server&quot;); &#125; return Void();&#125;Return&lt;void&gt; TVServer::registerListener(const uint32_t pid, const sp&lt;ITVServerListener&gt;&amp; listener) &#123; mListeners[pid] &#x3D; listener; listener-&gt;linkToDeath(mDeathRecipient, pid); LOGD(&quot;registerListener %d, %x&quot;, pid, listener.get()); return Void();&#125;Return&lt;void&gt; TVServer::unregisterListener(const uint32_t pid) &#123; mListeners[pid]-&gt;unlinkToDeath(mDeathRecipient); mListeners.erase(pid); LOGD(&quot;unregisterListener %d&quot;, pid); return Void();&#125;&#x2F;&#x2F; Methods from ::android::hidl::base::V1_0::IBase follow.&#x2F;&#x2F;ITVServer* HIDL_FETCH_ITVServer(const char* &#x2F;* name *&#x2F;) &#123; &#x2F;&#x2F;return new TVServer();&#x2F;&#x2F;&#125;&#x2F;&#x2F;&#125; &#x2F;&#x2F; namespace implementation&#125; &#x2F;&#x2F; namespace V1_0&#125; &#x2F;&#x2F; namespace tvserver&#125; &#x2F;&#x2F; namespace pure&#125; &#x2F;&#x2F; namespace qiushao&#125; &#x2F;&#x2F; namespace device 在注册 listener 的时候顺便给 listener linkToDeath 到一个 hidl_death_recipient 死亡讣告上。linkToDeath 的第二个参数为 cookie， 用来标志当前的 listener，若当前的 listener ＧＧ了， 系统会自动调用 ClientDeathRecipient 的 serviceDied 函数。其中的 cookie 值即为我们在 linkToDeath 传的第二个参数。收到 serviceDied 回调后，我们把对应 cookie 的 listener 从 mListener 中移除就行。这里我们使用了 client 的进程号作为 cookie。当然上面的代码还没有考虑多线程的情况， 实际项目代码中我们对所有的临界区资源访问前都应该进行加锁。 完整编译，启动虚拟机，启动 TVServiceTest，等待 TVServiceTest 进程退出，其实也就是 client GG 的情况。看 log serviceDied 方法的确被调用了。 1234567891011130|pure:&#x2F; # TVServerTest hello qiushao from TVServeronMessage:message from serverpure:&#x2F; # logcat -s TVServer --------- beginning of main02-03 15:02:51.255 5789 5792 D TVServer: registerListener 8044, d964300002-03 15:02:51.256 5789 5792 D TVServer: listener size &#x3D; 102-03 15:03:01.259 5789 5792 D TVServer: client died pid &#x3D; 804402-03 15:03:01.259 5789 5792 D TVServer: unregisterListener 8044^C130|pure:&#x2F; # 3. 非 hidl binder 服务的死亡讣告对于另外两种 binder 服务的死亡讣告其实流程都是一样的，差异只是需要继续的死亡讣告类不一样而已。java 服务对应的是java层 IBinder.DeathRecipient。native 服务对应的是c++层 IBinder::DeathRecipient。具体实现这里就不再展开了，有兴趣的同学可以自己尝试一下。","categories":[{"name":"Android系统开发入门","slug":"Android系统开发入门","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发入门-12.hidl服务回调","slug":"Android系统开发入门/12-hidl服务回调","date":"2020-01-10T10:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/01/10/Android系统开发入门/12-hidl服务回调/","link":"","permalink":"http://qiushao.net/2020/01/10/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/12-hidl%E6%9C%8D%E5%8A%A1%E5%9B%9E%E8%B0%83/","excerpt":"","text":"上一小节我们已经完整的跑起来了一个 hidl 的 hello demo，这个 demo 虽然非常简单，但已经包含了 hidl 的大部分知识点了，我们只要在这个框架的基础上不断的扩展功能即可。上一小节的demo 调用是单向的，即只能由 client 调用 service 的功能，但实际项目中我们是经常需要在 service 里面通知 client 某个事件发生了，需要 client 进行处理。也就是双向调用，或者称为 callback。下面我们在上一小节的基础上增加一个回调功能。 1. 增加回调 hal 接口在 tvserver/1.0 目录下增加 ITVServerListener.hal 文件 12345package device.qiushao.pure.tvserver@1.0;interface ITVServerListener &#123; oneway onMessage(string message);&#125;; 2. ITVServer.hal 增加回调注册接口1234567package device.qiushao.pure.tvserver@1.0;import ITVServerListener;interface ITVServer &#123; hello(string name) generates (string result); registerListener(uint32_t pid, ITVServerListener listener); unregisterListener(uint32_t pid);&#125;; 3. 更新 current.txtcurrent.txt 中增加 ITVServerListener 接口的 hash 值，先随便写一个，然后执行 1.&#x2F;device&#x2F;qiushao&#x2F;pure&#x2F;models&#x2F;hidl&#x2F;update-makefiles.sh 会提示 hash 值不对，更新 current.txt 即可，两个 hal 接口的 hash 值都更新之后，再执行 update-makefiles.sh 4. 实现新增的 hal 接口TVServer.h 123456789101112131415161718...#include &lt;device&#x2F;qiushao&#x2F;pure&#x2F;tvserver&#x2F;1.0&#x2F;ITVServerListener.h&gt;#include &lt;map&gt;using namespace std;...class TVServer : public ITVServer &#123;public: Return&lt;void&gt; hello(const hidl_string&amp; name, hello_cb _hidl_cb) override; Return&lt;void&gt; registerListener(const uint32_t pid, const sp&lt;ITVServerListener&gt;&amp; listener) override; Return&lt;void&gt; unregisterListener(const uint32_t pid) override;private: map&lt;uint32_t, sp&lt;ITVServerListener&gt; &gt; mListeners;&#125;;... 增加了 registerListener, unregisterListener 两个方法， 这两个方法的参数类型可以根据 hal 文件中声明的参数类型来推断。hidl 与 c++ 的数据类型转换可以按下表来转换一下，给所有参数都加上 const数据类型 hal 类型的参数，则使用 const sp&amp; listener 这种智能指针的形式。当然我们也可以使用 hidl-gen 来自动生成代码。参考上一小节的：根据 .hal 自动生成 cpp 实现。 TVServer.cpp 123456789101112131415161718192021222324252627282930313233#include &lt;android&#x2F;log.h&gt;#define LOG_TAG &quot;TVServer&quot;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)...Return&lt;void&gt; TVServer::hello(const hidl_string&amp; name, hello_cb _hidl_cb) &#123; char buf[100]; ::memset(buf, 0, 100); ::snprintf(buf, 100, &quot;hello %s from TVServer&quot;, name.c_str()); hidl_string result(buf); _hidl_cb(result); LOGD(&quot;listener size &#x3D; %d&quot;, mListeners.size()); map&lt;uint32_t, sp&lt;ITVServerListener&gt; &gt;::iterator it; for (it &#x3D; mListeners.begin(); it !&#x3D; mListeners.end(); ++it) &#123; sp&lt;ITVServerListener&gt; listener &#x3D; it-&gt;second; listener-&gt;onMessage(&quot;message from server&quot;); &#125; return Void();&#125;Return&lt;void&gt; TVServer::registerListener(const uint32_t pid, const sp&lt;ITVServerListener&gt;&amp; listener) &#123; mListeners[pid] &#x3D; listener; LOGD(&quot;registerListener %d, %x&quot;, pid, listener.get()); return Void();&#125;Return&lt;void&gt; TVServer::unregisterListener(const uint32_t pid) &#123; mListeners.erase(pid); LOGD(&quot;unregisterListener %d&quot;, pid); return Void();&#125; 5. 更新 manifest.xml增加一个interface节点就行 12345678910111213&lt;hal format&#x3D;&quot;hidl&quot;&gt; &lt;name&gt;device.qiushao.pure.tvserver&lt;&#x2F;name&gt; &lt;transport&gt;hwbinder&lt;&#x2F;transport&gt; &lt;version&gt;1.0&lt;&#x2F;version&gt; &lt;interface&gt; &lt;name&gt;ITVServer&lt;&#x2F;name&gt; &lt;instance&gt;default&lt;&#x2F;instance&gt; &lt;&#x2F;interface&gt; &lt;interface&gt; &lt;name&gt;ITVServerListener&lt;&#x2F;name&gt; &lt;instance&gt;default&lt;&#x2F;instance&gt; &lt;&#x2F;interface&gt;&lt;&#x2F;hal&gt; 6. 更新 client TVServerTest.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;device&#x2F;qiushao&#x2F;pure&#x2F;tvserver&#x2F;1.0&#x2F;ITVServer.h&gt;#include &lt;device&#x2F;qiushao&#x2F;pure&#x2F;tvserver&#x2F;1.0&#x2F;ITVServerListener.h&gt;#include &lt;hidl&#x2F;Status.h&gt;#include &lt;utils&#x2F;misc.h&gt;#include &lt;hidl&#x2F;HidlSupport.h&gt;#include &lt;stdio.h&gt;#include &lt;string&gt;using namespace std;using ::android::hardware::hidl_string;using ::android::sp;using device::qiushao::pure::tvserver::V1_0::ITVServer;using device::qiushao::pure::tvserver::V1_0::ITVServerListener;class TVServerListener : public ITVServerListener &#123;public: android::hardware::Return&lt;void&gt; onMessage(const hidl_string&amp; message) override &#123; printf(&quot;onMessage:%s\\n&quot;, message.c_str()); return android::hardware::Return&lt;void&gt;(); &#125;&#125;;int main()&#123; sp&lt;ITVServerListener&gt; listener &#x3D; new TVServerListener(); android::sp&lt;ITVServer&gt; service &#x3D; ITVServer::getService(); if (service &#x3D;&#x3D; nullptr)&#123; printf(&quot;Failed to get service\\n&quot;); return -1; &#125; service-&gt;registerListener(getpid(), listener); service-&gt;hello(&quot;qiushao&quot;, [&amp;](hidl_string result)&#123; printf(&quot;%s\\n&quot;, result.c_str()); &#125;); sleep(1); service-&gt;unregisterListener(getpid()); return 0;&#125; 7. 编译验证整编系统，执行 1234567891011pure:&#x2F; # TVServerTest hello qiushao from TVServeronMessage:message from serverpure:&#x2F; # logcat -s TVServer --------- beginning of main--------- beginning of system01-18 13:21:27.414 1665 1903 D TVServer: registerListener 4466, b044300001-18 13:21:27.414 1665 1903 D TVServer: listener size &#x3D; 101-18 13:21:28.415 1665 1903 D TVServer: unregisterListener 4466^C130|pure:&#x2F; # 可以看到收到了 onMessage 回调。","categories":[{"name":"Android系统开发入门","slug":"Android系统开发入门","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发入门-11.添加hidl服务","slug":"Android系统开发入门/11-添加hidl服务","date":"2020-01-07T10:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2020/01/07/Android系统开发入门/11-添加hidl服务/","link":"","permalink":"http://qiushao.net/2020/01/07/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/11-%E6%B7%BB%E5%8A%A0hidl%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"Android 8.0 之后，google 为了解决 Android 版本碎片化问题, 推出了 treble 架构，参考 Android Treble架构解析。核心思想就是 vendor 分区和 system 分区的隔离。把厂商的更改限制在 vendor 分区，system 分区由 google 把控。system 分区需要访问 vendor 分区的话，需要通过 hidl 的形式来访问。 网上有很多介绍 hidl 的文章，但没有一篇是介绍得比较全面的，都会遗漏一些小细节，由于这样，那样的小细节，自己到处找资料，折腾了两天才把 hidl 的demo 跑起来。以下作详细的记录，手把手教你从零创建自己的 hidl 服务。关于什么是 hidl ，及为什么要用 hidl 的理论知识这里就不作介绍了，可以参考官网的介绍 : hidl概览 1. 添加 hal 目录网上的 demo 全部都是直接在 android/hardware/interfaces 目录下添加了，但我觉得最好是在自己的 device 目录下添加比较好维护一点。 1mkdir -p device/qiushao/pure/models/hidl/tvserver/1.0 2. 定义 hal 接口在 device/qiushao/pure/models/hidl/tvserver/1.0 目录下创建文件 ITVServer.hal 12345package device.qiushao.pure.tvserver@1.0;interface ITVServer &#123; hello(string name) generates (string result);&#125;; 3. 根据 .hal 自动生成 cpp 实现123qiushao@qiushao-pc:~/source/android-10$ PACKAGE=device.qiushao.pure.tvserver@1.0qiushao@qiushao-pc:~/source/android-10$ LOC=device/qiushao/pure/models/hidl/tvserver/1.0/defaultqiushao@qiushao-pc:~/source/android-10$ hidl-gen -o $LOC -Lc++-impl -rdevice.qiushao.pure:device/qiushao/pure/models/hidl $PACKAGE 执行完以上命令之后在 default 目录下生成了 TVServer.h 和 TVServer.cpp 这两个文件我们需要对 TVServer.cpp 实现进行完善，只需要对我们定义的 hello 接口进行实现就行了，修改如下： 12345678Return&lt;void&gt; TVServer::hello(const hidl_string&amp; name, hello_cb _hidl_cb) &#123; char buf[100]; ::memset(buf, 0, 100); ::snprintf(buf, 100, &quot;hello %s from TVServer&quot;, name.c_str()); hidl_string result(buf); _hidl_cb(result); return Void();&#125; 我们还需要一个进程来容纳我们的服务，创建一个 main.cpp 文件： 12345678910111213141516171819202122232425#include &lt;hidl&#x2F;HidlTransportSupport.h&gt;#include &lt;utils&#x2F;Looper.h&gt;#include &lt;utils&#x2F;StrongPointer.h&gt;#include &quot;TVServer.h&quot;using android::hardware::configureRpcThreadpool;using android::hardware::joinRpcThreadpool;using device::qiushao::pure::tvserver::V1_0::ITVServer;using device::qiushao::pure::tvserver::V1_0::implementation::TVServer;int main(int argc, char **argv) &#123; &#x2F;&#x2F; sleep for a second, wait &#x2F;data&#x2F;vendor to be mounted sleep(1); configureRpcThreadpool(4, true &#x2F;* callerWillJoin *&#x2F;); android::sp&lt;ITVServer&gt; service &#x3D; new TVServer(); android::status_t ret &#x3D; service-&gt;registerAsService(); if (ret !&#x3D; android::NO_ERROR) &#123; &#125; joinRpcThreadpool(); return 0;&#125; 4. 开机自动启动服务在 tvserver/1.0/default 目录下创建 device.qiushao.pure.tvserver@1.0-service.rc 文件： 1234service tvserver &#x2F;vendor&#x2F;bin&#x2F;hw&#x2F;device.qiushao.pure.tvserver@1.0-service class hal user root group root 5. 生成 Android.bp1hidl-gen -o $LOC -Landroidbp-impl -rdevice.qiushao.pure:device/qiushao/pure/models/hidl $PACKAGE 在 Android 9.0 之后，查看自动生成的 Android.bp 文件，里面有些提示，说明自动生成的文件还需要稍作修改，我们修改如下: 12345678910111213141516cc_binary &#123; name: &quot;device.qiushao.pure.tvserver@1.0-service&quot;, init_rc: [&quot;device.qiushao.pure.tvserver@1.0-service.rc&quot;], relative_install_path: &quot;hw&quot;, vendor: true, srcs: [ &quot;TVServer.cpp&quot;, &quot;main.cpp&quot;, ], shared_libs: [ &quot;libhidlbase&quot;, &quot;libhidltransport&quot;, &quot;libutils&quot;, &quot;device.qiushao.pure.tvserver@1.0&quot;, ],&#125; 其中 device.qiushao.pure.tvserver@1.0-service.rc 文件会被安装到 /vendor/etc/init/ 目录。系统启动时会自动加载这个目录下的所有 rc 文件。 此时目录结构是这样的 12345678910111213qiushao@qiushao-pc:~/source/android-10/device/qiushao/pure/models/hidl$ tree tvserver/tvserver/└── 1.0 ├── default │ ├── Android.bp │ ├── main.cpp │ ├── TVServer.cpp │ └── TVServer.h │ └── device.qiushao.pure.tvserver@1.0-service.rc └── ITVServer.hal2 directories, 6 filesqiushao@qiushao-pc:~/source/android-10/device/qiushao/pure/models/hidl$ 6. 自动生成 hal 接口的 Android.bp这里需要用到 update-makefiles.sh 这个脚本，我们可以从 $(TOP)/hardware/interfaces 里面 copy 一份过来放到 device/qiushao/pure/models/hidl 目录，稍作修改即可 1234567891011121314#!/bin/bash# Script to update Android make-files for HAL and VTS modules.set -eif [ -z \"$ANDROID_BUILD_TOP\" ]; then echo \"Missing ANDROID_BUILD_TOP env variable. Run 'lunch' first.\" exit 1fisource $ANDROID_BUILD_TOP/system/tools/hidl/update-makefiles-helper.shdo_makefiles_update \\ \"device.qiushao.pure:device/qiushao/pure/models/hidl\" 然后在 Android 根目录执行 1./device/qiushao/pure/models/hidl/update-makefiles.sh 这个命令生成了 device/qiushao/pure/models/hidl/tvserver/1.0/Android.bp 这个文件： 1234567891011121314&#x2F;&#x2F; This file is autogenerated by hidl-gen -Landroidbp.hidl_interface &#123; name: &quot;device.qiushao.pure.tvserver@1.0&quot;, root: &quot;device.qiushao.pure&quot;, product_specific: true, srcs: [ &quot;ITVServer.hal&quot;, ], interfaces: [ &quot;android.hidl.base@1.0&quot;, ], gen_java: true,&#125; 我们需要在这个文件最前面添加以下配置才行，不然会编译不过： 1234hidl_package_root &#123; name: &quot;device.qiushao.pure&quot;, path: &quot;device&#x2F;qiushao&#x2F;pure&#x2F;models&#x2F;hidl&quot;,&#125; 目前目录结构是这样的： 12345678910111213141516qiushao@qiushao-pc:~/source/android-10/device/qiushao/pure/models/hidl$ tree .├── tvserver│ └── 1.0│ ├── Android.bp│ ├── default│ │ ├── Android.bp│ │ ├── main.cpp│ │ ├── TVServer.cpp│ │ └── TVServer.h│ │ └── device.qiushao.pure.tvserver@1.0-service.rc│ └── ITVServer.hal└── update-makefiles.sh3 directories, 9 filesqiushao@qiushao-pc:~/source/android-10/device/qiushao/pure/models/hidl$ 7. 更新 current.txtcurrent.txt 记录了所有 hal 接口的 hash 值，接口有变化时，同时需要更新 current.txt 中的 hash 值在 interfaces 目录下新建 current.txt 文件，随便写个 hash 值 1123456 device.qiushao.pure.tvserver@1.0::ITVServer 再执行一遍 update-makefiles.sh，这个时候就会发现提示 hash 值不正确了，同时会给出正确的 hash 值，我们把正确的 hash 值替换到 current.txt 即可。 8. 模块编译1mmm device/qiushao/pure/models/hidl/tvserver/1.0 编译完成后，可以发现 $(TARGET_OUT)/vendor/bin/hw 目录下生成了我们的服务 device.qiushao.pure.tvserver@1.0-service 9. 更新 manifest.xml复制 device/generic/goldfish/manifest.xml 到 device/qiushao/pure/manifest.xmlmanifest.xml 中加上 123456789&lt;hal format=\"hidl\"&gt; &lt;name&gt;device.qiushao.pure.tvserver&lt;/name&gt; &lt;transport&gt;hwbinder&lt;/transport&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;interface&gt; &lt;name&gt;ITVServer&lt;/name&gt; &lt;instance&gt;default&lt;/instance&gt; &lt;/interface&gt;&lt;/hal&gt; pure/product_copy_files.mk 中加上： 12PRODUCT_COPY_FILES +&#x3D; \\ device&#x2F;qiushao&#x2F;pure&#x2F;manifest.xml:vendor&#x2F;manifest.xml 10. 添加到 PRODUCT_PACKAGES修改 device.mk 增加 12PRODUCT_PACKAGES +&#x3D; \\ device.qiushao.pure.tvserver@1.0-service 11. 添加 selinux 规则系统原生的 selinux 规则在 system/sepolicy 目录下，我们可以直接修改里面的规则，但不推荐这么做，最好是在 device 目录下添加厂商自己的规则。在 BoardConfig.mk 里面添加: 1BOARD_SEPOLICY_DIRS +&#x3D; device&#x2F;qiushao&#x2F;pure&#x2F;sepolicy 然后我们就可以在 pure/sepolicy 目录下添加我们的 selinux 规则了。 新增 tvserver.te 123456789type tvserver, domain;type tvserver_exec, exec_type, vendor_file_type, file_type;hwbinder_use(tvserver);init_daemon_domain(tvserver)add_hwservice(tvserver, tvserver_hwservice)allow tvserver hwservicemanager_prop:file &#123;map read open getattr&#125;;allow tvserver system_file:dir &#123;read open getattr search&#125;; 新增 file_contexts 1&#x2F;vendor&#x2F;bin&#x2F;hw&#x2F;device.qiushao.pure.tvserver@1.0-service u:object_r:tvserver_exec:s0 新增 hwservice.te 1type tvserver_hwservice, hwservice_manager_type; 新增 hwservice_contexts 1device.qiushao.pure.tvserver::ITVServer u:object_r:tvserver_hwservice:s0 然后去编译整个系统， 运行，嘿，我们的服务跑起来了： 123130|pure:&#x2F; # ps -A | grep qiushaoroot 1648 1 15420 3864 futex_wait_queue_me 0 S device.qiushao.pure.tvserver@1.0-servicepure:&#x2F; # 12. 编写 client 调用服务在 1.0 目录下增加 test 目录，新建 TVServerTest.cpp 文件 12345678910111213141516171819202122232425#include &lt;device&#x2F;qiushao&#x2F;pure&#x2F;tvserver&#x2F;1.0&#x2F;ITVServer.h&gt;#include &lt;hidl&#x2F;Status.h&gt;#include &lt;utils&#x2F;misc.h&gt;#include &lt;hidl&#x2F;HidlSupport.h&gt;#include &lt;stdio.h&gt;#include &lt;string&gt;using namespace std;using ::android::hardware::hidl_string;using ::android::sp;using device::qiushao::pure::tvserver::V1_0::ITVServer;int main()&#123; android::sp&lt;ITVServer&gt; service &#x3D; ITVServer::getService(); if (service &#x3D;&#x3D; nullptr)&#123; printf(&quot;Failed to get service\\n&quot;); return -1; &#125; service-&gt;hello(&quot;qiushao&quot;, [&amp;](hidl_string result)&#123; printf(&quot;%s\\n&quot;, result.c_str()); &#125;); return 0;&#125; 新建 Android.bp 123456789101112131415cc_binary &#123; name: &quot;TVServerTest&quot;, vendor: true, srcs: [&quot;TVServerTest.cpp&quot;], shared_libs: [ &quot;liblog&quot;, &quot;libhardware&quot;, &quot;libhidlbase&quot;, &quot;libhidltransport&quot;, &quot;libutils&quot;, &quot;device.qiushao.pure.tvserver@1.0&quot;, ],&#125; 在 device.mk 中加上 12PRODUCT_PACKAGES +&#x3D; \\ TVServerTest 然后整编译系统，运行: 123pure:/ # TVServerTest hello qiushao from TVServerpure:/ # 成功调用了 hidl 服务。 最终代码目录结构是这样的 1234567891011121314151617181920qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10&#x2F;device&#x2F;qiushao&#x2F;pure&#x2F;models&#x2F;hidl$ tree.├── current.txt├── tvserver│ └── 1.0│ ├── Android.bp│ ├── default│ │ ├── Android.bp│ │ ├── device.qiushao.pure.tvserver@1.0-service.rc│ │ ├── main.cpp│ │ ├── TVServer.cpp│ │ └── TVServer.h│ ├── ITVServer.hal│ └── test│ ├── Android.bp│ └── TVServerTest.cpp└── update-makefiles.sh4 directories, 11 filesqiushao@qiushao-pc:~&#x2F;source&#x2F;android-10&#x2F;device&#x2F;qiushao&#x2F;pure&#x2F;models&#x2F;hidl$ 经过了这么多的步骤终于完成了一个 hidl 的 hello world。以后我们只要在这个框架上慢慢添加功能就行了。 网上大部分文章会忽略掉 current.txt, manifest.xml, selinux 及在 device/product 目录下添加模块的这些问题，导致自己跟着那些文章实现的时候，总是遇到各种问题，希望这篇记录能够帮助到想创建 hidl 服务的同学。","categories":[{"name":"Android系统开发入门","slug":"Android系统开发入门","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发入门-10.native服务回调","slug":"Android系统开发入门/10-native服务回调","date":"2019-12-31T12:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2019/12/31/Android系统开发入门/10-native服务回调/","link":"","permalink":"http://qiushao.net/2019/12/31/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/10-native%E6%9C%8D%E5%8A%A1%E5%9B%9E%E8%B0%83/","excerpt":"","text":"上一小节我们添加了一个 native server，也写了一个 client 来做测试。但只是单向的从 client 调用 server，实际项目中我们经常是需要双向调用的。某些事件发生的时候，server 端需要通知 client 来处理。这节我们就来学习一下如何从 server 端回调 client。首先我们要明确的是无论是从 client 调用 server， 还是 server 回调 client，本质上都是跨进程通信，都是需要借助 binder 框架的。 1. client 端更改为了简单省事，我们直接在上一小节的 demo 基础上作修改， HelloNatvieTest.cpp 修改如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;binder&#x2F;IServiceManager.h&gt;#include &lt;binder&#x2F;Parcel.h&gt;#include &lt;utils&#x2F;Errors.h&gt;#include &lt;stdio.h&gt;using namespace android;enum &#123; CMD_SAY_HELLO &#x3D; 1, CMD_CAL_SUM &#x3D; 2, CMD_CONNECT &#x3D; 3&#125;;class Callback :public BBinder &#123;public: enum &#123; CALLBACK_SAY_HELLO &#x3D; 1, &#125;; status_t onTransact(uint32_t code, const Parcel &amp;request, Parcel *reply, uint32_t flag) &#123; printf(&quot;Callback onTransact\\n&quot;); switch (code) &#123; case CALLBACK_SAY_HELLO: const char* str &#x3D; request.readCString(); printf(&quot;msg from server:%s\\n&quot;, str); break; &#125; return BBinder::onTransact(code, request, reply, flag); &#125;&#125;;static sp&lt;IBinder&gt; service;static void test_sayHello() &#123; Parcel request, reply; request.writeCString(&quot;qiushao&quot;); service-&gt;transact(CMD_SAY_HELLO, request, &amp;reply);&#125;static void test_calSum() &#123; Parcel request, reply; request.writeInt32(2); request.writeInt32(3); service-&gt;transact(CMD_CAL_SUM, request, &amp;reply); int sum &#x3D; reply.readInt32(); printf(&quot;sum of 2 + 3 &#x3D; %d\\n&quot;, sum);&#125;static void test_connect(sp&lt;Callback&gt; callback) &#123; Parcel request, reply; request.writeStrongBinder(callback); service-&gt;transact(CMD_CONNECT, request, &amp;reply);&#125;int main () &#123; service &#x3D; defaultServiceManager()-&gt;getService(String16(&quot;HelloNativeService&quot;)); sp&lt;Callback&gt; callback &#x3D; new Callback(); test_connect(callback); test_sayHello(); test_calSum(); sleep(10); return 0;&#125; 增加了一个 Callback 类，并且增加了一个 CMD_CONNECT 命令。main 函数中创建了一个 Callback 对象，然后通过 writeStrongBinder 把这个对象传给 server。 2. server 端更改HelloNativeService.cpp 修改如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;android&#x2F;log.h&gt;#include &lt;binder&#x2F;IServiceManager.h&gt;#include &lt;binder&#x2F;IPCThreadState.h&gt;#include &quot;HelloNativeService.h&quot;#define LOG_TAG &quot;HelloNativeService&quot;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)enum &#123; CMD_SAY_HELLO &#x3D; 1, CMD_CAL_SUM &#x3D; 2, CMD_CONNECT &#x3D; 3&#125;;enum &#123; CALLBACK_SAY_HELLO &#x3D; 1,&#125;;static void sayHello(const char *name) &#123; LOGD(&quot;hello %s from HelloNativeService&quot;, name);&#125;static void echo(sp&lt;IBinder&gt; client, const char *name) &#123; Parcel request, reply; char buff[1024]; memset(buff, 0, sizeof(buff)); sprintf(buff, &quot;hello %s from HelloNativeService&quot;, name); request.writeCString(buff); client-&gt;transact(CALLBACK_SAY_HELLO, request, &amp;reply);&#125;static int sum(int a, int b) &#123; return a + b;&#125;HelloNativeService::HelloNativeService() &#123; LOGD(&quot;HelloNativeService created&quot;);&#125;int HelloNativeService::instantiate() &#123; int r &#x3D; defaultServiceManager()-&gt;addService(String16(&quot;HelloNativeService&quot;), new HelloNativeService()); LOGD(&quot;add HelloNativeService r &#x3D; %d&quot;, r); return r;&#125;status_tHelloNativeService::onTransact(uint32_t code, const Parcel &amp;request, Parcel *reply, uint32_t flag) &#123; LOGD(&quot;service onTransact code &#x3D; %d&quot;, code); switch (code) &#123; case CMD_SAY_HELLO: &#123; const char *name &#x3D; request.readCString(); sayHello(name); echo(client, name); return NO_ERROR; &#125; case CMD_CAL_SUM: &#123; int a &#x3D; request.readInt32(); int b &#x3D; request.readInt32(); reply-&gt;writeInt32(sum(a, b)); return NO_ERROR; &#125; case CMD_CONNECT: &#123; client &#x3D; request.readStrongBinder(); return NO_ERROR; &#125; &#125; return BBinder::onTransact(code, request, reply, flag);&#125; 增加了一个 CMD_CONNECT 命令，通过 readStrongBinder 把 client 传送过来的 callback 对象给读取保存下来。后面需要回调客户端的时候只需要通过 client 这个 binder 就可以。client binder 与 server binder 的一个差异是 client binder 对象不需要添加到系统服务里面去，而是通过 writeStrongBinder 直接传送给 server。 3. 编译验证123456789101112pure:&#x2F; # HelloNativeTest Callback onTransactmsg from server:hello qiushao from HelloNativeServicesum of 2 + 3 &#x3D; 5pure:&#x2F; # logcat -s HelloNativeService--------- beginning of system--------- beginning of main01-12 17:07:34.250 1645 1660 D HelloNativeService: service onTransact code &#x3D; 301-12 17:07:34.252 1645 1660 D HelloNativeService: service onTransact code &#x3D; 101-12 17:07:34.252 1645 1660 D HelloNativeService: hello qiushao from HelloNativeService01-12 17:07:34.252 1645 1660 D HelloNativeService: service onTransact code &#x3D; 2130|pure:&#x2F; #","categories":[{"name":"Android系统开发入门","slug":"Android系统开发入门","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发入门-9.添加native系统服务","slug":"Android系统开发入门/9-添加native系统服务","date":"2019-12-29T12:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2019/12/29/Android系统开发入门/9-添加native系统服务/","link":"","permalink":"http://qiushao.net/2019/12/29/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/9-%E6%B7%BB%E5%8A%A0native%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"上一小节我们学习了 java 层的系统服务，但有时候出于性能方面的考虑，有些服务是需要使用 c++ 来实现的，比如音视频编解码，图形绘制等。 Android 系统原生的 MediaPlayerService 和 SurfaceFlinger 就是使用 c++ 实现的 Native 系统服务。这一小节我们就来学习一下如何添加一个 HelloNativeService。 1. 声明服务接口我们先在 $device 目录下创建 HelloNativeService 目录 12cd device&#x2F;qiushao&#x2F;puremkdir -p models&#x2F;HelloNativeService 然后创建 service 的头文件 HelloNativeService.h 123456789101112131415#ifndef ANDROID_10_HELLONATIVESERVICE_H#define ANDROID_10_HELLONATIVESERVICE_H#include &lt;binder&#x2F;IInterface.h&gt;#include &lt;binder&#x2F;Parcel.h&gt;#include &lt;utils&#x2F;Errors.h&gt;using namespace android;class HelloNativeService: public BBinder &#123;public: HelloNativeService(); static int instantiate(); virtual status_t onTransact(uint32_t, const Parcel&amp;, Parcel*, uint32_t);&#125;;#endif &#x2F;&#x2F;ANDROID_10_HELLONATIVESERVICE_H 这里我们直接继承的是 BBinder， 而不是像其他教程一样又 BpInterface， 又 BnInterface 的，还把 BpInterface 跟 BnInterface 的实现放到同一个 cpp 文件中， 把 client 跟 server 的代码放到同一个文件中，个人感觉把简单的事情复杂化了。 2. 实现服务功能创建文件 HelloNativeService.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;android&#x2F;log.h&gt;#include &lt;binder&#x2F;IServiceManager.h&gt;#include &lt;binder&#x2F;IPCThreadState.h&gt;#include &quot;HelloNativeService.h&quot;#define LOG_TAG &quot;HelloNativeService&quot;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)enum &#123; CMD_SAY_HELLO &#x3D; 1, CMD_CAL_SUM &#x3D; 2&#125;;static void sayHello(const char *name) &#123; LOGD(&quot;hello %s from HelloNativeService&quot;, name);&#125;static int sum(int a, int b) &#123; return a + b;&#125;HelloNativeService::HelloNativeService() &#123; LOGD(&quot;HelloNativeService created&quot;);&#125;int HelloNativeService::instantiate() &#123; int r &#x3D; defaultServiceManager()-&gt;addService(String16(&quot;HelloNativeService&quot;),new HelloNativeService()); LOGD(&quot;add HelloNativeService r &#x3D; %d&quot;, r); return r;&#125;status_t HelloNativeService::onTransact(uint32_t code, const Parcel &amp;request, Parcel *reply, uint32_t flag) &#123; switch (code) &#123; case CMD_SAY_HELLO: sayHello(request.readCString()); return NO_ERROR; case CMD_CAL_SUM: int a &#x3D; request.readInt32(); int b &#x3D; request.readInt32(); reply-&gt;writeInt32(sum(a, b)); return NO_ERROR; &#125; return BBinder::onTransact(code, request, reply, flag);&#125; 其中最重要的是 onTransact 函数的实现，这是一个回调函数，当 client 端通过 binder 调用 server 功能的时候， server 端的 onTransact 回调函数就会被调用。各参数理解如下： code : 表示要执行的动作，类似Handler发送的Message的what。code指示了当前远程操作的命令，IBinder定义了像INTERFACE_TRANSACTION、PING_TRANSACTION 这样的几个通用命令。自己使用的命令的标识值需要在FIRST_CALL_TRANSACTION和LAST_CALL_TRANSACTION之间。 request， reply ： request 和 reply 参数相当于普通函数里的调用参数和返回值。Parcel类型是可以跨进程的数据。 flag ： 参数 flags 只有 0 和 FLAG_ONEWAY 两种。0 表示阻塞调用， FLAG_ONEWAY 表示异步调用。这个参数不需要我们在服务端处理， Binder 框架会自动处理。 3. 添加 main.cpp前面我们定义了服务接口而已，这个服务也是需要依赖在某个进程才能运行的 123456789101112131415#include &lt;binder&#x2F;IServiceManager.h&gt;#include &lt;binder&#x2F;IPCThreadState.h&gt;#include &quot;HelloNativeService.h&quot;using namespace android;int main(int argc, char *argv[]) &#123; sp&lt;ProcessState&gt; proc(ProcessState::self()); HelloNativeService::instantiate(); ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool(); return 0;&#125; 以上都是样板代码，具体 ProcessState 的功能作用是什么这里就不展开了。 4. Android.bp1234567891011cc_binary &#123; name: &quot;HelloNativeService&quot;, srcs: [&quot;main.cpp&quot;, &quot;HelloNativeService.cpp&quot;], shared_libs: [ &quot;liblog&quot;, &quot;libcutils&quot;, &quot;libutils&quot;, &quot;libbinder&quot;, ],&#125; 5. selinux 规则设置为了简单起见，我们直接修改系统默认的 sepolicy 规则路径了。 5.1 添加 HelloNativeService.tesystem/sepolicy/private/HelloNativeService.te 和 system/sepolicy/prebuilts/api/29.0/private/HelloNativeService.te 文件内容保持一致 1234567type HelloNativeService, domain;typeattribute HelloNativeService coredomain;type HelloNativeService_exec, system_file_type, exec_type, file_type;binder_use(HelloNativeService)init_daemon_domain(HelloNativeService)allow HelloNativeService HelloNativeService_service:service_manager &#123; add find &#125;; 5.2 修改 file_contextssystem/sepolicy/private/file_contexts 和 system/sepolicy/prebuilts/api/29.0/private/file_contexts 文件内容保持一致添加以下配置 1&#x2F;system&#x2F;bin&#x2F;HelloNativeService u:object_r:HelloNativeService_exec:s0 5.3 修改 service_contextssystem/sepolicy/private/service_contexts 和 system/sepolicy/prebuilts/api/29.0/private/service_contexts 文件内容保持一致添加以下配置 1HelloNativeService u:object_r:HelloNativeService_service:s0 5.4 修改 service.tesystem/sepolicy/private/service.te 和 system/sepolicy/prebuilts/api/29.0/private/service.te添加以下配置 1type HelloNativeService_service, service_manager_type; 6. 开机自动运行在 device/qiushao/pure 目录添加rc文件 init.ranchu.rc 12345service HelloNativeService &#x2F;system&#x2F;bin&#x2F;HelloNativeService class core user root group root seclabel u:r:HelloNativeService:s0 在 pure.mk 中添加以下配置， 这个配置需要添加在 $(call inherit-product, $(SRC_TARGET_DIR)/product/aosp_x86_64.mk) 之前。 1PRODUCT_COPY_FILES +&#x3D; device&#x2F;qiushao&#x2F;pure&#x2F;init.ranchu.rc:root&#x2F;init.ranchu.rc 7. 编写 client 调用服务我们把测试代码跟 service 放在同一个目录，直接在 HelloNativeService 目录下创建 HelloNativeTest.cpp 文件： 1234567891011121314151617181920212223242526272829303132333435#include &lt;binder&#x2F;IServiceManager.h&gt;#include &lt;binder&#x2F;Parcel.h&gt;#include &lt;utils&#x2F;Errors.h&gt;#include &lt;stdio.h&gt;using namespace android;enum &#123; CMD_SAY_HELLO &#x3D; 1, CMD_CAL_SUM &#x3D; 2&#125;;static sp&lt;IBinder&gt; service;static void test_sayHello() &#123; Parcel request, reply; request.writeCString(&quot;qiushao&quot;); service-&gt;transact(CMD_SAY_HELLO, request, &amp;reply);&#125;static void test_calSum() &#123; Parcel request, reply; request.writeInt32(2); request.writeInt32(3); service-&gt;transact(CMD_CAL_SUM, request, &amp;reply); int sum &#x3D; reply.readInt32(); printf(&quot;sum of 2 + 3 &#x3D; %d\\n&quot;, sum);&#125;int main () &#123; service &#x3D; defaultServiceManager()-&gt;getService(String16(&quot;HelloNativeService&quot;)); test_sayHello(); test_calSum(); return 0;&#125; Android.bp 中添加 1234567891011cc_binary &#123; name: &quot;HelloNativeTest&quot;, srcs: [&quot;HelloNativeTest.cpp&quot;], shared_libs: [ &quot;liblog&quot;, &quot;libcutils&quot;, &quot;libutils&quot;, &quot;libbinder&quot;, ],&#125; 8. 编译运行经过以上步骤，我们的 native 服务和测试 demo 就完成了，目录结构如下： 123456789qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10&#x2F;device&#x2F;qiushao&#x2F;pure&#x2F;models$ tree HelloNativeService&#x2F;HelloNativeService&#x2F;├── Android.bp├── HelloNativeService.cpp├── HelloNativeService.h├── HelloNativeTest.cpp└── main.cpp0 directories, 5 files 我们还需要把刚刚添加的这两个模块添加到 PRODUCT_PACKAGES 1PRODUCT_PACKAGES +&#x3D; HelloNativeService HelloNativeTest 然后编译运行，查看服务列表，可以看到我们的 HelloNativeService 已经在运行状态了。然后执行 HelloNativeTest，服务端正确返回了计算结果。查看一下 logcat， HelloNativeService 也正确收到了 HelloNativeTest 传递过来的数据。 1234567891011121314qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10$ adb shellpure:&#x2F; # service list | grep -i hello 15 HelloService: [android.pure.IHelloService]161 HelloNativeService: []pure:&#x2F; # pure:&#x2F; # HelloNativeTestsum of 2 + 3 &#x3D; 5pure:&#x2F; # pure:&#x2F; # logcat -s HelloNativeService--------- beginning of main--------- beginning of system01-05 00:03:19.788 1661 1661 D HelloNativeService: HelloNativeService created01-05 00:03:19.788 1661 1661 D HelloNativeService: add HelloNativeService r &#x3D; 0&#x2F;n01-05 00:05:50.011 1661 1670 D HelloNativeService: hello qiushao from HelloNativeService","categories":[{"name":"Android系统开发入门","slug":"Android系统开发入门","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发入门-8.java服务回调","slug":"Android系统开发入门/8-java服务回调","date":"2019-12-22T12:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2019/12/22/Android系统开发入门/8-java服务回调/","link":"","permalink":"http://qiushao.net/2019/12/22/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/8-java%E6%9C%8D%E5%8A%A1%E5%9B%9E%E8%B0%83/","excerpt":"","text":"上一小节我们添加了一个 java service，也写了一个 client 来做测试。但只是单向的从 client 调用 service，实际项目中我们经常是需要双向调用的。某些事件发生的时候，service 端需要通知 client 来处理。这节我们就来学习一下如何从 service 端回调 client。为了简单起见，我们直接在上一小节的代码基础上进行修改。 1. 使用 aidl 定义callback接口在 frameworks/base/core/java/android/pure 目录下创建 ICallback.aidl 1234package android.pure;interface ICallback &#123; void onMessage(in String message);&#125; 在 frameworks/base/Android.bp framework-defaults 模块中添加我们刚刚加的 aidl 文件 1&quot;core&#x2F;java&#x2F;android&#x2F;pure&#x2F;ICallback.aidl&quot;, 然后进入 framework/base 目录执行 mm -j 命令编译 framework.jar 模块。编译成功后，会在 out/soong/.intermediates/frameworks/base/framework/android_common/gen/aidl/frameworks/base/core/java/android/pure 目录生成 ICallback.java 这个文件。 2. 添加注册回调接口修改 IHelloService.aidl 如下 1234567package android.pure;import android.pure.ICallback;interface IHelloService &#123; void hello(in String name); void registerCallback(in int pid, in ICallback callback); void unregisterCallback(in int pid);&#125; HelloService.java 修改如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.android.server;import android.os.RemoteException;import android.pure.IHelloService;import android.pure.ICallback;import android.util.Log;import java.util.HashMap;import java.util.Map;public class HelloService extends IHelloService.Stub &#123; private final String TAG &#x3D; &quot;HelloService&quot;; private Map&lt;Integer, ICallback&gt; mClients; public HelloService() &#123; Log.d(TAG, &quot;create hello service&quot;); mClients &#x3D; new HashMap&lt;&gt;(); &#125; @Override public void hello(String name) &#123; Log.d(TAG, &quot;hello &quot; + name); try &#123; for (ICallback callback : mClients.values()) &#123; callback.onMessage(&quot;message from service&quot;); &#125; &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void registerCallback(int pid, ICallback callback) &#123; mClients.put(pid, callback); Log.d(TAG, &quot;registerCallback client&#39;s size &#x3D; &quot; + mClients.size()); &#125; @Override public void unregisterCallback(int pid) &#123; mClients.remove(pid); Log.d(TAG, &quot;unregisterCallback client&#39;s size &#x3D; &quot; + mClients.size()); &#125;&#125; 我们把 client 传递过来的 callback 保存到 mClients 集合中，当 client 调用 hello 接口时， 遍历 mclients 把消息传递给 client。 3. client 注册回调接口修改 PureSettings apk 中的 MainActivity 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.pure.settings;import android.app.Activity;import android.os.Bundle;import android.os.RemoteException;import android.os.ServiceManager;import android.pure.ICallback;import android.pure.IHelloService;import android.util.Log;import android.view.View;import android.widget.Button;public class MainActivity extends Activity &#123; private static final String TAG &#x3D; &quot;PureSettings&quot;; private IHelloService service &#x3D; null; private Button button; private ICallback callback &#x3D; new ICallback.Stub() &#123; @Override public void onMessage(String message) throws RemoteException &#123; Log.d(TAG, &quot;onMessage:&quot; + message); &#125; &#125;; private void test() &#123; Log.d(TAG, &quot;test&quot;); try &#123; service.hello(&quot;qiushao&quot;); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); service &#x3D; IHelloService.Stub.asInterface(ServiceManager.getService(&quot;HelloService&quot;)); button &#x3D; (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; test(); &#125; &#125;); &#125; @Override protected void onResume() &#123; super.onResume(); try &#123; service.registerCallback(android.os.Process.myPid(), callback); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); try &#123; service.unregisterCallback(android.os.Process.myPid()); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 4. 编译验证整编系统，运行虚拟机，打开 PureSettings 测试，查看 logcat 1234567pure:&#x2F; # logcat -s HelloService:D PureSettings:D02-02 22:57:37.913 1769 1769 D HelloService: create hello service02-02 22:57:53.498 1769 3058 D HelloService: registerCallback client&#39;s size &#x3D; 102-02 22:57:56.587 3580 3580 D PureSettings: test02-02 22:57:56.587 1769 3058 D HelloService: hello qiushao02-02 22:57:56.588 3580 3580 D PureSettings: onMessage:message from service02-02 22:58:01.160 1769 3503 D HelloService: unregisterCallback client&#39;s size &#x3D; 0 从 log 上看，client 收到了 service 传递过来的消息。","categories":[{"name":"Android系统开发入门","slug":"Android系统开发入门","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发入门-7.添加java层系统服务","slug":"Android系统开发入门/7-添加java系统服务","date":"2019-12-20T12:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2019/12/20/Android系统开发入门/7-添加java系统服务/","link":"","permalink":"http://qiushao.net/2019/12/20/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/7-%E6%B7%BB%E5%8A%A0java%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"我们作为一个系统开发人员，经常要与各种服务打交道，什么 ActivityManagerService啊，PackageManagerService啊， PowerManagerService啊的。大部分场景是都只需要打打 patch 就行了， 但有时候我们也需要添加一些自定义的服务的。服务可以有很多种形式， 但这里讨论的是如何添加 java 层的系统服务。 1. 使用 aidl 定义服务接口首先我们得定义我们的服务名是什么，提供什么样的接口。在这个例子里面，我们的服务就叫 HelloService，它提供了下接口： void hello(String name) //播放指定路径的音频文件 在 frameworks/base/core/java/android 目录下创建 pure 目录，我们把代码放到 pure 里面。pure 目录下增加中文件 IHelloService.aidl 1234package android.pure;interface IHelloService &#123; void hello(String name);&#125; 在 frameworks/base/Android.bp framework-defaults 模块中添加我们刚刚加的 aidl 文件 1&quot;core&#x2F;java&#x2F;android&#x2F;pure&#x2F;IHelloService.aidl&quot;, 然后进入 framework/base 目录执行 mm -j 命令编译 framework.jar 模块。编译成功后，会在 out/soong/.intermediates/frameworks/base/framework/android_common/gen/aidl/frameworks/base/core/java/android/pure 目录生成 IHelloService.java 这个文件。 这个文件封装了 binder 通信的相关细节，有兴趣的同学可以去了解一下。 2. 实现接口在 frameworks/base/services/core/java/com/android/server 目录下新建 HelloService.java 文件： 1234567891011121314151617package com.android.server;import android.pure.IHelloService;import android.util.Log;public class HelloService extends IHelloService.Stub &#123; private final String TAG &#x3D; &quot;HelloService&quot;; public HelloService() &#123; Log.d(TAG, &quot;create hello service&quot;); &#125; @Override public void hello(String name) &#123; Log.d(TAG, &quot;hello &quot; + name); &#125;&#125; 3. 将服务添加到 ServiceManager修改 frameworks/base/services/java/com/android/server/SystemServer.java 文件，在 startOtherServices 方法里面增加以下代码： 1234&#x2F;&#x2F; add hello servicetraceBeginAndSlog(&quot;HelloService&quot;);ServiceManager.addService(&quot;HelloService&quot;, new HelloService());traceEnd(); 至此服务算是添加完了，我们来编译运行一下，发现系统起不来了，看下错误 log 1234567891011121314151617181912-20 23:46:47.308 3521 3521 I SystemServer: HelloService12-20 23:46:47.308 3521 3521 D HelloService: create hello service12-20 23:46:47.308 1526 1526 E SELinux : avc: denied &#123; add &#125; for service&#x3D;HelloService pid&#x3D;3521 uid&#x3D;1000 scontext&#x3D;u:r:system_server:s0 tcontext&#x3D;u:object_r:default_android_service:s0 tclass&#x3D;service_manager permissive&#x3D;012-20 23:46:47.308 1526 1526 E ServiceManager: add_service(&#39;HelloService&#39;,95) uid&#x3D;1000 - PERMISSION DENIED12-20 23:46:47.308 3521 3521 E System : ******************************************12-20 23:46:47.308 3521 3521 E System : ************ Failure starting system services12-20 23:46:47.308 3521 3521 E System : java.lang.SecurityException12-20 23:46:47.308 3521 3521 E System : at android.os.BinderProxy.transactNative(Native Method)12-20 23:46:47.308 3521 3521 E System : at android.os.BinderProxy.transact(BinderProxy.java:510)12-20 23:46:47.308 3521 3521 E System : at android.os.ServiceManagerProxy.addService(ServiceManagerNative.java:156)12-20 23:46:47.308 3521 3521 E System : at android.os.ServiceManager.addService(ServiceManager.java:192)12-20 23:46:47.308 3521 3521 E System : at android.os.ServiceManager.addService(ServiceManager.java:161)12-20 23:46:47.308 3521 3521 E System : at com.android.server.SystemServer.startOtherServices(SystemServer.java:1914)12-20 23:46:47.308 3521 3521 E System : at com.android.server.SystemServer.run(SystemServer.java:512)12-20 23:46:47.308 3521 3521 E System : at com.android.server.SystemServer.main(SystemServer.java:349)12-20 23:46:47.308 3521 3521 E System : at java.lang.reflect.Method.invoke(Native Method)12-20 23:46:47.308 3521 3521 E System : at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)12-20 23:46:47.308 3521 3521 E System : at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:908)12-20 23:46:47.308 3521 3521 D SystemServerTiming: HelloService took to complete: 1ms 从 SELinux : avc: denied { add } for service=HelloService 这个信息来看，是因为我们没有添加 SELinux 规则，什么是 SELinux 这里就不展开了，同学们可以自己去查下资料。 4. selinux 规则设置Android 10 的 selinux 规则是放在 system/sepolicy 目录下的。但 Android 每个版本 selinux 的添加规则多多少少是有些变化的，我们要怎么把这个新服务的 SELinux 规则给加上呢, 我们可以参考现有的系统服务的规则去添加，这里参考的是 network_time_update_service 服务： 12345678910111213141516171819cd system&#x2F;sepolicygrep -nr network_time_update_service...prebuilts&#x2F;api&#x2F;28.0&#x2F;plat_pub_versioned.cil:2650:(type network_time_update_service)prebuilts&#x2F;api&#x2F;28.0&#x2F;plat_pub_versioned.cil:2651:(typeattribute network_time_update_service_28_0)prebuilts&#x2F;api&#x2F;28.0&#x2F;plat_pub_versioned.cil:2652:(roletype object_r network_time_update_service_28_0)prebuilts&#x2F;api&#x2F;28.0&#x2F;public&#x2F;service.te:107:type network_time_update_service, system_server_service, service_manager_type;prebuilts&#x2F;api&#x2F;28.0&#x2F;private&#x2F;compat&#x2F;27.0&#x2F;27.0.cil:385:(expandtypeattribute (network_time_update_service_27_0) true)prebuilts&#x2F;api&#x2F;28.0&#x2F;private&#x2F;compat&#x2F;27.0&#x2F;27.0.cil:1102:(typeattributeset network_time_update_service_27_0 (network_time_update_service))prebuilts&#x2F;api&#x2F;28.0&#x2F;private&#x2F;compat&#x2F;26.0&#x2F;26.0.cil:389:(typeattributeset network_time_update_service_26_0 (network_time_update_service))prebuilts&#x2F;api&#x2F;28.0&#x2F;private&#x2F;service_contexts:109:network_time_update_service u:object_r:network_time_update_service:s0public&#x2F;service.te:125:type network_time_update_service, system_server_service, service_manager_type;private&#x2F;compat&#x2F;27.0&#x2F;27.0.cil:391:(expandtypeattribute (network_time_update_service_27_0) true)private&#x2F;compat&#x2F;27.0&#x2F;27.0.cil:1108:(typeattributeset network_time_update_service_27_0 (network_time_update_service))private&#x2F;compat&#x2F;26.0&#x2F;26.0.cil:395:(typeattributeset network_time_update_service_26_0 (network_time_update_service))private&#x2F;compat&#x2F;28.0&#x2F;28.0.cil:463:(expandtypeattribute (network_time_update_service_28_0) true)private&#x2F;compat&#x2F;28.0&#x2F;28.0.cil:1306:(typeattributeset network_time_update_service_28_0 (network_time_update_service))private&#x2F;service_contexts:132:network_time_update_service u:object_r:network_time_update_service:s0 涉及到的文件很多，有部分文件是不需要修改的，我们先把找到的所有 service.te 和 service_contexts 都参考 network_time_update_service 加上 HelloService 的配置。 service_contexts 加上 1HelloService u:object_r:HelloService:s0 service.te 加上 1type HelloService, system_server_service, service_manager_type; 5. 编译验证完成以上各步骤的修改后，我们就可以先来验证一下，服务是否添加成功了。先 make api-stubs-docs-update-current-api -j20 更新一下 api 接口，再整编系统。运行虚拟机，执行 service list 看看有没有 HelloService 服务。 123pure:&#x2F; # service list | grep HelloService 16 HelloService: [android.pure.IHelloService]pure:&#x2F; # 6. 客户端调用我们创建完服务端之后，还要考虑怎么提供 api 接口给到 client 使用。我们分为两种情况来讨论。 6.1 系统源码中使用假如我们上面添加的服务是给在系统源码中编译的模块使用的，那就简单了。比如一个 apk ，我们在系统源码中创建一个 apk 模块。目录结构如下： 1234567891011121314151617qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10&#x2F;device&#x2F;qiushao&#x2F;pure&#x2F;models$ tree PureSettings&#x2F;PureSettings&#x2F;├── Android.bp├── AndroidManifest.xml├── res│ ├── layout│ │ └── activity_main.xml│ └── mipmap-hdpi│ └── ic_launcher.png└── src └── com └── pure └── settings └── MainActivity.java7 directories, 5 filesqiushao@qiushao-pc:~&#x2F;source&#x2F;android-10&#x2F;device&#x2F;qiushao&#x2F;pure&#x2F;models$ Android.bp： 1234567android_app &#123; srcs: [&quot;src&#x2F;**&#x2F;*.java&quot;], resource_dirs: [&quot;res&quot;], name: &quot;PureSettings&quot;, certificate: &quot;platform&quot;, platform_apis: true,&#125; 其中 platform_apis 要设置为 true，不然没法调用我们新加的服务和 ServiceManager 。 AndroidManifest.xml： 1234567891011121314&lt;manifest xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; package&#x3D;&quot;com.pure.settings&quot;&gt; &lt;application android:icon&#x3D;&quot;@mipmap&#x2F;ic_launcher&quot; android:label&#x3D;&quot;PureSettings&quot; android:supportsRtl&#x3D;&quot;true&quot;&gt; &lt;activity android:name&#x3D;&quot;com.pure.settings.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name&#x3D;&quot;android.intent.action.MAIN&quot; &#x2F;&gt; &lt;category android:name&#x3D;&quot;android.intent.category.LAUNCHER&quot; &#x2F;&gt; &lt;&#x2F;intent-filter&gt; &lt;&#x2F;activity&gt; &lt;&#x2F;application&gt;&lt;&#x2F;manifest&gt; res/layout/activity_main.xml: 1234567891011121314&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot; xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot; android:orientation&#x3D;&quot;vertical&quot; tools:context&#x3D;&quot;.MainActivity&quot;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;button&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;test&quot; &#x2F;&gt;&lt;&#x2F;LinearLayout&gt; src/com/pure/settings/MainActivity.java: 1234567891011121314151617181920212223242526272829303132333435363738394041package com.pure.settings;import android.app.Activity;import android.os.Bundle;import android.os.RemoteException;import android.os.ServiceManager;import android.pure.IHelloService;import android.util.Log;import android.view.View;import android.widget.Button;public class MainActivity extends Activity &#123; private static final String TAG &#x3D; &quot;PureSettings&quot;; private IHelloService service &#x3D; null; private Button button; private void test() &#123; Log.d(TAG, &quot;test&quot;); try &#123; service.hello(&quot;qiushao&quot;); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); service &#x3D; IHelloService.Stub.asInterface(ServiceManager.getService(&quot;HelloService&quot;)); button &#x3D; (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; test(); &#125; &#125;); &#125;&#125; 把模块添加到系统, pure.mk: 1PRODUCT_PACKAGES +&#x3D; PureSettings 编译运行，闪退了，看下错误日志，发现： 112-21 23:55:32.970 1526 1526 E SELinux : avc: denied &#123; find &#125; for service&#x3D;HelloService pid&#x3D;4266 uid&#x3D;10102 scontext&#x3D;u:r:platform_app:s0:c512,c768 tcontext&#x3D;u:object_r:HelloService:s0 tclass&#x3D;service_manager permissive&#x3D;0 看起来是还有 selinux 权限需要添加。具体分析如下缺少什么权限：{find}权限，谁缺少权限：scontext=u:r:platform_app:s0:c512,c768对哪个文件缺少权限：tcontext=u:object_r:HelloService:s0什么类型的文件：tclass=service_manager 完整的意思： platform_app 缺少 service_manager 类型的 HelloService 的 find 权限。 根据以上分析，我们就可以找到解决方案：在 platform_app.te 中添加 HelloService 的 find 权限即可。 1allow platform_app HelloService:service_manager find; 我们查找一下有哪些 platform_app.te 文件： 1234567891011qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10&#x2F;system&#x2F;sepolicy$ find -name platform_app.te .&#x2F;prebuilts&#x2F;api&#x2F;27.0&#x2F;public&#x2F;platform_app.te.&#x2F;prebuilts&#x2F;api&#x2F;27.0&#x2F;private&#x2F;platform_app.te.&#x2F;prebuilts&#x2F;api&#x2F;29.0&#x2F;public&#x2F;platform_app.te.&#x2F;prebuilts&#x2F;api&#x2F;29.0&#x2F;private&#x2F;platform_app.te.&#x2F;prebuilts&#x2F;api&#x2F;26.0&#x2F;public&#x2F;platform_app.te.&#x2F;prebuilts&#x2F;api&#x2F;26.0&#x2F;private&#x2F;platform_app.te.&#x2F;prebuilts&#x2F;api&#x2F;28.0&#x2F;public&#x2F;platform_app.te.&#x2F;prebuilts&#x2F;api&#x2F;28.0&#x2F;private&#x2F;platform_app.te.&#x2F;public&#x2F;platform_app.te.&#x2F;private&#x2F;platform_app.te 把找到的所有 private/platform_app.te 都加上后，再重新编译运行发现不会挂了，看下 logcat: 123130|pure:&#x2F; # logcat -c;logcat -s &quot;HelloService:V&quot; &quot;PureSettings:V&quot; 12-22 10:47:26.505 4291 4291 D PureSettings: test12-22 10:47:26.506 1757 3514 D HelloService: hello qiushao 的确调用到了我们添加的服务。 6.2 非系统源码中使用前面实现了在 Android 系统源码中调用新添加服务的方法，但在实际项目中很多情况是在非系统源码环境下使用的。这种情况我们一般是再封装一层接口出来。调用的层级为： apk –&gt; HelloApi –&gt; HelloService我们按以下目录结构创建 HelloApi 模块： 1234567891011qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10&#x2F;device&#x2F;qiushao&#x2F;pure&#x2F;models$ tree HelloApi&#x2F;HelloApi&#x2F;├── Android.bp└── java └── com └── pure └── api └── HelloManager.java4 directories, 2 filesqiushao@qiushao-pc:~&#x2F;source&#x2F;android-10&#x2F;device&#x2F;qiushao&#x2F;pure&#x2F;models$ Android.bp: 1234567java_library &#123; name: &quot;com.pure.api&quot;, installable: true, srcs: [ &quot;java&#x2F;**&#x2F;*.java&quot;, &#x2F;&#x2F;文件列表 ],&#125; HelloManager.java: 1234567891011121314151617181920212223242526272829package com.pure.api;import android.os.RemoteException;import android.os.ServiceManager;import android.pure.IHelloService;public class HelloManager &#123; private static HelloManager mInstance &#x3D; null; public static HelloManager getInstance() &#123; if (null &#x3D;&#x3D; mInstance) &#123; mInstance &#x3D; new HelloManager(); &#125; return mInstance; &#125; private IHelloService mService &#x3D; null; private HelloManager() &#123; mService &#x3D; IHelloService.Stub.asInterface(ServiceManager.getService(&quot;HelloService&quot;)); &#125; public void sayHello(String name) &#123; try &#123; mService.hello(name); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 然后到 HelloApi 目录 mm 编译模块，得到 out/target/common/obj/JAVA_LIBRARIES/com.pure.api_intermediates/classes.jar 文件。我们把这个 classes.jar 文件，复制到用 android-studio 创建的 apk 项目 的 app/libs 目录下，改名为 com.pure.api.jar 。右键单击 com.pure.api.jar 选择 add as library， 然后我们就可以在 apk 的代码中使用 com.pure.api.jar 的接口了： 123456789...public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); HelloManager.getInstance().sayHello(&quot;qiushao&quot;); &#125;&#125; 安装 apk 到虚拟机上运行，又遇到了 SELinux : avc: denied 错误，这次的错误是 E SELinux : avc: denied { find } for service=HelloService pid=4266 uid=10102 scontext=u:r:untrusted_app:s0:c512,c768 tcontext=u:object_r:HelloService:s0 tclass=service_manager permissive=0跟上面的错误基本上是一样的，只不过是把 platform_app 换成了 untrusted_app 而已。platform_app 表示有系统签名的 apk， untrusted_app 表示没有系统签名的 apk。我们按同样的思路添加完 selinux 的权限后，重新编译运行虚拟机，就可以正常调用服务的接口了。","categories":[{"name":"Android系统开发入门","slug":"Android系统开发入门","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发入门-6.删除Android原生内置APK","slug":"Android系统开发入门/6-删除原生内置APK","date":"2019-12-12T14:26:26.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2019/12/12/Android系统开发入门/6-删除原生内置APK/","link":"","permalink":"http://qiushao.net/2019/12/12/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/6-%E5%88%A0%E9%99%A4%E5%8E%9F%E7%94%9F%E5%86%85%E7%BD%AEAPK/","excerpt":"","text":"Android 系统内置了很多应用，比如说通信录，日历，计算器，相机等， 对于 TV 来说，这些应用是没有什么用的，只是占用系统空间而已。为了节剩一下系统空间，我们在编译系统时要把这些模块给去掉。以下介绍两种方法来达到我们的目的。 1. 直接从 PRODUCT_PACKAGES 中删除比如说我们要删除通信录 Contacts 这个应用，我们可以查找一下这个应用是在哪里加入到 PRODUCT_PACKAGES 的。 12345678910111213141516171819202122qiushao@qiushao-PC:~&#x2F;source&#x2F;android-8.1$ mgrep Contacts.&#x2F;build&#x2F;make&#x2F;target&#x2F;product&#x2F;core_tiny.mk:22: ContactsProvider \\.&#x2F;build&#x2F;make&#x2F;target&#x2F;product&#x2F;core_base.mk:24: ContactsProvider \\.&#x2F;build&#x2F;make&#x2F;target&#x2F;product&#x2F;core.mk:33: Contacts \\.&#x2F;device&#x2F;google&#x2F;atv&#x2F;products&#x2F;atv_base.mk:32: ContactsProvider \\.&#x2F;platform_testing&#x2F;build&#x2F;tasks&#x2F;tests&#x2F;instrumentation_test_list.mk:35: ContactsProviderTests \\.&#x2F;platform_testing&#x2F;build&#x2F;tasks&#x2F;tests&#x2F;instrumentation_test_list.mk:36: ContactsProviderTests2 \\.&#x2F;packages&#x2F;services&#x2F;Car&#x2F;car_product&#x2F;build&#x2F;car_base.mk:23: ContactsProvider \\.&#x2F;packages&#x2F;services&#x2F;Telephony&#x2F;Android.mk:3:# Build the Phone app which includes the emergency dialer. See Contacts.&#x2F;packages&#x2F;apps&#x2F;Contacts&#x2F;CleanSpec.mk:50:$(call add-clean-step, rm -rf $(OUT_DIR)&#x2F;target&#x2F;common&#x2F;obj&#x2F;APPS&#x2F;Contacts_intermediates).&#x2F;packages&#x2F;apps&#x2F;Contacts&#x2F;tests&#x2F;Android.mk:13:LOCAL_PACKAGE_NAME :&#x3D; ContactsTests.&#x2F;packages&#x2F;apps&#x2F;Contacts&#x2F;tests&#x2F;Android.mk:15:LOCAL_INSTRUMENTATION_FOR :&#x3D; Contacts.&#x2F;packages&#x2F;apps&#x2F;Contacts&#x2F;Android.mk:53:LOCAL_PACKAGE_NAME :&#x3D; Contacts.&#x2F;packages&#x2F;providers&#x2F;ContactsProvider&#x2F;tests2&#x2F;Android.mk:23: ContactsProviderTestUtils \\.&#x2F;packages&#x2F;providers&#x2F;ContactsProvider&#x2F;tests2&#x2F;Android.mk:32:LOCAL_PACKAGE_NAME :&#x3D; ContactsProviderTests2.&#x2F;packages&#x2F;providers&#x2F;ContactsProvider&#x2F;tests2&#x2F;Android.mk:35:LOCAL_INSTRUMENTATION_FOR :&#x3D; ContactsProvider.&#x2F;packages&#x2F;providers&#x2F;ContactsProvider&#x2F;test_common&#x2F;Android.mk:29:LOCAL_MODULE :&#x3D; ContactsProviderTestUtils.&#x2F;packages&#x2F;providers&#x2F;ContactsProvider&#x2F;tests&#x2F;Android.mk:8: ContactsProviderTestUtils \\.&#x2F;packages&#x2F;providers&#x2F;ContactsProvider&#x2F;tests&#x2F;Android.mk:18:LOCAL_PACKAGE_NAME :&#x3D; ContactsProviderTests.&#x2F;packages&#x2F;providers&#x2F;ContactsProvider&#x2F;tests&#x2F;Android.mk:21:LOCAL_INSTRUMENTATION_FOR :&#x3D; ContactsProvider.&#x2F;packages&#x2F;providers&#x2F;ContactsProvider&#x2F;Android.mk:22:LOCAL_PACKAGE_NAME :&#x3D; ContactsProvider.&#x2F;cts&#x2F;tests&#x2F;tests&#x2F;contactsproviderwipe&#x2F;Android.mk:35:LOCAL_PACKAGE_NAME :&#x3D; CtsContactsProviderWipe 看一下搜索的结果应该可以知道是 ./build/make/target/product/core.mk 这个文件里面添加了 Contacts 应用。 很多系统原生的应用也是在这里面添加的。我们可以直接在这里面删除即可。 2. 通过 LOCAL_OVERRIDES_PACKAGES 删除虽然通过前面的方法基本上可以满足我们的需求了，但是需要修改系统原生的配置，不好维护。后来发现一种更好维护的方法。在 device/qiushao 目录下添加 Android.mk 里面添加一个模块 remove_unused_module 12345678910111213141516171819include $(CLEAR_VARS)LOCAL_MODULE :&#x3D; remove_unused_moduleLOCAL_MODULE_TAGS :&#x3D; optionalLOCAL_MODULE_CLASS :&#x3D; FAKELOCAL_MODULE_SUFFIX :&#x3D; $(COMMON_ANDROID_PACKAGE_SUFFIX)LOCAL_OVERRIDES_PACKAGES +&#x3D; \\ Contacts \\ Emailinclude $(BUILD_SYSTEM)&#x2F;base_rules.mk$(LOCAL_BUILT_MODULE): $(hide) echo &quot;Fake: $@&quot; $(hide) mkdir -p $(dir $@) $(hide) touch $@PACKAGES.$(LOCAL_MODULE).OVERRIDES :&#x3D; $(strip $(LOCAL_OVERRIDES_PACKAGES)) 这里需要注意的是 $(hide) echo &quot;Fake: $@&quot; 前面是 TAB，不是空格， Makefile 语法的要求。 然后在 device/qiushao/pure/pure.mk 里面添加 1PRODUCT_PACKAGES +&#x3D; remove_unused_module 将要去掉的模块添加到 LOCAL_OVERRIDES_PACKAGES 就可以了，统一管理，很方便。下面来验证一下。把 out/target/product/pure/system 目录删除，然后重新编译，运行，发现Contacts，Email这两个应用的确是不见了。 3. LOCAL_OVERRIDES_PACKAGES 原理LOCAL_MODULE_CLASS := FAKE 指定编译输出的目录为 $(PRODUCT_OUT)/fake_packages， 也就是不会打包到系统里面。LOCAL_OVERRIDES_PACKAGES 定义本模块要覆盖的模块，也就是本模块被编译的话，被覆盖的模块就不会被编译了。 3.1 Android 8.0Android 8.0 版本的代码在 main.mk 里面有对 OVERRIDES_PACKAGES 进行处理： 123456789# Some packages may override others using LOCAL_OVERRIDES_PACKAGES.# Filter out (do not install) any overridden packages.overridden_packages :&#x3D; $(call get-package-overrides,$(modules_to_install))ifdef overridden_packages# old_modules_to_install :&#x3D; $(modules_to_install) modules_to_install :&#x3D; \\ $(filter-out $(foreach p,$(overridden_packages),$(p) %&#x2F;$(p).apk %&#x2F;$(p).odex %&#x2F;$(p).vdex), \\ $(modules_to_install))endif modules_to_install 是所有要编译的模块，overridden_packages 就是指要覆盖的模块了，一般来说是通过在各模块的 Android.mk 里面通过 LOCAL_OVERRIDES_PACKAGES 指定的。filter-out 就是过滤掉。这段代码的意思就是将 overridden_packages 从 modules_to_install 中删除掉。 3.2 Android 10.0Android 10.0 的时候对 main.mk 进行了大修改。对 OVERRIDES_PACKAGES 进行处理为： 12345678910111213141516171819202122232425262728293031323334353637383940414243# Lists most of the files a particular product installs, including:# - PRODUCT_PACKAGES, and their LOCAL_REQUIRED_MODULES# - PRODUCT_COPY_FILES# The base list of modules to build for this product is specified# by the appropriate product definition file, which was included# by product_config.mk.# Name resolution for PRODUCT_PACKAGES:# foo:32 resolves to foo_32;# foo:64 resolves to foo;# foo resolves to both foo and foo_32 (if foo_32 is defined).## Name resolution for LOCAL_REQUIRED_MODULES:# If a module is built for 2nd arch, its required module resolves to# 32-bit variant, if it exits. See the select-bitness-of-required-modules definition.# $(1): product makefiledefine product-installed-files $(eval _mk :&#x3D; $(strip $(1))) \\ $(eval _pif_modules :&#x3D; \\ $(PRODUCTS.$(_mk).PRODUCT_PACKAGES) \\ $(if $(filter eng,$(tags_to_install)),$(PRODUCTS.$(_mk).PRODUCT_PACKAGES_ENG)) \\ $(if $(filter debug,$(tags_to_install)),$(PRODUCTS.$(_mk).PRODUCT_PACKAGES_DEBUG)) \\ $(if $(filter tests,$(tags_to_install)),$(PRODUCTS.$(_mk).PRODUCT_PACKAGES_TESTS)) \\ $(if $(filter asan,$(tags_to_install)),$(PRODUCTS.$(_mk).PRODUCT_PACKAGES_DEBUG_ASAN)) \\ $(call auto-included-modules) \\ ) \\ $(eval ### Filter out the overridden packages and executables before doing expansion) \\ $(eval _pif_overrides :&#x3D; $(call module-overrides,$(_pif_modules))) \\ $(eval _pif_modules :&#x3D; $(filter-out $(_pif_overrides), $(_pif_modules))) \\ $(eval ### Resolve the :32 :64 module name) \\ $(eval _pif_modules_32 :&#x3D; $(patsubst %:32,%,$(filter %:32, $(_pif_modules)))) \\ $(eval _pif_modules_64 :&#x3D; $(patsubst %:64,%,$(filter %:64, $(_pif_modules)))) \\ $(eval _pif_modules_rest :&#x3D; $(filter-out %:32 %:64,$(_pif_modules))) \\ $(eval ### Note for 32-bit product, 32 and 64 will be added as their original module names.) \\ $(eval _pif_modules :&#x3D; $(call get-32-bit-modules-if-we-can, $(_pif_modules_32))) \\ $(eval _pif_modules +&#x3D; $(_pif_modules_64)) \\ $(eval ### For the rest we add both) \\ $(eval _pif_modules +&#x3D; $(call get-32-bit-modules, $(_pif_modules_rest))) \\ $(eval _pif_modules +&#x3D; $(_pif_modules_rest)) \\ $(call expand-required-modules,_pif_modules,$(_pif_modules),$(_pif_overrides)) \\ $(filter-out $(HOST_OUT_ROOT)&#x2F;%,$(call module-installed-files, $(_pif_modules))) \\ $(call resolve-product-relative-paths,\\ $(foreach cf,$(PRODUCTS.$(_mk).PRODUCT_COPY_FILES),$(call word-colon,2,$(cf))))endef 其中 _pif_modules 变量保存了所有要安装到系统的模块。_pif_overrides 变量保存了所有被 overridden 的模块。$(eval _pif_modules := $(filter-out $(_pif_overrides), $(_pif_modules)))这行的意思就是把 _pif_overrides 模块从 _pif_modules 模块中删除。 获取所有被 overridden 的模块方法： 123define module-overrides$(foreach m,$(1),$(PACKAGES.$(m).OVERRIDES) $(EXECUTABLES.$(m).OVERRIDES) $(SHARED_LIBRARIES.$(m).OVERRIDES))endef 从这个函数来看目前我们可以 OVERRIDES 的模块类型有 PACKAGES, EXECUTABLES, SHARED_LIBRARIES。如果我们需要 OVERRIDES 其他类型的模块的话，扩展 module-overrides 这个函数就行。","categories":[{"name":"Android系统开发入门","slug":"Android系统开发入门","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发入门-5.添加预编译模块","slug":"Android系统开发入门/5-添加预编译模块","date":"2019-12-10T14:26:26.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2019/12/10/Android系统开发入门/5-添加预编译模块/","link":"","permalink":"http://qiushao.net/2019/12/10/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/5-%E6%B7%BB%E5%8A%A0%E9%A2%84%E7%BC%96%E8%AF%91%E6%A8%A1%E5%9D%97/","excerpt":"","text":"在实际的系统开发过程中，有很多文件都是预先编译好的，比如第三方APK，so库, jar包， bin 文件，配置文件等。我们需要在系统编译时能把这些文件打包编译到系统镜像里面。我们有两种方法可以达到我们的目的： PRODUCT_COPY_FILES 和 定义 prebuilt 模块。 如果这个文件只需要预置到指定目录就可以了，那我们就可以简单的将其加入 PRODUCT_COPY_FILES 变量就行， 比如一些 bin 文件， 配置文件。 如果这个文件有其他模块编译依赖，或者这个文件需要系统签名，那我们就得定义一个预编译模块，比如一些 so 库，APK 文件， jar 包等。 1. PRODUCT_COPY_FILES我们先来学习简单的方式 PRODUCT_COPY_FILES。PRODUCT_COPY_FILES 变量值可以在 $product.mk 文件里面设置， 在我们这个例子里面是 pure.mk 文件。但如果我们需要内置的文件很多，全部都写在 $product.mk 里面的话，可能就会很乱。所以为了维护方便，我们一般把 PRODUCT_COPY_FILES 的设置提取到一个单独的文件。在 $product.mk 里面 include 就行。下面以内置一个 busybox bin 文件为例子。 1.1 建立 prebuilt 目录层级我们把 prebuilt 的文件都放到 device/qiushao/pure/prebuilt 目录，prebuilt 目录也建立不同层级的目录，放置不同类型的文件： 123456prebuilt├── apk # 预置 apk 模块├── libs # 预置库模块，so 库， jar 包等└── vendor # PRODUCT_COPY_FILES 类型预置，按实际输出路径组织 └── bin └── busybox-i686 1.2 下载 busybox bin 文件把 busybox 放在 prebuilt/vendor/bin 目录 12cd prebuilt&#x2F;vendor&#x2F;binwget https:&#x2F;&#x2F;busybox.net&#x2F;downloads&#x2F;binaries&#x2F;1.21.1&#x2F;busybox-i686 1.3 添加 product_copy_files.mk在 device/qiushao/pure 目录下新建 product_copy_files.mk 文件，内容如下： 123456# product copy filesLOCAL_PREBUILD_DIR :&#x3D; device&#x2F;qiushao&#x2F;pure&#x2F;prebuiltPRODUCT_COPY_FILES +&#x3D; \\ $(LOCAL_PREBUILD_DIR)&#x2F;vendor&#x2F;bin&#x2F;busybox-i686:vendor&#x2F;bin&#x2F;busybox 然后在 pure.mk 里面include 1include device&#x2F;qiushao&#x2F;pure&#x2F;product_copy_files.mk 这样就添加完啦，以后只要在 product_copy_files.mk 增加要预置的文件即可。编译验证一下，发现 adb shell 可以用 busybox 命令了。 2. 定义 prebuilt 模块定义一个预编译模块和上一节中定义一个普通的编译模块格式相似，不同的是 srcs 变量指定的不是源文件，而是二进制文件的路径。下面是常见预编译模块的写法。 2.1 java 库12345678910java_import &#123; name: &quot;api.pure&quot;, installable: true, jars: [ &quot;api.pure.jar&quot;, ], libs: [ &quot;framework&quot;, ],&#125; 如果这个 jar 包需要安装到系统，则需要配置 installable 为 true。如果只是作为编译时提供接口而已， 则不需要设置 installable。更多的设置选项请参考 java_import 2.2 c/c++ 库Android.bp 形式： 12345678910111213141516cc_prebuilt_library_shared &#123; name: \"libpure_api\", export_include_dirs: [\"include\"], vendor: true, target: &#123; android_arm: &#123; srcs: [\"prebuilt/lib/libpure_api.so\"], &#125;, android_arm64: &#123; srcs: [\"prebuilt/lib64/libpure_api.so\"], &#125;, &#125;, shared_libs: [ \"liblog\", ],&#125; Android.mk 形式： 123456789include $(CLEAR_VARS)LOCAL_MODULE := libpure_api#32位、64位两者都编译LOCAL_SRC_FILES_32 := prebuilt/lib/libpure_api.soLOCAL_SRC_FILES_64 := prebuilt/lib64/libpure_api.soLOCAL_MULTILIB := both #取值为 32 / 64 / bothLOCAL_MODULE_CLASS := SHARED_LIBRARIESLOCAL_MODULE_SUFFIX := .soinclude $(BUILD_PREBUILT) 2.3 APK 文件目前我还不知道怎么使用 Android.bp 来定义一个 prebuilt apk 模块，查了一下资料也没有查到如何使用 Android.bp 来定义 prebuilt 模块。所以只能使用 Android.mk 来定义了。 123456789LOCAL_PATH :&#x3D; $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE :&#x3D; NetMusicLOCAL_SRC_FILES :&#x3D; $(LOCAL_MODULE).apkLOCAL_MODULE_TAGS :&#x3D; optionalLOCAL_MODULE_CLASS :&#x3D; APPS #模块类型为 apkLOCAL_CERTIFICATE :&#x3D; platform #使用系统签名LOCAL_MODULE_SUFFIX :&#x3D; .apkinclude $(BUILD_PREBUILT) 如果没有 so 库的话，就这么简单了。有 so 库的话，相对来说要麻烦一点，后面再专门讨论。","categories":[{"name":"Android系统开发入门","slug":"Android系统开发入门","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发入门-4.添加自定义模块","slug":"Android系统开发入门/4-添加自定义模块","date":"2019-11-22T14:26:26.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2019/11/22/Android系统开发入门/4-添加自定义模块/","link":"","permalink":"http://qiushao.net/2019/11/22/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/4-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/","excerpt":"","text":"早期的Android系统都是采用Android.mk的配置来编译源码，从Android 7.0开始引入Android.bp。很明显Android.bp的出现就是为了替换掉Android.mk。如果你从 Android7.0 的代码一路看到 Android10.0，你就会发现系统的各个模块正在逐步替换成 Android.bp。既然官方都在逐步弃用 Android.mk 了，那我们也跟随官方的脚步使用 Android.bp 来创建新模块。 1. 可执行文件:cc_binary下面我们以一个 hello world 模块为例来初步认识一下一个 Android.bp 模块的相关概念。在 device/qiushao/pure 目录下创建一个 hello 目录，创建 hello.cpp: 123456789101112#include &lt;cstdio&gt;#include &lt;android&#x2F;log.h&gt;#define LOG_TAG &quot;qiushao&quot;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,LOG_TAG ,__VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG ,__VA_ARGS__)int main() &#123; printf(&quot;hello qiushao\\n&quot;); LOGD(&quot;hello qiushao&quot;); return 0;&#125; 在 hello 目录下创建 Android.bp 12345678cc_binary &#123; &#x2F;&#x2F;模块类型为可执行文件 name: &quot;hello&quot;, &#x2F;&#x2F;模块名hello srcs: [&quot;hello.cpp&quot;], &#x2F;&#x2F;源文件列表 vendor: true, &#x2F;&#x2F;编译出来放在&#x2F;vendor目录下(默认是放在&#x2F;system目录下) shared_libs: [ &#x2F;&#x2F;编译依赖的动态库 &quot;liblog&quot;, ],&#125; 至此一个模块就已经添加完成了，接下来我们可以在 hello 目录下用 mm 命令测试一下是否可以编译通过 123456789101112131415161718192021222324252627qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10&#x2F;device&#x2F;qiushao&#x2F;pure&#x2F;hello$ mm -j&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;PLATFORM_VERSION_CODENAME&#x3D;RELPLATFORM_VERSION&#x3D;10TARGET_PRODUCT&#x3D;pureTARGET_BUILD_VARIANT&#x3D;engTARGET_BUILD_TYPE&#x3D;releaseTARGET_ARCH&#x3D;x86_64TARGET_ARCH_VARIANT&#x3D;x86_64TARGET_2ND_ARCH&#x3D;x86TARGET_2ND_ARCH_VARIANT&#x3D;x86_64HOST_ARCH&#x3D;x86_64HOST_2ND_ARCH&#x3D;x86HOST_OS&#x3D;linuxHOST_OS_EXTRA&#x3D;Linux-5.0.0-37-generic-x86_64-Ubuntu-18.04.3-LTSHOST_CROSS_OS&#x3D;windowsHOST_CROSS_ARCH&#x3D;x86HOST_CROSS_2ND_ARCH&#x3D;x86_64HOST_BUILD_TYPE&#x3D;releaseBUILD_ID&#x3D;QD1A.190821.011OUT_DIR&#x3D;out&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;[100% 7&#x2F;7] Install: out&#x2F;target&#x2F;product&#x2F;pure&#x2F;vendor&#x2F;bin&#x2F;hello#### build completed successfully (1 seconds) ####qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10&#x2F;device&#x2F;qiushao&#x2F;pure&#x2F;hello$ 在 device/qiushao/pure/pure.mk 中添加配置 1PRODUCT_PACKAGES +&#x3D; hello 添加这个配置之后，编译系统时就会自动编译并打包这个模块到系统里面。我们完整编译一下系统，运行虚拟机，然后连接 adb shell 执行刚刚添加的模块： 123456qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10$ adb shellpure:&#x2F; # hello hello qiushaopure:&#x2F; # which hello&#x2F;vendor&#x2F;bin&#x2F;hellopure:&#x2F; # 我们来回顾一下 Android.bp 的内容，也就几行配置而已，非常简单。当然其实还有非常多的配置我们并没有使用到。具体的配置项可以参考以下文档 cc_binary 2. c/c++ 库:cc_library1234567891011cc_library &#123; &#x2F;&#x2F;模块类型为c&#x2F;c++库， 会同时编译动态库和静态库， &#x2F;&#x2F;如果要指定编译动态库或者静态库，则应该要用 cc_library_shared 或者 cc_library_static name: &quot;libpure_utils&quot;, &#x2F;&#x2F;模块名 vendor: true, &#x2F;&#x2F;安装到 vendor 分区 export_include_dirs: [&quot;include&quot;], &#x2F;&#x2F;导出头文件目录，这样其他模块要使用本模块的时候，就不需要用 include_dirs 指定头文件目录了。 srcs: [&quot;src&#x2F;pure_log.cpp&quot;, &quot;src&#x2F;pure_thread.cpp&quot;], &#x2F;&#x2F;源文件列表, 如果不想要一个一个列出来， &#x2F;&#x2F;可以使用 srcs: [&quot;**&#x2F;*.cpp&quot;] 这种方式来查找所有的 cpp 文件。 shared_libs: [ &#x2F;&#x2F;依赖的动态库 &quot;liblog&quot;, ],&#125; 3. java 库:java_library1234567891011121314java_library &#123; &#x2F;&#x2F;模块类型为 java 库，这个类型与 java_library_static 是完全一样的 name: &quot;api.pure&quot;, &#x2F;&#x2F;模块名 installable: true, &#x2F;&#x2F;下面详细说明 enabled: true, &#x2F;&#x2F;是否编译这个模块，有时候我们需要根据某些条件，关闭某个模块。 dex_preopt: &#123; enabled: false, &#x2F;&#x2F;不做 preopt， &#125;, srcs: [ &quot;java&#x2F;**&#x2F;*.java&quot;, &#x2F;&#x2F;文件列表 ], libs: [ &quot;android.hidl.manager-V1.0-java&quot;, &#x2F;&#x2F;依赖的其他 java 库 ],&#125; 其中 installable 配置有必要作下说明，官方文档是这么写的： java_library builds and links sources into a .jar file for the device, and possibly for the host as well. By default, a java_library has a single variant that produces a .jar file containing .class files that were compiled against the device bootclasspath. This jar is not suitable for installing on a device, but can be used as a static_libs dependency of another module. Specifying installable: true will product a .jar file containing classes.dex files, suitable for installing on a device. 简单的说就是如果不指定 installable: true, 则编译出来的 jar 包里面是 .class 文件。这种包是没法安装到系统上的，只能给其他 java 模块作为 static_libs 依赖。指定 installable: true, 则编译出来的 jar 包里面是 classes.dex 文件。这种才是 Android 虚拟机可以加载的格式。 上面的这几个例子是最常见的模块。Android 系统中还有非常多种类型的模块。这里面就不一一举例了，需要定义其他类型的模块时，可以参考以下文档 soong。或者参考系统已有的 Android.bp 模块。 4. 模块编译输出分区前面的几个例子，我们只有输出到 system 或者 vendor 分区这两种选择， 其实系统还有其它几个目录可以输出的，下面对这些目录的作用及怎么指定模块的输出分区作下说明： system :主要包含 Android 框架， google 官方实现 Android.mk 默认就是输出到 system 分区，不用指定 Android.bp 默认就是输出到 system 分区，不用指定 vendor :SoC芯片商分区(系统级核心厂商，如高通), 为他们提供一些核心功能和服务，由 soc 实现 Android.mk LOCAL_VENDOR_MODULE := true Android.bp vendor: true odm :设备制造商分区（如华为、小米），为他们的传感器或外围设备提供一些核心功能和服务 Android.mk LOCAL_ODM_MODULE := true Android.bp device_specific: true product :产品机型分区 Android.mk LOCAL_PRODUCT_MODULE := true Android.bp product_specific","categories":[{"name":"Android系统开发入门","slug":"Android系统开发入门","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发入门-3.添加系统属性","slug":"Android系统开发入门/3-添加系统属性","date":"2019-11-20T14:26:26.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2019/11/20/Android系统开发入门/3-添加系统属性/","link":"","permalink":"http://qiushao.net/2019/11/20/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/3-%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7/","excerpt":"","text":"在 Android 系统中有一个 Property Service 服务， 这个服务对外提供了两个接口： SystemProperties.get(String key, String def) 读取系统属性 SystemProperties.set(String key, String val) 设置系统属性 有两个命令行对这两个接口进行了封装，我们可以直接在adb shell 中输入： getprop key 读取系统属性 setprop key val 设置系统属性 系统属性可以简单的理解为系统层级的全局变量，以 key-value 的形式保存， key-value 都是字符串。这些属性可能是有些资源的使用状态，进程的执行状态，系统的特有属性等。本文不会去分析系统属性服务的构架原理之类的东西，这些东西后面有时间再整理。这里先从编译系统的角度介绍应该怎么添加一个系统属性。比如增加一个系统版本号信息。在添加系统属性之前，我们先要了解一下系统属性的命名规则及系统属性文件路径。 特殊前缀属性 ro ：只读属性，不能修改。 persist ：修改属性后，重启依然有效。数据会保存到 /data/property 目录。其他前缀的属性被设置后，只是保存在内在中而已，并没有保存到磁盘，所以重启后就恢复默认值了。 ctrl ：用来启动和停止服务。每一项服务必须在 init.rc 中定义。init 一旦收到设置 ctrl.start 属性的请求，属性服务将使用该属性值作为服务名找到该服务，启动该服务。这项服务的启动结果将会放入 init.svc.&lt;服务名&gt; 属性中。 系统属性默认值配置文件系统启动的时候会从几个配置文件中加载属性的默认值，大概有以下几个文件， 在不同 Android 版本系统上可能不一样： /default.prop 或者是 /prop.default， /vendor/default.prop /system/build.prop /vendor/build.prop /data/local.prop /data/property/* 系统会按先后顺序依次加载以上文件，后加载的属性将覆盖原先的值。default.prop 的值是通过 build/tools 目录下的 buildinfo.sh 和 vendor_buildinfo.sh 生成的。要修改的话，就要修改编译系统了，这种方法不好维护，不推荐。一般来说我们可以把属性加到 /system/build.prop 或者 /vendor/build.prop。 添加系统属性到 /system/build.prop只要在 $TARGET_DEVICE_DIR 目录创建一个 system.prop 文件，在里面添加属性即可。编译系统会把 $(TARGET_DEVICE_DIR)/system.prop 添加到 /system/build.prop 文件中去。在 device/qiushao/pure 目录下添加文件 system.prop: 1ro.pure.version&#x3D;1.0 然后重新编译系统， 编译完之后查看 out/target/product/pure/system/build.prop 文件， 发现并没有我们添加的属性。原来在 Android 9.0 之后，google不推荐把厂家定制的 property 加到 /system 分区了。只是在 device/qiushao/pure 目录下添加 system.prop 文件是没有作用的。 具体原因见 build/make/core/Makefile 391 行左右代码 123456ifdef TARGET_SYSTEM_PROPsystem_prop_file :&#x3D; $(TARGET_SYSTEM_PROP)$(info TARGET_SYSTEM_PROP &#x3D; $(TARGET_SYSTEM_PROP))elsesystem_prop_file :&#x3D; $(wildcard $(TARGET_DEVICE_DIR)&#x2F;system.prop)endif 我们在这里加了个 log ， 然后编译系统，发现 TARGET_SYSTEM_PROP 已经定义过了 1234&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;build&#x2F;make&#x2F;core&#x2F;Makefile was modified, regenerating...[ 99% 450&#x2F;451] finishing build rules ...TARGET_SYSTEM_PROP &#x3D; build&#x2F;make&#x2F;target&#x2F;board&#x2F;gsi_system.prop 因此，如果我们一定要把属性加到 /system/build.prop 的话，还需要在 device/qiushao/pure/BoardConfig.mk 添加以下配置才可以： 1TARGET_SYSTEM_PROP +&#x3D; device&#x2F;qiushao&#x2F;pure&#x2F;system.prop 添加之后，重新编译，再查看 out/target/product/pure/system/build.prop 文件，发现我们添加的属性已经在里面了： 123qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10$ cat out&#x2F;target&#x2F;product&#x2F;pure&#x2F;system&#x2F;build.prop | grep ro.purero.pure.version&#x3D;1.0qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10$ 添加系统属性到 /vendor/build.prop虽然通过上面的方法可以将属性添加到 /system/build.prop，但在 Android9.0 之后，更推荐把厂家私有属性添加到 /vendor/build.prop 中。通过 PRODUCT_PROPERTY_OVERRIDES 变量添加即可。编译系统会把 PRODUCT_PROPERTY_OVERRIDES 变量的值添加到 /vendor/build.prop 文件中去。具体代码位置在编译系统的 build/make/core/Makefile 文件 476 行左右： 12345678910111213# -----------------------------------------------------------------# vendor build.prop## For verifying that the vendor build is what we think it isINSTALLED_VENDOR_BUILD_PROP_TARGET :&#x3D; $(TARGET_OUT_VENDOR)&#x2F;build.propALL_DEFAULT_INSTALLED_MODULES +&#x3D; $(INSTALLED_VENDOR_BUILD_PROP_TARGET)ifdef property_overrides_split_enabledFINAL_VENDOR_BUILD_PROPERTIES +&#x3D; \\ $(call collapse-pairs, $(PRODUCT_PROPERTY_OVERRIDES))FINAL_VENDOR_BUILD_PROPERTIES :&#x3D; $(call uniq-pairs-by-first-component, \\ $(FINAL_VENDOR_BUILD_PROPERTIES),&#x3D;)endif # property_overrides_split_enabled 在 device/qiushao/pure/pure.mk 中添加以下配置： 1234PRODUCT_PROPERTY_OVERRIDES +&#x3D; \\ ro.vendor.pure.name&#x3D;qiushao \\ persist.vendor.pure.name&#x3D;qiushao \\ vendor.pure.name&#x3D;qiushao 然后重新编译系统，查看 out/target/product/pure/vendor/build.prop 发现属性已经添加进去了。 12345qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10$ cat out&#x2F;target&#x2F;product&#x2F;pure&#x2F;vendor&#x2F;build.prop | grep pure.namero.vendor.pure.name&#x3D;qiushaopersist.vendor.pure.name&#x3D;qiushaovendor.pure.name&#x3D;qiushaoqiushao@qiushao-pc:~&#x2F;source&#x2F;android-10$ 虚拟机验证启动虚拟机后，再另外启动一个终端使用 adb shell 1234567891011121314151617pure:&#x2F; # getprop ro.pure.version 1.0pure:&#x2F; # getprop ro.vendor.pure.nameqiushaopure:&#x2F; # getprop persist.vendor.pure.name qiushaopure:&#x2F; # getprop vendor.pure.name qiushaopure:&#x2F; # setprop ro.pure.version 2.0 setprop: failed to set property &#39;ro.pure.version&#39; to &#39;2.0&#39;pure:&#x2F; # setprop persist.vendor.pure.name shaoqiupure:&#x2F; # setprop vendor.pure.name shaoqiupure:&#x2F; # getprop persist.vendor.pure.nameshaoqiupure:&#x2F; # getprop vendor.pure.nameshaoqiupure:&#x2F; # reboot 我们先用 getprop 命令读取了我们添加的属性，都可以正常读取。然后我们尝试用 setprop 命令改写属性的值， 发现 ro 前缀的属性改写失败了，其他属性可以改写成功。然后我们重启一下系统再重新读取： 12345pure:&#x2F; # getprop persist.vendor.pure.nameshaoqiupure:&#x2F; # getprop vendor.pure.nameqiushaopure:&#x2F; # 我们发现 persist 前缀的属性跟重启前的值一致，而非 persist 前缀的值恢复原样了。从这几个实验来看我们之前的结论一样。","categories":[{"name":"Android系统开发入门","slug":"Android系统开发入门","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发入门-2.添加product","slug":"Android系统开发入门/2-添加product","date":"2019-11-19T14:26:26.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2019/11/19/Android系统开发入门/2-添加product/","link":"","permalink":"http://qiushao.net/2019/11/19/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/2-%E6%B7%BB%E5%8A%A0product/","excerpt":"","text":"前面我们都是编译 Android 内置的 product 进行验证的，但真正做产品的时候，我们通常是需要添加自己的 product的。一般来说一个 product 有四个要素: vendorsetup.sh : 把 product 添加到 lunch 选择项中 BoardConfig.mk : 芯片硬件相关配置，分区设置等 AndroidProducts.mk : 指定 product 配置 product.mk : 一个产品的软件相关的配置，比如内置哪些软件模块，由AndroidProducts.mk 中的PRODUCT_MAKEFILES指定 但在 Android 10 的时候 vendorsetup.sh 文件已经不需要了，对应的功能被移到了AndroidProducts.mk中。下面我们参考 aosp_x86_64 这个 product 来一步一步创建一个我们自己的 product。 1. 创建 device 目录上面我们说了一个 product 有四个要素，那这四个要素总得有个容身之处。在 Android 系统上，product 的四要素放在两个地方， 一个是 device 目录，用来给各厂商放 product 的。另一个是 build/target 目录，用来放 google 官方内置的 aosp product。build/target/product 里面放 AndroidProducts.mk, 跟 product.mk， build/target/board 里面放 BoardConfig.mk 等。 我们在 device 目录添加 product 就行。先创建 device 目录。目录结构按这种形式创建： device/[company]/[device] 1mkdir -p device&#x2F;qiushao&#x2F;pure 注意，这里我们说的是 device 目录， 而不是 prodcut 目录。我们可以这么理解， device 是硬件相关的芯片平台级配置， product 是软件相关的配置。一个 device 下面可以有多个 product，即同一块硬件板子上，可以内置不同的软件模块。 2. 新建板级配置 BoardConfig.mkBoardConfig.mk 包含了硬件芯片架构配置，分区大小配置等信息这里我们直接使用 aosp_x86_64 的 BoardConfig.mk 就行 1include $(SRC_TARGET_DIR)&#x2F;board&#x2F;generic_x86_64&#x2F;BoardConfig.mk 3. 新建 product 配置 pure.mk我们直接继承 aosp_x86_64 的 product 配置，再稍作修改就行 1234$(call inherit-product, $(SRC_TARGET_DIR)&#x2F;product&#x2F;aosp_x86_64.mk)PRODUCT_NAME :&#x3D; purePRODUCT_DEVICE :&#x3D; pure 其中 PRODUCT_NAME 跟 PRODUCT_DEVICE 是最重要的两个变量，需要我们自己重新赋值。PRODUCT_NAME 要保持跟配置文件名一致。编译输出目录就是由这个变量决定的。PRODUCT_DEVICE 跟BoardConfig.mk相关，编译系统会根据$(PRODUCT_DEVICE) 来加载对应目录下的BoardConfig.mk文件。 4. 新建 AndroidProducts.mkAndroidProducts.mk 中定义了变量 PRODUCT_MAKEFILES，列出了我们在第三步添加的 product 配置文件。在 Android 10 中还多了一个变量 COMMON_LUNCH_CHOICES。这个变量是用来取代 vendorsetup.sh 的作用的。 12345PRODUCT_MAKEFILES :&#x3D; \\ $(LOCAL_DIR)&#x2F;pure.mkCOMMON_LUNCH_CHOICES :&#x3D; \\ pure-eng 我们在 lunch 界面可以看到 pure-eng 这个选项，就是由这里的COMMON_LUNCH_CHOICES变量配置的。其中 pure 为 product name。这里我们可以添加多个 product，但为了简单起见，只添加一个就行。eng 为 build type。有以下几种配置： eng : 对应到工程版。编译打包所有模块。同时ro.secure=0， ro.debuggable=1， ro.kernel.android.checkjni=1，表示adbd处于ROOT状态，所有调试开关打开 userdebug : 对应到用户调试版。同时ro.debuggable=1，打开调试开关，但并没有放开ROOT权限 user : 对应到用户版。同时ro.secure=1，ro.debuggable=0，关闭调试开关，关闭ROOT权限。最终发布到用户手上的版本，通常都是user版。 5. 编译验证至此，我们就定义好了一个最简单的 product 出来了， 目录结构如下： 12345qiushao└── pure ├── AndroidProducts.mk ├── BoardConfig.mk └── pure.mk 接下来编译验证一下看看能否用虚拟机跑起来，如果跑不起来请仔细核对一下以上步骤是否有问题。 1234source build&#x2F;envsetup.shlunch pure-engmake -jemulator 启动虚拟机后我们看一下设置中的系统版本信息如下： product name， 编译时间都对上了，说明我们自己创建的 product 已经可以编译运行了。后面我们就可以慢慢的在这个 product 上加功能了。","categories":[{"name":"Android系统开发入门","slug":"Android系统开发入门","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发入门-1.Android系统源码下载编译","slug":"Android系统开发入门/1-Android系统源码下载编译","date":"2019-11-16T14:46:26.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2019/11/16/Android系统开发入门/1-Android系统源码下载编译/","link":"","permalink":"http://qiushao.net/2019/11/16/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/1-Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/","excerpt":"","text":"由于国情特殊，想要直接下载 Android 的源码是很费劲的事，需要搭梯子才行，但幸好有很多高校，企业都提供了 Android 源码的镜像，方便下载，我使用的是清华大学的镜像，为清华大学点赞。具体的使用说明参考清华大学开源镜像站使用说明即可。下面也记录一下自己的操作。 1. 安装 gitAndroid 的源码是使用 git 进行管理的， 所以我们先要安装 git 123sudo apt install gitgit config --global user.name &quot;qiushao&quot;git config --global user.email &quot;qiushaox@gmail.com&quot; 2. 下载 repo 工具Android 源码工程并不是单独的一个 git 仓库，而是由非常多的git仓库组成的。目前估计有上百个独立的git仓库。 要手动一个一个 clone 这些仓库是不可能的，所以 google 开发了一个 repo 工具，通过 repo 来下载所有的仓库，所有的代码。repo 的安装方法如下： 123456mkdir ~&#x2F;bincurl https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;git-repo -o ~&#x2F;bin&#x2F;repochmod +x ~&#x2F;bin&#x2F;repoecho &#39;export PATH&#x3D;$PATH:~&#x2F;bin&#39; &gt;&gt; ~&#x2F;.bashrc echo &#39;export REPO_URL&#x3D;&quot;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;git-repo&#x2F;&quot;&#39; &gt;&gt; ~&#x2F;.bashrcsource ~&#x2F;.bashrc 3. 下载 Android 源码1234mkdir -p ~&#x2F;source&#x2F;android-10cd ~&#x2F;source&#x2F;android-10repo init -u https:&#x2F;&#x2F;aosp.tuna.tsinghua.edu.cn&#x2F;platform&#x2F;manifest -b android-10.0.0_r8repo sync 具体要下哪个分支可以查看Android分支列表。 repo sync 要跑好几个小时，这个要看你的网速怎样了。 以后要更新代码的话，也只要执行 repo sync 命令即可。如果 sync 过程中出错了，只再跑 repo sync 即可。 4. 编译 Android 源码12345678910111213141516171819202122232425qiushao@qiushao-pc:~$ cd source&#x2F;android-10&#x2F;qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10$ source build&#x2F;envsetup.sh qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10$ lunch aosp_x86_64-eng&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;PLATFORM_VERSION_CODENAME&#x3D;RELPLATFORM_VERSION&#x3D;10TARGET_PRODUCT&#x3D;aosp_x86_64TARGET_BUILD_VARIANT&#x3D;engTARGET_BUILD_TYPE&#x3D;releaseTARGET_ARCH&#x3D;x86_64TARGET_ARCH_VARIANT&#x3D;x86_64TARGET_2ND_ARCH&#x3D;x86TARGET_2ND_ARCH_VARIANT&#x3D;x86_64HOST_ARCH&#x3D;x86_64HOST_2ND_ARCH&#x3D;x86HOST_OS&#x3D;linuxHOST_OS_EXTRA&#x3D;Linux-5.0.0-32-generic-x86_64-Ubuntu-18.04.3-LTSHOST_CROSS_OS&#x3D;windowsHOST_CROSS_ARCH&#x3D;x86HOST_CROSS_2ND_ARCH&#x3D;x86_64HOST_BUILD_TYPE&#x3D;releaseBUILD_ID&#x3D;QD1A.190821.011OUT_DIR&#x3D;out&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10$ make -j 如果我们已经知道要编译的 product 的名字了， 可以直接 lunch product_name 就行，不确定的话，就 lunch 不加参数，然后再选择要编译的 product。然后就是静静地等待编译完成了， Android10 的编译居然没有任何错误，一次性编译过了，看来 google 对编译这块做了不少改进，Android9.0以前总是会遇到各种各样的问题。大概花了40分钟。相比旧电脑速度提高了6倍这样。 5. 运行编译好的系统Android 系统源码里面预置了 emulator 虚拟机， 我们只要 source, lunch 完之后，就可以直接执行 emulator 命令。emulator 会自动找到 out 目录下对应的 product 目录下的镜像来启动 12345678910qiushao@qiushao-pc:~&#x2F;source&#x2F;android-10$ emulatoremulator: WARNING: Couldn&#39;t find crash service executable &#x2F;home&#x2F;qiushao&#x2F;source&#x2F;android-10&#x2F;prebuilts&#x2F;android-emulator&#x2F;linux-x86_64&#x2F;emulator64-crash-serviceemulator: WARNING: system partition size adjusted to match image file (3083 MB &gt; 800 MB)qemu_ram_alloc_user_backed: callemulator: INFO: boot completedemulator: INFO: boot time 9973 msemulator: Increasing screen off timeout, logcat buffer size to 2M.emulator: Revoking microphone permissions for Google App. 等待虚拟机启动完成，查看一下系统信息确认是我们刚刚编译的系统。product, 编译时间，用户名都能对上，说明是我们刚刚编译的系统了。","categories":[{"name":"Android系统开发入门","slug":"Android系统开发入门","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"Android系统开发入门-0.开发环境准备","slug":"Android系统开发入门/0-开发环境准备","date":"2019-11-15T14:46:26.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2019/11/15/Android系统开发入门/0-开发环境准备/","link":"","permalink":"http://qiushao.net/2019/11/15/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/0-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/","excerpt":"","text":"为了在家里编译 Android 系统，特意在双 11 的时候配置了一台新电脑，之前的旧笔记本也已经用了6年了，编译速度太慢了，也该下岗了。 硬件配置：CPU：AMD 3900X， 12核心24线程内存：32G， 编译 Android10 非常耗内存，编译过程中我留意了一下，有一段时间耗尽了所有的内存硬盘：1T SSD， 在固态硬盘上编译速度比机械硬盘速度翻倍 软件配置：操作系统：ubuntu18.04.3软件安装： 12apt-get install -y openjdk-8-jdksudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev libgl1-mesa-dev libxml2-utils xsltproc unzip 上面这个其实是 ubuntu 14.04 的安装软件， 有部分软件在 ubuntu 18.04 上已经没有了，可能会提示一下，这个没影响，不管它就是，继续安装其他软件就行。安装完上面这些软件编译环境就算是配置好了。 如果你安装的 linux 发行版本不是 ubuntu 或者是最新版本的话，编译环境的配置可能会比较麻烦，推荐使用 docker 来编译。请参考docker构建Android编译环境 Android源码版本：android-10.0.0_r8后面所有的 Android 系统开发系列文章都是基于 Android10 来实践验证的。跟其他版本的 Android 可能会有些差异。","categories":[{"name":"Android系统开发入门","slug":"Android系统开发入门","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"}]},{"title":"ubuntu 18.04 安装配置shadowsocks","slug":"Linux/ubuntu-shadowsocks","date":"2019-11-14T14:46:26.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2019/11/14/Linux/ubuntu-shadowsocks/","link":"","permalink":"http://qiushao.net/2019/11/14/Linux/ubuntu-shadowsocks/","excerpt":"","text":"有时候真想不明白当局者的想法是怎样的，屏蔽一些时事政治相关的或者一些不可描述的网站就算了，大家也都可以理解。但为什么连各大技术服务站点也一锅端了呢？github 访问越来越慢了， Android studio 建个工程，gradle 就得同步大半天， npm 也好不到哪去。想下个 Android的系统源码下不动，下个 Fuschia 的源码也下不动。 幸亏国内还有一些良心的学校，企业提供了各种开源镜像，才让我们的开发环境稍微改善。 Linux 系统软件源：http://mirrors.163.com/ npm 镜像：https://npm.taobao.org/ gradle, maven 镜像：https://maven.aliyun.com/mvn/view 代码托管：https://gitee.com/ Android源码镜像：https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/ 但有些场景还是需要搭梯子才能满足的，比如 google 搜索，查看最新 Android 开发文档， 下载 Fuschia 系统源码等。之前一直用 lantern，还买了会员，但今年也不太稳定了。于是改用 shadowsocks 试试，以下是折腾记录。 1. 安装配置 shadowsocks在 Linux 系统上可以通过 pip 安装命令行版本的 shadowsocks 12sudo apt install python-pipsudo pip install shadowsocks 任意目录新建配置文件 shadowsocks.json， 我就放在了自己的家目录 123456789&#123; &quot;server&quot;: &quot;代理服务器IP&quot;, &quot;server_port&quot;: 代理服务器端口, &quot;password&quot;: &quot;代理服务器访问密码&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;localPort&quot;: 1080, &quot;method&quot;: &quot;aes-256-cfb&quot;, &#x2F;&#x2F;代理服务器访问数据加密方式，根据自己配置ss 服务端时的配置自行填写 &quot;timeout&quot;:600&#125; 启动 shadowsocks 12345678910111213141516171819202122232425262728qiushao@qiushao-pc:~$ sudo sslocal -c ~&#x2F;shadowsocks.json -d startINFO: loading config from &#x2F;home&#x2F;qiushao&#x2F;shadowsocks.json2019-11-14 23:29:01 INFO loading libcrypto from libcrypto.so.1.1Traceback (most recent call last): File &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;sslocal&quot;, line 11, in &lt;module&gt; load_entry_point(&#39;shadowsocks&#x3D;&#x3D;2.8.2&#39;, &#39;console_scripts&#39;, &#39;sslocal&#39;)() File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;shadowsocks&#x2F;local.py&quot;, line 39, in main config &#x3D; shell.get_config(True) File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;shadowsocks&#x2F;shell.py&quot;, line 262, in get_config check_config(config, is_local) File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;shadowsocks&#x2F;shell.py&quot;, line 124, in check_config encrypt.try_cipher(config[&#39;password&#39;], config[&#39;method&#39;]) File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;shadowsocks&#x2F;encrypt.py&quot;, line 44, in try_cipher Encryptor(key, method) File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;shadowsocks&#x2F;encrypt.py&quot;, line 83, in __init__ random_string(self._method_info[1])) File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;shadowsocks&#x2F;encrypt.py&quot;, line 109, in get_cipher return m[2](method, key, iv, op) File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;shadowsocks&#x2F;crypto&#x2F;openssl.py&quot;, line 76, in __init__ load_openssl() File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;shadowsocks&#x2F;crypto&#x2F;openssl.py&quot;, line 52, in load_openssl libcrypto.EVP_CIPHER_CTX_cleanup.argtypes &#x3D; (c_void_p,) File &quot;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;ctypes&#x2F;__init__.py&quot;, line 379, in __getattr__ func &#x3D; self.__getitem__(name) File &quot;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;ctypes&#x2F;__init__.py&quot;, line 384, in __getitem__ func &#x3D; self._FuncPtr((name_or_ordinal, self))AttributeError: &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanupqiushao@qiushao-pc:~$ 啊哦，好像不太顺利，网上搜索一下 undefined symbol: EVP_CIPHER_CTX_cleanup，有很多人遇到这个错误。这个问题是由于在openssl1.1.0版本中，废弃了EVP_CIPHER_CTX_cleanup函数，如官网中所说： EVP_CIPHER_CTX was made opaque in OpenSSL 1.1.0. As a result,EVP_CIPHER_CTX_reset() appeared and EVP_CIPHER_CTX_cleanup() disappeared.EVP_CIPHER_CTX_init() remains as an alias for EVP_CIPHER_CTX_reset(). 解决方法： 把所有的 EVP_CIPHER_CTX_cleanup 都改成 EVP_CIPHER_CTX_reset 就行。 1sudo vim &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;shadowsocks&#x2F;crypto&#x2F;openssl.py 改完之后再运行一遍，这次提示运行成功了 12345qiushao@qiushao-pc:~$ sudo sslocal -c ~&#x2F;shadowsocks.json -d startINFO: loading config from &#x2F;home&#x2F;qiushao&#x2F;shadowsocks.json2019-11-14 23:40:23 INFO loading libcrypto from libcrypto.so.1.1startedqiushao@qiushao-pc:~$ 2. 配置系统代理打开系统设置 –&gt; 网络 –&gt; 网络代理 选择手动设置，按如下设置就行: 配置完之后，打开chrome浏览器我们发现已经可以愉快的玩耍了。但 firefox 不知为什么不行。反正也不用，就不管它了。如果你的目的只是在浏览器上科学上网而已，那到此已经完成了，后面的可以不用继续看了。 3. 安装配置 privoxyprivoxy 本身也是一个代理软件，我们有 shadowsocks 不就够了？为什么要用到这家伙？因为 shadowsocks 是 socks5 协议，但我们的终端只支持 http, https 协议。所以需要使用 privoxy 把socks 和 http 协议作下转换。这个安装配置也很简单： 12sudo apt install privoxysudo vim &#x2F;etc&#x2F;privoxy&#x2F;config 按下图来配置就行 配置完后重启一下 privoxy 就行 1sudo service privoxy restart 4. 终端代理配置在 ~/.bashrc 中加入以下配置 12345# proxy settingsexport http_proxy&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:8118&quot;export https_proxy&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:8118&quot;git config --global http.proxy http:&#x2F;&#x2F;127.0.0.1:8118git config --global https.proxy http:&#x2F;&#x2F;127.0.0.1:8118 然后 source ~/.bashrc 终端和git就可以科学上网啦。 123456789101112qiushao@qiushao-pc:~$ wget www.google.com--2019-11-15 21:32:29-- http:&#x2F;&#x2F;www.google.com&#x2F;Connecting to 127.0.0.1:8118... connected.Proxy request sent, awaiting response... 200 OKLength: 12913 (13K) [text&#x2F;html]Saving to: ‘index.html’index.html 100%[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;] 12.61K --.-KB&#x2F;s in 0s 2019-11-15 21:32:29 (381 MB&#x2F;s) - ‘index.html’ saved [12913&#x2F;12913]qiushao@qiushao-pc:~$ 想了解墙的基本原理及翻墙的基本原理的同学，可以参考下面这篇博客上网限制和翻墙基本原理","categories":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/categories/Linux/"}],"tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://qiushao.net/tags/shadowsocks/"}]},{"title":"ubuntu 18.04 docker构建Android编译环境","slug":"Linux/docker-aosp-build-env","date":"2019-11-14T04:46:26.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2019/11/14/Linux/docker-aosp-build-env/","link":"","permalink":"http://qiushao.net/2019/11/14/Linux/docker-aosp-build-env/","excerpt":"","text":"一般来说，使用 ubuntu 系统来编译 Android 系统会比较方便一点，问题会少一点，因为 google 官方就是在 ubuntu 上进行编译的，其他的发行版本没有验证过。但是官方使用的 ubuntu系统都是非常旧的版本，还停留在 14.04, 16.04 这些版本，现在我都装上18.04了，明年20.04都出来了。使用较新版本的ubuntu编译较旧版本的 Android也是比较折腾的。虽说都是 linux 内核的发行版本，但各发行版的各种工具链的版本差异是很大的，之前在 archlinux, deepin 15.5 上尝试过编译android 6.0， 这过程就出现了各种奇怪的编译错误。虽然这些编译错误只要慢慢用心查，还是能找到处理方法的，但就是太折腾了。所以后面自己搞了一套 docker 的编译环境。无论你用哪个 linux 发行版，都可以不用折腾这些编译环境了。这套环境我在 Android5.1, Android 6.0， Android 8.1 上都编译验证过，没问题。具体的使用方法如下。 安装 docker网上介绍 docker 的安装方法乱七八糟的，其实只要简单的一条命令就行了 12curl -sSL https:&#x2F;&#x2F;get.docker.com&#x2F; | shsudo usermod -aG docker qiushao 编译 docker 镜像我已经做好了一个可以用来编译 Android 各版本系统源码的 docker 镜像， 不想麻烦的话，直接用就行。 123git clone https:&#x2F;&#x2F;github.com&#x2F;qiushao&#x2F;aosp_builder.gitcd aosp_builderdocker build -t aosp_builder:V1.0 . 构建出来的镜像用户名为 builder, 如果想要了解这个镜像的环境是怎么构建的，可以参考一下 aosp_builder 里面的 Dockerfile 文件。 使用方法按上面的步骤操作完之后，应该生成一个 aosp_builder:V1.0 的docker 镜像了。创建容器： 1docker run -it --name aosp_builder -v ~&#x2F;source:&#x2F;home&#x2F;builder&#x2F;source -u builder aosp_builder:V1.0 &#x2F;bin&#x2F;bash 其中-v ~/source:/home/builder/source 参数是将宿主机目录 ~/source 映射到 docker 容器的 /home/builder/source 目录。因为我宿主机上 Android 的源码放在 ~/source这个目录里面了。 -u builder 表示使用 builder 用户登录，不指定的话，会使用 root 用户登录，最好不要用 root 登录，用 root 用户登录的话，编译时产生的文件用户属主就是 root 了，在宿主机上要编辑或删除这些编译生成的文件就得用 sudo 了。 其他参数的意义就不作详细说明了，想要了解的话请查阅 docker 使用文档。 电脑重启后， 我们之前创建的容器还存在的， 我们不需要重新创建容器， 只要启动之前创建的容器就行： 12docker start aosp_builderdocker exec -it aosp_builder &#x2F;bin&#x2F;bash 然后我们就可以按照 Android 的标准编译流程开编了","categories":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/categories/Linux/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"},{"name":"docker","slug":"docker","permalink":"http://qiushao.net/tags/docker/"}]},{"title":"永远不要返回局部变量的指针或引用","slug":"c++/nerver-return-reference-of-local-valuable","date":"2019-04-20T05:00:00.000Z","updated":"2020-12-27T01:22:23.748Z","comments":true,"path":"2019/04/20/c++/nerver-return-reference-of-local-valuable/","link":"","permalink":"http://qiushao.net/2019/04/20/c++/nerver-return-reference-of-local-valuable/","excerpt":"","text":"永远不要返回函数的局部变量的指针或引用，因为函数执行完之后，将释放分配给局部变量的内存，这段内存可能会被回收用作其他用途，也可能暂时不动，这是没法预测的。如果被回收用途其他用途了，那返回的指针就是一个野指针，要么读取的数据是错误的，要么出现内存访问异常错误。如果这段内存暂时还没被回收，那从指针读到的数据也还是正确的，但你没法预料下一秒是否会被回收了。举个例子： 12345678910111213#include &lt;iostream&gt;using namespace std;int *sum(int number1, int number2) &#123; int result &#x3D; number1 + number2; return &amp;result;&#125;int main() &#123; int *result &#x3D; sum(2, 3); cout&lt;&lt; &quot;2 + 3 &#x3D; &quot; &lt;&lt; *result&lt;&lt;endl; return 0;&#125; 这段代码在我的电脑上运行就会出现段错误，程序异常终止。那有时候我们真的需要返回一个局部变量的话，应该怎么办呢？有很多方法可以满足这种需求。 1. 静态局部变量 12345678910111213#include &lt;iostream&gt;using namespace std;int *sum(int number1, int number2) &#123; static int result &#x3D; number1 + number2; return &amp;result;&#125;int main() &#123; int *result &#x3D; sum(2, 3); cout&lt;&lt; &quot;2 + 3 &#x3D; &quot; &lt;&lt; *result&lt;&lt;endl; return 0;&#125; 静态局部变量存放在内存的全局数据区。函数结束时，静态局部变量不会消失，每次该函数调用时，也不会为其重新分配空间。它始终驻留在全局数据区，直到程序运行结束。静态局部变量的初始化与全局变量类似．如果不为其显式初始化，则C++自动为其初始化为0。静态局部变量与全局变量共享全局数据区，但静态局部变量只在定义它的函数中可见。 简单来说就是静态局部变量具有全局变量的生命周期，具有局部变量的作用域。在实际项目中我们一般推荐使用这种方式。 2. 全局变量1234567891011121314#include &lt;iostream&gt;using namespace std;static int result;int *sum(int number1, int number2) &#123; result &#x3D; number1 + number2; return &amp;result;&#125;int main() &#123; int *result &#x3D; sum(2, 3); cout&lt;&lt; &quot;2 + 3 &#x3D; &quot; &lt;&lt; *result&lt;&lt;endl; return 0;&#125; 在标准库中的 struct tm *localtime (const time_t *__timer) 实现就是返回的全局变量指针。建议优先考虑静态局部变量，如果非要使用全局变量的话，最好使用 static 把全局变量的作用域限制在本文件内。避免造成命名污染。 3. 动态申请内存123456789101112131415#include &lt;iostream&gt;using namespace std;int *sum(int number1, int number2) &#123; int *result &#x3D; new int; *result &#x3D; number1 + number2; return result;&#125;int main() &#123; int *result &#x3D; sum(2, 3); cout&lt;&lt; &quot;2 + 3 &#x3D; &quot; &lt;&lt; *result&lt;&lt;endl; delete result; return 0;&#125; 使用这种方法需要注意，由于用new申请的动态内存，调用者需要负责释放(delete)这段内存。否则就会造成内存泄漏。很多内存泄漏问题都是这种动态申请内存后忘了释放内存造成的。所以这种方法我们能避免就尽量避免。避免不了的话，则建议使用智能指针来自动管理内存的释放问题。 4. 智能指针123456789101112131415#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;shared_ptr&lt;int&gt; sum(int number1, int number2) &#123; shared_ptr&lt;int&gt; result(new int); *result &#x3D; number1 + number2; return result;&#125;int main() &#123; shared_ptr&lt;int&gt; result &#x3D; sum(2, 3); cout&lt;&lt; &quot;2 + 3 &#x3D; &quot; &lt;&lt; *result &lt;&lt;endl; return 0;&#125; 这种写法就不需要手动释放分配的内存。但这是 c++ 11 之后才支持的语法。在 android 系统中我们可以使用 sp 智能指针。对于内存占用比较大的对象来说，推荐使用智能指针。因为系统会自动释放内存， 而使用静态局部变量的话，内存就会一直被占用着。","categories":[{"name":"c++","slug":"c","permalink":"http://qiushao.net/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://qiushao.net/tags/c/"}]},{"title":"永远不要在构造函数和析构函数中调用虚函数","slug":"c++/do-not-call-virtual-function-in-constructor","date":"2019-04-07T08:00:00.000Z","updated":"2020-12-27T01:22:23.748Z","comments":true,"path":"2019/04/07/c++/do-not-call-virtual-function-in-constructor/","link":"","permalink":"http://qiushao.net/2019/04/07/c++/do-not-call-virtual-function-in-constructor/","excerpt":"","text":"今天在写一个 Android 的 native服务，一不小心就踩到了一个坑，案发现场太复杂，以下是一个简单的 demo： 12345678910111213141516171819202122232425262728293031#include &lt;string&gt;#include &lt;unistd.h&gt;using namespace std;class SqliteHelper &#123;public: SqliteHelper(const string &amp;dbPath, int dbVersion) &#123; int version &#x3D; 0; &#x2F;&#x2F;get db version from dbPath if (0 &#x3D;&#x3D; version) &#123; onCreate(); &#125; &#125; virtual void onCreate() &#123; printf(&quot;SqliteHelper onCreate\\n&quot;); &#125;&#125;;class SystemDB : public SqliteHelper &#123;public: SystemDB(const string &amp;dbPath, int dbVersion) : SqliteHelper(dbPath, dbVersion) &#123; &#125; virtual void onCreate() &#123; printf(&quot;SystemDB onCreate\\n&quot;); &#125;&#125;;int main() &#123; SqliteHelper *db &#x3D; new SystemDB(&quot;&#x2F;data&#x2F;vendor&#x2F;pure&#x2F;db&#x2F;system.db&quot;, 1); return 0;&#125; 我们先创建一个数据操作辅助类 SqliteHelper, 其中定义了一个虚函数 virtual void onCreate();然后我们创建了一个子类 SystemDB 继承了 SqliteHelper， 并覆写了 onCreate 方法。在 SqliteHelper 的构造函数中判断数据库的版本是不是 0， 如果是 0 的话， 就调用 onCreate 函数去创建数据库表。这里的 onCreate， 我们预期的应该是子类的实现， 即 SystemDB::onCreate()， 但实际上调用的却是父类的实现。运行结果如下： 1234&#x2F;home&#x2F;deep&#x2F;projects&#x2F;clion&#x2F;cppTest&#x2F;cmake-build-debug&#x2F;cppTestSqliteHelper onCreateProcess finished with exit code 0 一开始没加 log, 加上理所当然的认为调用的会是子类中的实现， 在这里折腾了一个多小时，数据库怎么都创建不出来。后面慢慢加了 log 才发现这里的坑。查了资料才发现原来 Scott 同学在&lt;Effective C++&gt;中早就大力宣传过：永远不要在构造函数和析构函数中调用虚函数 Item 9: Never call virtual functions during construction or destruction 1、you shouldn’t call virtual functions during construction or destruction, because the calls won’t do what you think, and if they did, you’d still be unhappy. If you’re a recovering Java or C# programmer, pay close attention to this Item, because this is a place where those languages zig, while C++ zags. 2、During base class construction, virtual functions never go down into derived classes. Instead, the object behaves as if it were of the base type. Informally speaking, during base class construction, virtual functions aren’t. 3、It’s actually more fundamental than that. During base class construction of a derived class object, the type of the object is that of the base class. Not only do virtual functions resolve to the base class, but the parts of the language using runtime type information (e.g., dynamic_cast (see Item 27) and typeid) treat the object as a base class type. An object doesn’t become a derived class object until execution of a derived class constructor begins. Upon entry to the base class destructor, the object becomes a base class object, and all parts of C++ — virtual functions, dynamic_casts, etc., — treat it that way. 我个人的理解是：当实例化一个子类对象时，首先进行父类部分的构造，然后再进行子类部分的构造。当在构造父类部分时，子类部分还没开始创建，从某种意义上讲此时它只是个基类对象，所以此时虚函数是基类的函数。假设在构造函数中虚函数仍然“生效”，即在父类的构造函数中调用的是子类的虚函数。那就有很大的可能会出现以下问题：子类的虚函数使用到子类的成员变量。此时子类的成员变量还没有初始化，就很有可能导致程序异常崩溃了。","categories":[{"name":"c++","slug":"c","permalink":"http://qiushao.net/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://qiushao.net/tags/c/"}]},{"title":"linux下玩街机游戏","slug":"Linux/mame-settings","date":"2019-01-21T13:20:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2019/01/21/Linux/mame-settings/","link":"","permalink":"http://qiushao.net/2019/01/21/Linux/mame-settings/","excerpt":"","text":"前几天啊标从南京过来深圳出差半个月，周末一起吃完晚饭后，决定去打两局桌球。打着桌球的时候，发现旁边刚好有两台街机，想起了以前大学时一起玩三国战纪的时光。便玩了一局劲爆刺激的三国战纪， 结束后意犹未尽，便回来电脑上折腾着怎么在 linux 下玩街机游戏。以下是折腾记录，系统为 linux deepin 15.9。 1. 安装 mame 街机模拟器这个在 deepin 的应用商店里面就有，直接安装就行， 版本为 0.195。 2. 下载三国战纪 rom网上到处找 rom， 下了好几个都不能用，最后在 mamecn.com 里面找了一个能用的三国战纪 ，下载后，把 kov.zip copy 到 /usr/share/games/mame/roms/ 目录。然后在终端执行 mame kov ，有错误提示： 123456deep@deep-PC:&#x2F;usr&#x2F;share&#x2F;games&#x2F;mame&#x2F;roms$ mame kovpgm_p02s.u20 NOT FOUND (tried in kov pgm kov)kov_igs027a.bin NOT FOUND (NO GOOD DUMP KNOWN) (tried in kov pgm kov)pgm_t01s.rom NOT FOUND (tried in kov pgm kov)pgm_m01s.rom NOT FOUND (tried in kov pgm kov)Fatal error: Required files are missing, the machine cannot be run. 网上搜索一下错误 pgm_p02s.u20 NOT FOUND ，原来是还要再下一个 pgm 模拟器的 rom 才行。 3. 下载 pgm 模拟器rom还是在 mamecn.com 里面找到的 rom pgm.zip，把 pgm.zip 也 copy 到 /usr/share/games/mame/roms/ 目录。再执行一下 mame kov 就可以正常跑起来啦网上很多教程没有提到这一步，一些同学遇到上面的错误就一脸蒙敝了。还有 rom 的版本要和 mame 的版本匹配才行，我也是找了好几个 rom 才最终跑起来的。 4. 按键配置直接输入 mame ，不带参数，就可以进入主界面。中间一列的下边有个选项 Configure Options –&gt; General Inputs –&gt; Player 1 Control 就是玩家 1 的按键配置了。只要配置上下左右， button1 ~ button4， 还有 start, select 就行， select 为投币， start 为开始。 5. 测试过的 rom附我在 0.195 版本 mame 上能正常玩的几个 rom: 链接：https://pan.baidu.com/s/1CUgZhgqu3g3GqNou8yn71Q 密码：txj8 12345pgm.zipneogeo.zipkov.zipkov2.zipkof97.zip 6. 连网对战目前 mame 只支持单机游戏，mame 是开源的， 有时间可以在 mame 的基础上增加一个网络对战的功能。要实现这样的功能就非常复杂了。大学时经常玩的街机对战平台是 SuperARC， 不过这个平台去年已经倒了。现在街机游戏已经没落了，这种平台没法盈利，就只能关门大吉了。我想做这么个网战平台的目的更多是怀旧与相关技术的学习应用而已。不过 2019 年估计是没有时间开始了， 看 2020 吧。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/tags/Linux/"},{"name":"Mame","slug":"Mame","permalink":"http://qiushao.net/tags/Mame/"}]},{"title":"正确获取shell脚本所在目录","slug":"Linux/get-shell-script-dir","date":"2019-01-12T15:00:00.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2019/01/12/Linux/get-shell-script-dir/","link":"","permalink":"http://qiushao.net/2019/01/12/Linux/get-shell-script-dir/","excerpt":"","text":"1. why，为什么我们要获取脚本所在的目录编写脚本时，经常需要知道脚本所在目录的位置，以便引用其他的资源或调用其他的脚本。因为这些资源的目录位置相对于当前脚本的位置是固定的。有同学就会问，既然它们的相对位置是固定的，那为什么我们不直接使用相对路径呢？因为你并不一定是在脚本所有的目录去运行脚本的！举个例子：有个工程的目录结构如下： 12345release -script -ftp.sh -ftp.conf -release.sh 现在，我需要在 release 目录下执行 release.sh 脚本。release.sh 脚本会调用同级目录下的 script/ftp.sh 去做一些工作。ftp.sh 需要用到 ftp.conf 配置文件。你会怎样实现呢？像下面这样子？release.sh： 1234#!&#x2F;bin&#x2F;bashecho &quot;call release.sh&quot;.&#x2F;script&#x2F;ftp.sh ftp.sh： 12345#!&#x2F;bin&#x2F;bashecho &quot;call ftp.sh&quot;echo &quot;working path &#x3D; $(pwd)&quot;cat .&#x2F;ftp.conf ftp.conf： 1this is ftp.conf content 这样子是有问题的，因为你是在 release 目录执行的 release.sh，所以当前所在的目录就是在 release 目录，而在 release.sh 中调用 script/ftp.sh，相当于起了一个子进程去执行 script/ftp.sh，子进程会继承父进程的环境变量！$PWD也不例外。也就是说 script/ftp.sh 脚本的 cat ./ftp.conf 中的 . 代表的是 release 目录！所以会找不到 ./ftp.conf： 12345qiushao@qiushao-PC:~&#x2F;project&#x2F;shell&#x2F;release$ .&#x2F;release.sh call release.shcall ftp.shworking path &#x3D; &#x2F;home&#x2F;qiushao&#x2F;project&#x2F;shell&#x2F;releasecat: .&#x2F;ftp.conf: No such file or directory 你或许会想，可不可以这么写呢: cat ./script/ftp.sh，可以是可以，但这样子损失了可移植性！假如 script 下面的脚本是一套通用的功能，其他工程也可以使用。那要移植到其他项目可能就需要修改这个路径。因为有可能其他项目是这么调用的：./foobar/script/ftp.sh。所以这种方法不推荐。那我们可不可以先进入 script 目录，再调用 ftp.sh，执行完 ftp.sh 后，再返回之前的目录呢，就像这样： 123cd script.&#x2F;ftp.shcd - 这样是可以，但增加了使用者的工作量，且使用者有可能会忘了准备工作和扫尾工作。所以这种方法也不推荐。最好的方法就是在 ftp.sh 中获取 ftp.sh 所在的目录的绝对路径:$SCRIPT_PATH，然后在 ftp.sh 中可以这么访问 ftp.conf： 1cat $SCRIPT_PATH&#x2F;ftp.conf 那么问题来了，我们怎么才能正确的获取到脚本所在的目录的绝对路径呢？ 2. how，如何正确获取脚本所在目录的绝对路径经过上面的讨论，我们已经确认必须要获取脚本所在的路径了。下面我们就讨论怎样才能正确的获取脚本所在目录的绝对路径。 2.1. pwd如果你是一个新手，可能会想，获取脚本所在的路径还不简单，pwd 命令啊。too young too simple。请看官方对 pwd 命令的解释： print name of current/working directory 这个命令是用来打印当前的工作路径，这里没有任何意思说明，这个目录就是脚本存放的目录。工作路径是与运行脚本的目录，以及在脚本中的 cd 命令相关的。并不是固定的。前面的例子可以说明这一点。所在这种方法是错误的。 2.2. $0另一个误人子弟的答案，是 $0，这个也是不对的，这个$0是Bash环境下的特殊变量，其真实含义是： Expands to the name of the shell or shell script. This is set at shell initialization. If bash is invoked with a file of commands, $0 is set to the name of that file. If bash is started with the -c option, then $0 is set to the first argument after the string to be executed, if one is present. Otherwise, it is set to the file name used to invoke bash, as given by argument zero.翻译如下：$0会扩展成 shell 或者 shell 脚本的名称。这是在 shell 初始化的时候设置的。如果 bash 是以调用一个脚本文件或命令启动的，$0就会被设置为脚本文件的名称。如果 bash 是以通过 -c参数启动的，那么$0就会被设置为将要被执行的字符串后面的第一个参数，如果有参数的话。除此以外，$0会被设置成调用bash的那个文件的名称。 如果看了解释有点晕的话，还是通过几个例子来看吧：还是用上面的例子，只将 script/ftp.sh 修改如下 1234#!&#x2F;bin&#x2F;bashecho &quot;call ftp.sh&quot;echo &quot;$0&quot; 执行 ./release.sh，结果如下： 123call release.shcall ftp.sh.&#x2F;script&#x2F;ftp.sh 看到没，$0 的值是 ./script/ftp.sh，也就是脚本的名称，这个名称并不一定是绝对路径。它是跟调用方式相关的。因为我们是这样的调用的：./script/ftp.sh，所以它就是：./script/ftp.sh。你可能会想，如果是这样的话，那我们就可以获取脚本的相对路径，然后进入这个路径，再调用 pwd 命令就可以获得脚本所在的路径啦：ftp.sh： 12345#!&#x2F;bin&#x2F;bashecho &quot;call ftp.sh&quot;current_path&#x3D;$(cd $(dirname $0);pwd)echo &quot;current_path&#x3D;$current_path&quot; 执行结果： 1234qiushao@qiushao-PC:~&#x2F;project&#x2F;shell&#x2F;release$ .&#x2F;release.sh call release.shcall ftp.shcurrent_path&#x3D;&#x2F;home&#x2F;qiushao&#x2F;project&#x2F;shell&#x2F;release&#x2F;script 嘿，好像是正确了。但别高兴太早，要是我们换一个调用方式呢，把 release.sh 改成这样： 12345#!&#x2F;bin&#x2F;bashecho &quot;call release.sh&quot;source .&#x2F;script&#x2F;ftp.sh#.&#x2F;script&#x2F;ftp.sh 执行结果就是： 1234qiushao@qiushao-PC:~&#x2F;project&#x2F;shell&#x2F;release$ .&#x2F;release.sh call release.shcall ftp.shcurrent_path&#x3D;&#x2F;home&#x2F;qiushao&#x2F;project&#x2F;shell&#x2F;release 这下傻了吧。为什么会这样呢。这里需要用到一个知识点：** 直接调用脚本(./script/ftp.sh)会起一个新的子进程去执行脚本，使用source ./script/fpt.sh的话，是在当前进行中执行脚本内容！ **。另外如果你有注意前面关于$0的解释的话，就会注意到一句话： $0是在 shell 进程初始化的时候设置的。 结合这两个知识点就能解释为什么使用 source ./script/ftp.sh 的方法会出错了。因为 source 一个脚本并不会另起一个新的 shell 进程。而 $0 是在这个 shell 进程启动时就设置的了，所以 $0 的值是 ./release 而不是 ./script/ftp.sh。 2.3. 正确的方法在尝试过了各种各样的错误方法之后，终于找到了正确的方法： 1SCRIPT_DIR&#x3D;$(cd $(dirname $&#123;BASH_SOURCE[0]&#125;); pwd) $BASH_SOURCE是一个数组，它的第0个元素是脚本的名称。具体请查看 man bash，搜索 BASH_SOURCE。不过这种方法的局限性在于只适用于 bash 其他 shell 不支持这个变量，例如 csh, zsh。还好，bash 是我们最常用的 shell。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://qiushao.net/tags/shell/"}]},{"title":"hexo 博客搭建","slug":"Hexo/hello-hexo","date":"2019-01-01T12:46:26.000Z","updated":"2020-12-27T01:22:23.744Z","comments":true,"path":"2019/01/01/Hexo/hello-hexo/","link":"","permalink":"http://qiushao.net/2019/01/01/Hexo/hello-hexo/","excerpt":"","text":"折腾了一圈，最终还是回到了原点，使用静态博客系统。以前用过 hexo，所以还是继续用它吧。 1. 安装 hexo直接参考hexo官网的安装说明就行，很简单，执行两行命令而已 12sudo apt install nodejs gitsudo npm install hexo-cli -g 2. 初始化博客1234hexo init qiushao.netcd qiushao.netnpm installhexo server 然后从头到尾看一遍 _config.yml 配置文件，看看哪些东西需要修改的，都一一修改了。 执行完以上几个步骤，一个最原始的 hexo 博客系统就已经搭建完成了，可以访问一下浏览器 http://localhost:4000/接下来是各种个性化的配置了。 3. 切换 pure 主题pure 是我见过的主题中最喜欢的了，经典的三列式布局。自带全文搜索，支持各种第三方评论系统。 1git clone https:&#x2F;&#x2F;github.com&#x2F;cofess&#x2F;hexo-theme-pure.git themes&#x2F;pure 修改 _config.yml 配置文件 123## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;# theme: landscapetheme: pure 重新启动一下 hexo server，就已经切换到 pure 主题啦。接下来要对主题作一系列的个性化配置。 3.1 启用全文检索1npm install hexo-generator-json-content --save 启用这个插件后，重新启动 hexo server，点击导航栏，头像下边的 search 输入框就可以进行全文检索了。 3.2 导航栏配置pure 主题相关的配置都在 themes/pure/_config.yml 文件里面，里面的配置基本一看就懂，一步步修改看效果就行。menu: 项用于配置左边的导航栏要显示哪些入口。我个人没有豆瓣书单，github 又没有拿得出手的项目，所以这两项给注释掉了。 3.3 开启文章章节目录导航文章章节目录导航的配置在 config 项 下的 toc， 默认就是开启的， 但是我们在文章详情页却看不到目录导航。因为，开启这个选项后，每篇文章头的配置都要加上 toc: true 才行，比如： 123456---title: hexo 博客搭建date: 2019-01-12 22:46:26tags: hexotoc: true--- 这个感觉有点不合理，一开就全开就行了，还要每篇文章都配置一下，太烦了，还可能会忘了。因此自己修改了一下主题的代码，首先查找一下 toc 相关的文件： 1grep -nr toc 从查找的结果上看有两个地方需要修改一下 layout/_partial/post/nav.ejs, layout/_partial/sidebar-toc.ejs。把这两个文件的 &amp;&amp; post.toc 条件给去掉就行。 3.4 评论系统推荐使用 Valine 作为评论系统，评论都放在自己的 leancloud 数据库上，使用其他的第三方平台评论系统的话，总担心平台突然GG了。使用方法很简单，只要在 leancloud 注册一个账号，然后新建一个应用。在应用管理页找到 appid, appkey 填到 themes/pure/_config.yml 里面的 valine 配置项即可。 1234valine: # Valine. https:&#x2F;&#x2F;valine.js.org appid: # your leancloud application appid appkey: # your leancloud application appkey visitor: true # 开启文章阅读量统计 下面还有一个 pv 的配置项，当开启 pv 配置项时， 不知为什么文章阅读量统计会失效。 3.5 分类，标签等页面不可访问按上面的步骤配置好后，这时左边导航栏的分类，标签，关于等页面是访问不了的。需要手动 copy blog_path/theme/pure/_source/ 目录下的所有文件夹到 blog_path/source/ 目录下才行。这里感觉可以优化一下，理论上来说这些布局文件直接放在 theme 里面就行了，没必要 copy 到 source 里面。 至此，基本上就都配置完了，遇到问题再补充。 搭建博客其实很简单，难的是持续不断的输出。善始者实繁，克终者盖寡，希望自己能做一个善始善终的人。以后不再折腾，专心内容的输出就行。 4. 发布安装 git 发布插件 1npm install hexo-deployer-git --save _config.yml 中配置发布仓库信息 1234deploy: type: git repo: git@github.com:qiushao&#x2F;qiushao.github.io.git branch: master 然后使用 hexo d 命令即可将静态站点上传到 github。 5. 自定义域名访问在 source 目录下添加一个 CNAME 文件，里面写上自己的域名即可。然后在域名解析添加一条 cname 规则，指向 qiushao.github.io 即可。 6. 添加RSS订阅1npm install hexo-generator-feed --save 修改根目录配置文件_config.yml，末尾添加以下配置 12345678910# Extensions## Plugins: http:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 修改主题配置文件 _config.yml，把 rss 功能打开就行 12345social: links: github: https:&#x2F;&#x2F;github.com&#x2F;qiushao rss: atom.xml link_tooltip: true # enable the social link tooltip, options: true, false","categories":[{"name":"hexo","slug":"hexo","permalink":"http://qiushao.net/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://qiushao.net/tags/hexo/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/categories/Linux/"},{"name":"QT","slug":"QT","permalink":"http://qiushao.net/categories/QT/"},{"name":"Android","slug":"Android","permalink":"http://qiushao.net/categories/Android/"},{"name":"Android系统开发入门","slug":"Android系统开发入门","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"},{"name":"Camera","slug":"Camera","permalink":"http://qiushao.net/categories/Camera/"},{"name":"hdmi","slug":"hdmi","permalink":"http://qiushao.net/categories/hdmi/"},{"name":"c++","slug":"c","permalink":"http://qiushao.net/categories/c/"},{"name":"Android系统开发进阶","slug":"Android系统开发进阶","permalink":"http://qiushao.net/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/"},{"name":"Java","slug":"Java","permalink":"http://qiushao.net/categories/Java/"},{"name":"hexo","slug":"hexo","permalink":"http://qiushao.net/categories/hexo/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qiushao.net/tags/Linux/"},{"name":"QT","slug":"QT","permalink":"http://qiushao.net/tags/QT/"},{"name":"gperftools","slug":"gperftools","permalink":"http://qiushao.net/tags/gperftools/"},{"name":"tcmalloc","slug":"tcmalloc","permalink":"http://qiushao.net/tags/tcmalloc/"},{"name":"内存泄漏","slug":"内存泄漏","permalink":"http://qiushao.net/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"name":"Android","slug":"Android","permalink":"http://qiushao.net/tags/Android/"},{"name":"Hi3519AV100","slug":"Hi3519AV100","permalink":"http://qiushao.net/tags/Hi3519AV100/"},{"name":"Camera","slug":"Camera","permalink":"http://qiushao.net/tags/Camera/"},{"name":"coredump","slug":"coredump","permalink":"http://qiushao.net/tags/coredump/"},{"name":"edid","slug":"edid","permalink":"http://qiushao.net/tags/edid/"},{"name":"hdmi","slug":"hdmi","permalink":"http://qiushao.net/tags/hdmi/"},{"name":"nfs","slug":"nfs","permalink":"http://qiushao.net/tags/nfs/"},{"name":"tftp","slug":"tftp","permalink":"http://qiushao.net/tags/tftp/"},{"name":"c++","slug":"c","permalink":"http://qiushao.net/tags/c/"},{"name":"静态代码检查","slug":"静态代码检查","permalink":"http://qiushao.net/tags/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5/"},{"name":"Kernel","slug":"Kernel","permalink":"http://qiushao.net/tags/Kernel/"},{"name":"docker","slug":"docker","permalink":"http://qiushao.net/tags/docker/"},{"name":"Java","slug":"Java","permalink":"http://qiushao.net/tags/Java/"},{"name":"maven","slug":"maven","permalink":"http://qiushao.net/tags/maven/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://qiushao.net/tags/shadowsocks/"},{"name":"Mame","slug":"Mame","permalink":"http://qiushao.net/tags/Mame/"},{"name":"shell","slug":"shell","permalink":"http://qiushao.net/tags/shell/"},{"name":"hexo","slug":"hexo","permalink":"http://qiushao.net/tags/hexo/"}]}